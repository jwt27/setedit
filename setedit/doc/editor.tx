\input texinfo  @c -*-texinfo-*-
@c Copyright (C) 1996-2003 by Salvador Eduardo Tropea.
@c The first 75 lines configures all, the rest is the real doc.

@comment %**start of header

@setfilename setedit.info
@set version 0.5.2
@set update-date 11 October 2003
@set update-month October 2003
@set name-author Salvador Eduardo Tropea

@set rh Robert H@value{ouml}hne
@macro RH{}
@value{rh}
@end macro

@settitle SET's editor v @value{version}
@footnotestyle separate
@paragraphindent asis
@iftex
@afourpaper
@end iftex

@comment %**end of header

@c ---- Includes according to the output format
@ifset html
@include set.htm
@clear text
@end ifset

@ifset text
@include set.txt
@clear html
@end ifset

@ifclear html
@ifclear text
@include set.txi
@end ifclear
@end ifclear

@macro SSET{}
@mail{@value{name-author},salvador@@inti.gov.ar}
@end macro
@set title-printed SET's Editor
@set minidesc-printed A friendly text editor
@set year-copyr 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@set info-file  setedit

@macro ikey{KEY,DESC}
@key{\KEY\}
@kindex \DESC\ | @key{\KEY\} |
@end macro

@c --------------------------------------------------------------
@c Now we have 3 different headers:
@c 1) For the printed manual, is called titlepage
@c 2) For Info files
@c 3) For HTML files
@c I tried to automate it.
@c --------------------------------------------------------------

@set text-pre1 @ @ @ This document describes the use of the SET's editor; this editor was designed for programmers and to be used alone or inside of the RHIDE.

@set text-pre2 @ @ @ This documentation may be freely distributed with the editor or the RHIDE package or any part thereof, provided this copyright notice is left intact on all copies.

@set text-pre3 @ @ @ Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.

@macro lista1
@itemize @bullet
  @item @sc{Andris Pavenis} <pavenis@@lanet.lv>@*
    (with a lot of patches and reports)

  @item @sc{Bernd Becker} <munin@@munin.inka.de>@*
    (with a lot of corrections to this text)
    
  @item @sc{Burton Radons} <loth@@pacificcoast.net>@*
    (with the new calculator, bug reports and ideas)
    
  @item @sc{Frank Donahoe} <fdonahoe@@wilkes1.wilkes.edu>@*
    (with a lot of corrections to this text)

  @item @sc{Grzegorz Adam Hankiewicz} <gradha@@users.sourceforge.net>@*
    (with tests and a lot of ideas)
    
  @item @sc{Ivan Baldo} <ibaldo@@adinet.com.uy>@*
    (Debian packages, tests and a lot of ideas)
    
  @item @sc{Marek Habersack} <grendel@@ananke.amu.edu.pl>@*
    (with tests and a lot of ideas)

  @item @sc{Molnar Laszlo} <molnarl@@cdata.tvnet.hu>@*
    (with the old calculator, tests and a lot of ideas)

  @item @sc{@value{rh}} <robert.hoehne@@gmx.net>@*
    (with some base routines, a lot of patches and reports)
@end itemize
@end macro

@macro titem4{NOM,COM,KEY,ALT}
@titemR{\NOM\,\COM\,\KEY\,\ALT\}
@kindex \COM\ @key{\KEY\}
@kindex \NOM\ @key{\KEY\}
@end macro

@macro titem3{NOM,COM,KEY}
@titemR{\NOM\,\COM\,\KEY\}
@kindex \COM\ @key{\KEY\}
@kindex \NOM\ @key{\KEY\}
@end macro

@macro refMenu{command,key}
Name of the command: \command\.@*
Assigned key: @kbd{\key\}
@paragraph{}
@kindex \command\ @key{\key\}
@end macro

@macro refMenu1{command}
Name of the command: \command\.
@paragraph{}
@kindex \command\ @key{From menu}
@end macro

@HeaderPage1{}
@ifinfo
@ifset html
@include editor.ctx
@end ifset
@top EDITOR
@end ifinfo
@HeaderPage2{}

@ifclear text
@ifclear html
Pressing F1 when selecting any item of the menu you'll get help about it.
@paragraph{}
@end ifclear
@end ifclear

@chapter Introduction

@value{text-pre1}
@paragraph{}

@value{text-pre2}
@paragraph{}

@value{text-pre3}
@paragraph{}

  People who helped me develop the editor (alphabetically sorted):
@paragraph{}

@lista1{}

  The editor is distributed under the GPL license. Please read the files
included in the source distribution for more information.
@paragraph{}

  This editor is included in the @RH{}'s RHIDE as a replacement for the
original Turbo Vision's editor class.
@paragraph{}

@section Copying

  The editor is distributed under the GPL license:
@paragraph{}

@format
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@end format

  A copy of the license should be in the package, if not please tell me.
@paragraph{}

@c when using something like What's, TeX is confused by the '
@section What is SETs Editor?

  SET's editor is an editor designed to be used by programmers; the main
target of the editor is C and C++ code but Pascal and Clipper are supported
too. Currently I'm trying to make it more general so it's useful not only
for programming
@paragraph{}

  The editor was designed to be very similar to the DOS standard editors for
C, especially to Borland's IDE editor. The editor supports a lot of
WordStar style commands plus some CUA commands, so if you have used any
editor that uses these kinds of commands you'll find my editor very
familiar. On the other hand if you have never used a DOS editor,
especially if you use VI on UNIX machines you'll feel lost. In this case
you may want to configure the keyboard.

@x{How to configure the keyboard}.
@paragraph{}

@section About the Author

@my-flag{}

The editor was created by @value{name-author} with some code contributed by
@RH{}

@display
E-Mail: @SSET{}

Telephone: (+5411) 4759-0013
Postal Address:
Salvador E. Tropea
Curapalig@value{uuml}e 2124
(1678) Caseros - 3 de Febrero
Prov: Buenos Aires
Argentina
@end display
@paragraph{}

@my-flag{}

@chapter Available commands and keys assignments

  In this section I will explain the features of the editor and the default
configuration for the keyboard. If you want to change an assignment of a
key consult "configure the keyboard".  @x{How to configure the keyboard}.
@paragraph{}

  Read the conventions topic first to understand my way of indicating
keystrokes.
@paragraph{}

  In the description of each command I'll include the internal name used by
the editor because this name is needed to configure the keyboard.
@paragraph{}

@section Conventions

  I'll use some conventions when talking about the keystrokes needed to
trigger some command. So here is what I use:
@paragraph{}

  The key named @key{Ctrl} or Control is represented as @samp{^}; this key doesn't have any
effect used alone inside of the editor so the @samp{^} symbol will be used only
in conjunction with the name of a key indicating that you must press the
two keys at the same time. For example, @kbd{^A} is @key{Ctrl} and @key{A} at the same time.
When I say "at the same time" that means: press @kbd{@key{Ctrl}}, hold it, and press
the other key; that's the reason to put @key{A} after @key{Ctrl}.
@paragraph{}

  To indicate a sequence of keystrokes I'll use a dash to separate the keys. For
example, @kbd{^K-B} is @key{Ctrl} and @key{K} at the same time, and then press @key{B}, of course
release @kbd{^K} first.
@paragraph{}

  To indicate keys pressed at the same time other than @kbd{^x} I'll use a plus.
For example, @kbd{Shift+^Insert} is the three keys at the same time!
@paragraph{}

  I don't think that you are stupid; the editor is written for programmers,
but I wanted to make that clear to avoid problems ;-).
@paragraph{}

@section Cursor movement
@cindex Movement

@table4{Action,Command,Key,Alternate}
@titem4{Character left,cmcCharLeft,Left arrow,^S}
@titem4{Character right,cmcCharRight,Right arrow,^D}
@titem4{Word left,cmcWordLeft,^Left arrow,^A}
@titem4{Word right,cmcWordRight,^Right arrow,^F}
@titem4{End of the word,cmcGoEndOfWord,,}
@titem4{Line up,cmcLineUp,Up arrow,^E}
@titem4{Line down,cmcLineDown,Down arrow,^X}
@titem3{Scroll the screen one line up,cmcScrollUp,^W}
@titem3{Scroll the screen one line down,cmcScrollDown,^Z}
@titem4{Page up,cmcPageUp,PgUp,^R}
@titem4{Page down,cmcPageDown,PgDn,^C}
@titem4{Beginning of line,cmcLineStart,Home,^Q-S}
@titem4{End of line,cmcLineEnd,End,^Q-D}
@titem4{Top of window,cmcFirstLineInScreen,^Q-E,^Home}
@titem4{Bottom of window,cmcLastLineInScreen,^Q-X,^End}
@titem4{Top of file,cmcTextStart,^Q-R,^PgUp}
@titem4{Bottom of file,cmcTextEnd,^Q-C,^PgDn}
@endtable-{}

@section Insert and Delete
@cindex Insert and Delete

@table4{Action,Command,Key,Alternate}
@titem4{Delete the character under cursor,cmcDelChar,Del,^G}
@titem4{Delete character to left,cmcBackSpace,Backspace,^H}
@titem3{Delete line,cmcDelLine,^Y}
@titem4{Delete to end of line,cmcDelEnd,^Q-Y,Shift+^Y}
@titem3{Delete to start of line,cmcDelStart,^Q-H}
@titem3{Delete word at right,cmcDelWord,^T}
@titem3{Delete word at left,cmcDelPrevWord,^Backspace}
@titem4{Insert line,cmcNewLine,Enter,^N}
@titem4{Insert mode on/off,cmcInsMode,Ins,^V}
@endtable-{}

  When you are in insert mode all the typed characters are inserted in the
text, but when the insert mode is off the typed characters replace the old
text. The editor starts with insert mode on. You can quickly know the mode
by the cursor shape. When the insert mode is on, the cursor is only a
line, but when it is off, the cursor is block shaped.
@paragraph{}

@section Blocks
@cindex Blocks

  A block is a selected portion of the text. You can copy, delete, @il{etc.@:} blocks
of text. The associated commands are:
@paragraph{}

@table4{Action,Command,Key,Alternate}
@titem3{Move to beginning of block,cmcGoBeginBlock,^Q-B}
@titem3{Move to end of block,cmcGoEndBlock,^Q-K}
@titem3{Set beginning of block,cmcStartSelect,^K-B}
@titem3{Set end of block,cmcEndSelect,^K-K}
@titem3{Hide/Show block,cmcHideSelect,^K-H}
@titem3{Mark line,cmcMarkLine,^K-L}
@titem3{Mark word,cmcMarkWord,^K-T}
@titem4{Delete block and copy it to the Clipboard,cmcCut,^K-Y,Shift+Del}
@titem3{Copy the selected block,cmcCopyBlock,^K-C}
@titem3{Move block,cmcMoveBlock,^K+V}
@titem3{Copy to Clipboard,cmcCopy,^Ins}
@titem3{Delete block,cmcClear,^Del}
@titem3{Paste from Clipboard,cmcPaste,Shift+Ins}
@titem4{Read block from disk,cmcReadBlock,^K-R,Shift+^R}
@titem4{Write block to disk,cmcWriteBlock,^K-W,Shift+^W}
@titem3{Replace the block by the Clipboard block,cmcReplaceSelect,Shift+^Ins}
@titem3{Convert to Uppercase,cmcToUpper,^K-M}
@titem3{Convert to Lowercase,cmcToLower,^K-O}
@titem3{Invert case,cmcInvertCase,none}
@titem3{Alternate case,cmcAltCase,none}
@titem3{Report the length of the block,cmcSelLength,^Q-L}
@endtable-{}

@subsection Block modes
@cindex Persistent Blocks

  There are two block modes. One is the mode that the old editor of RHIDE
used. This mode is used in CUA programs. The other is called Persistent
Blocks.
@paragraph{}

  In the normal mode each time you select a block and then insert anything
in it (with @code{cmcPaste} or by typing anything) the selected block is deleted
and is replaced by the new text.
@paragraph{}

  In persistent blocks the selection is not replaced and is not lost when
you move the cursor. From this comes the name "Persistent." In this mode
you can use @code{cmcMoveBlock} and @code{cmcCopyBlock} without using the Clipboard. In
addition you can apply indentations to the block (@x{Indentation}),
search only inside it, @il{etc.} That's what makes this mode much more powerful than
the former. If you really like to replace the selected text by the selection
of the Clipboard, that's the default behaviour of the first mode. You can use
the @code{cmcReplaceSelect} command to achieve the same in the Persistent Blocks
mode.
@paragraph{}

@subsection Selecting with the mouse or Shift

  The described commands for selecting a block, @code{cmcStartSelect} and @code{cmcEndSelect},
are good but not so quick. There are other ways to do this.
@paragraph{}

@subsubsection Using the mouse

  Using the mouse you need only point to the start place, and while pressing the
left button moving the mouse to the end point of your block.
@paragraph{}

  To select a word with the mouse just double click on it.
@paragraph{}

@subsubsection Using the Shift key

  Using the @key{Shift} key you only need to move the cursor to the start point,
keep @kbd{@key{Shift}} pressed and move the cursor to the end point with any of the
available cursor commands. @x{Cursor movement}.
@paragraph{}

@subsection Indentation
@cindex Indentation

  You can indent or unindent a block of text using various commands, but you
must keep in mind that for now the editor is limited in the following way:
@x{Real Tabs} If you are using tabs to indent your text, don't mix tabs with
spaces and, if you are using spaces to indent, don't mix them with real tabs.
@paragraph{}

@table4{Action,Command,Key,Alternate}
@titem4{Indent block one position adding a space,cmcIndentBlkOne,^K-I,Shift+^I}
@titem4{Unindent block one character - not an x position,cmcUnIndentBlkOne,^K-U,Shift+^U}
@titem3{Indent block,cmcIndentBlk,^K-Tab}
@titem3{Unindent block,cmcUnIndentBlk,^K-Shift+Tab}
@endtable-{}

@code{cmcUnIndentBlkOne} unindents deleting one char at the start of the line so,
if the line is indented with tabs, the line will retract one tab.
@paragraph{}

@code{cmcIndentBlk} acts according to the mode. If you are using tabs,
the editor will put one tab at the beginning of each line. If you aren't
using tabs the editor will operate the Tab command on the first line and
then will use this amount of indentation on the entire block. @x{Real Tabs}.
@paragraph{}

@code{cmcUnIndentBlk} acts according to the mode too. @x{Real Tabs} mode.
Just like @code{cmcUnIndentBlkOne} it deletes one tab but if you don't use
tabs the editor uses Backspace on the first used column of the first
line of the block and unindents by the resulting amount the rest of the
block.
@paragraph{}

The following commands aren't applied to the whole block, they apply only to
the line where the cursor is positioned.
@paragraph{}

@table3{Action,Command,Key}
@titem3{Smart Indent block,cmcSmartIndent,^Tab}
@titem3{Smart Unindent block,cmcSmartUnIndent,Shift+^Tab}
@endtable-{}

@code{cmcSmartIndent} and @code{cmcSmartUnIndent} indents take as reference the @{ @} pair
where the cursor is, for example:
@paragraph{}

@example
  @{
line1
     line2
   line3
  @}
@end example

After indenting line1 with @code{cmcSmartIndent} and line2 with @code{cmcSmartUnIndent}
you get:
@paragraph{}

@example
  @{
   line1
   line2
   line3
  @}
@end example

The indentation is made with spaces and you must put the cursor on the first
letter of the line, the l in this example.
@paragraph{}

@subsection Rectangular Blocks
@cindex Blocks - Rectangular

  The editor includes a mode where you can select a rectangular portion of
the text and copy, cut, clear, paste, move, @il{etc.@:} this region.
This tool is very useful for modifications on columns.
@paragraph{}

  Attention! The selected area is based on the X,Y coordinates. For this
reason if you insert lines before the bottom of the rectangle the area won't
be moved. I don't plan to move the area by now because that takes some CPU
and I think that this selection is made just before using it. So don't
report that like a bug. That is the way it works!
@paragraph{}

@table3{Action,Command,Key}
@titem3{Set beginning of block,cmcSelRectStart,^K-Shift+B}
@titem3{Set end of block,cmcSelRectEnd,^K-Shift+K}
@titem3{Hide/Show block,cmcSelRectHide,^K-Shift+H}
@titem3{Delete block and copy it to an special Clipboard,cmcSelRectCut,^K-ShiftT}
@titem3{Move block,cmcSelRectMove,^K+Shift+V}
@titem3{Copy to special Clipboard,cmcSelRectCopy,^K-Shift+C}
@titem3{Delete block,cmcSelRectDel,^K-Shift+L}
@titem3{Paste from special Clipboard,cmcSelRectPaste,^K-Shift+P}
@titem3{Convert to uppercase,cmcSelRectToUpper,}
@titem3{Convert to lowercase,cmcSelRectToLower,}
@endtable-{}

@section Miscellaneous keyboard commands

@table3{Action,Command,Key}
@titem3{Autoindent mode on/off,cmcIndentMode,^O}
@titem3{Find place marker,cmcGotoMarkn,^Q n*}
@titem3{Set marker,cmcPutMarkn,^K n*}
@titem3{Search for open curly bracket from where the cursor is,cmcSearchStart,^[}
@titem3{Search for close curly bracket from where the cursor is,cmcSearchEnd,^]}
@titem3{Search for ( from where the cursor is,cmcSearchOpPar,Shift+^9}
@titem3{Search for ) from where the cursor is,cmcSearchClPar,Shift+^0}
@titem3{Search for [ from where the cursor is,cmcSearchOpCor,Shift+^[}
@titem3{Search for ] from where the cursor is,cmcSearchClCor,Shift+^]}
@titem3{Search for the complementary pair,cmcSearchComplement,^Q ESC}
@titem3{Undo,cmcUndo,Alt+Backspace}
@titem3{PMacro's Trigger,cmcExpandCode,^Space}
@titem3{Goto Line,cmcGotoEditorLine,^J}
@titem3{Set the options for the current window (Not in RHIDE),cmcSetLocalOptions,Alt+L}
@titem3{Set the default options (Not in RHIDE),cmcSetGlobalOptions,Alt+G}
@titem3{Convert all tabs to spaces,cmcExpandAllTabs,From menu}
@titem3{Compact the text using tabs,cmcCompactBuffer,From menu}
@titem3{Start recording a macro,cmcRecordMacro,Shift+F10}
@titem3{Stop recording a macro,cmcStopMacro,Alt+F10}
@titem3{Play a macro,cmcPlayMacro,^F10}
@endtable-{}

@chapter Keyboard configuration

  The editor can be configured to trigger one or more commands pressing one key or an
arbitrary sequence of keys. Unlike old versions, now the sequence of keys isn't limited.
Additionally you no longer need to configure the editor for non-US keyboards.
@paragraph{}

  If you used an old version of the editor you'll note that now the keyboard
configuration is a lot easier and much more powerful.
@paragraph{}

@section How to configure the keyboard

 These options are located under the menu option called Tool&Ops, submenu
Options, submenu Keyboard, submenu Key assignment; yes is a little deep in the menu.
@paragraph{}

  After selecting this option you'll get a window with the keyboard assignments. This
window shows entries of the type @code{Key sequence -> Command sequence}. You can
delete an assignment by selecting it and choosing the @code{Delete} button.
@paragraph{}

  The list is sorted by a internal criteria. The keys with @key{Shift} have an @code{S}
in front, for @key{Ctrl} you'll see a @code{C} and for @key{Alt} an @code{A}. The editor
can distinguish the left and right @key{Alt} keys; if you enable it the right @key{Alt}
will be represented by an @code{a}. @x{Alt key configuration}.
@paragraph{}

  To add a new assignment press the @code{Add} button. A window called @il{Sequence of
keys} will appear. This window is used to choose the sequence of keys that will trigger
an action in the editor. The sequence can be as large as you want, so if you want to
assign a sequence like this: @kbd{^A-Shift+^Insert-Alt+Z} you can, but I doubt you
really want to use such a complex combination even if the editor is flexible enough
to allow it.
@paragraph{}

  To add a new key to the sequence use the @code{Add} button, to delete a key use the
@code{Delete} button. The @code{Add} button always adds a key to the end of the list; to
insert a key in the sequence use the @code{Insert} button, it will insert the
key before the selected key. Finally you can choose if you want to assign a
sequence of commands or a sLisp macro to this key sequence. @x{sLisp macros}.
@paragraph{}

@subsection Assigning a sequence of commands

  A window called @il{Commands} will appear. The mechanism to add, insert and delete
commands is the same as used for a keyboard sequence. This time when you add or insert
a new command to the sequence a window with all the available commands will pop-up.
The meaning of each command can be found in the indices of this help.
@paragraph{}

  To make a selection with the commands, like when holding @key{Shift}, you must use
the @code{SelectOn} and @code{SelectOff} commands. For an example you can take a
look at the assignments for the @kbd{Shift+Left} or @kbd{Shift+Right} keys.
@paragraph{}

@subsection Assigning a sLisp macro
@cindex macros.slp

  A window called @il{Macros} will appear. This window shows all the macros defined in
the @file{macros.slp} file. @x{sLisp macros}.
@paragraph{}

  The main advantage of using macros instead of command sequence is that macros can
insert text in your code.
@paragraph{}

@subsection Assigning sLisp code
@cindex slisp code to a key

  A window called @il{sLisp code} will appear. This window shows allows
entering a small portion of sLisp code. For long code use define a macro.
@x{sLisp macros}.
@p{}

  The sLisp code must start with @code{(} and end with @code{)} or you'll get
parser errors.
@p{}

@section Alt key configuration

  The editor can distinguish the left and right @key{Alt} keys. As old versions didn't
allowed that and as different users use different @key{Alt} keys the editor doesn't
make any difference between them anymore by default.
@paragraph{}

  The @il{Setup Alt keys} menu option (under Tool&Ops | Options | Keyboard) allows to
enable it. Three options are offered:
@paragraph{}

@table2{Option,Meaning}
@titemR{Left Alt,The menues are tiggered by the left Alt and you can use the right Alt
for commands}
@titemR{Right Alt,The reverse as for Left Alt - right Alt activates menues\, left Alt commands}
@titemR{Both Alt,Both keys can be used for menues}
@endtable-{}

@section Restoring the default keyboard assignments

  If you need to restore the original keyboard assignment because you did something very
wrong you can use this option for that. The option is located under Tool&Ops | Options
| Keyboard.

@section Consulting scan codes

  If you need to know the scan code of a key for your program you don't need to use a
table or another program. The editor has a tool built in that shows scancodes for
keypresses under Tool&Ops | Options | Keyboard.

@c --------------------------------------------------------------------------
@c --------------------------------------------------------------------------
@chapter Pull-down menues

The menues are configurable; for this reason the following structure is just
one of many possible arrangements.
@paragraph{}

If you need or want to configure the shortcuts activating the menues or
menue options look at the @file{menubind.smn} file. The format is self explanatory
and the editor supports syntax highlighting for these files.
@paragraph{}

@c --------------------------------------------------------------------------
@section File

This menu contains the file operations (save, load, print, @il{etc.@:}) and
the program exit functions.
@paragraph{}

@c --------------------------------------------------------------------------
@subsection Open

This option brings the file open dialog (@x{File Open}). From this dialog you can select
a file to load and edit.
@paragraph{}

Choose the Open button or select a file with @kbd{@key{Enter}} to open the
file. Use @kbd{@key{Esc}} to abort.
@paragraph{}

If the file is read-only a dialog will ask you if you want to make the file
writable, in this case the editor will try to change the file attributes. Not
always is it possible to change these attributes, as for example, the CDs are
read-only and obviously you can't change files on them.
@paragraph{}

@refMenu{cmeOpen,F3}

@c --------------------------------------------------------------------------
@subsection New

Use this option to create a new and empty editor window. The window's name will
be @il{Untitled}.
@paragraph{}

An alternative way to do it is just using the @il{Open} option and give a new name
instead of selecting an existing file. @x{Open}. The advantage of this
method is that the new window already has a meaningful name, instead of
having to save the file first.
@paragraph{}

@refMenu1{cmeNew}

@c --------------------------------------------------------------------------
@subsection Open Read-only copy

Use this option to open a copy of the file you are editing in another window.
@paragraph{}

Be careful, the new copy is loaded from disk so it may be unsychronized. The
copy will automatically become read-only so you won't be able to modify it
and accidentally overwrite the first copy.
@paragraph{}

For more information: @x{Editor General}.
@paragraph{}

@refMenu1{cmeOpenROCopy}

@c --------------------------------------------------------------------------
@subsection Save

This option saves the contents of the current window. Only the contents of
this window are saved; not anything else. Additionally it only saves if the window
was modified.
@paragraph{}

If the window is named @il{Untitled} this command acts like @x{Save as}.
@paragraph{}

@refMenu{cmcSave,F2}

@c --------------------------------------------------------------------------
@subsection Save as

This option allows to save the contents of the current window specifying a
new name for the file. For this purpose the file open dialog is used
(@x{File Open}).
@paragraph{}

If the file already exists a dialog will pop-up asking for confirmation
to overwrite the existing file.
@paragraph{}

The title of the window is changed to reflect the new file name.
@paragraph{}

@refMenu1{cmcSaveAs}

@c --------------------------------------------------------------------------
@subsection Save as UNIX

This option is very similar to the @il{Save as} option (@x{Save as}). The
only difference is that the editor will use the ASCII 10 as line end instead
of the 13,10 DOS sequence. That's very useful when you need to compile the
file under UNIX or you just want to save some bytes on your disk.
@paragraph{}

Additionally there is an option to save UNIX files as UNIX files without
converting it to DOS style. @x{Editor General,Tool&Ops|Options|Editor General}.
@paragraph{}

@refMenu1{cmcSaveAsUNIX}

@c --------------------------------------------------------------------------
@subsection Save with same time

This option is very similar to the @il{Save} option (@x{Save}). The only
difference is that the editor won't modify the creation time. This
option is very useful to modify header files avoiding the recompilation
of the whole project. A common case is when you only add constants to a
header that is included by various files but only one will use the new
constants.
@paragraph{}

@refMenu1{cmcSaveSameTime}

@c --------------------------------------------------------------------------
@subsection Save all

All modified editing windows will be saved.
@paragraph{}

@refMenu1{cmcSaveAll}

@c --------------------------------------------------------------------------
@subsection Print

This option prints the current editor window. Don't use this option without
configuring the printer module. @x{Print Setup}.
@paragraph{}

This option was designed to print source files, to print plain text files
or avoid all the formating features. Select the portion of text to be
printed and save the block (@kbd{^K-W}) to a file with the name of the device
to which your printer is connected. As an example to print to the DOS LPT 1
device just write the block to the @file{lpt1} file.
@paragraph{}

The editor will report the number of lines processed and printed in the
message window.
@paragraph{}

To learn more about the message window @x{Message Window}.
@paragraph{}

@refMenu1{cmePrintEditor}

@c --------------------------------------------------------------------------
@subsection Print Setup

This option brings up a dialog to configure the printing module. After
configuring it you can print using the @il{Print} option. @x{Print}.
If you want to print a plain text (without formating) consult the @il{Print}
option too.
@paragraph{}

The dialog asks for the following parameters:
@paragraph{}

@itemize @bullet
  @item Total lines per page: The total number of lines that fits on one page
including the footer and header lines.
  @item Columns w/o margin: The number of colums that fits on the page
excluding the desired margin.
  @item Left margin: The number of columns left blank at the left side of the
page.
  @item Print line numbers: Select this option to get the line numbers printed
  @item Time format: The time format specified in the C style. (@x{Time and date modifiers formats}).
  @item Date format: The date format specified in the C style. (@x{Time and date modifiers formats}).
  @item Title: only used in the header.
  @item Author: only used in the header.
  @item Output file: Specify the printer device here. For example: the DOS
LPT 1 is the lpt1 file.
  @item Printer initialization: The sequence of character used to initialize
the printer. Normally it includes a reset and a font selection.
Specify the values separated by commas.
  @item Before heading: Commands to send before the header.
  @item After heading: Commands to send after the header.
  @item Before footer: Commands to send before the footer.
  @item After footer: Commands to send after the footer.
@end itemize

Use the @il{Ok} button to confirm or the @il{Cancel} button to reject.
@paragraph{}

The @il{Epson} button fills the values with the default settings for Epson
printers (ESCP2 language). The @il{HP} button fills the values with the
default settings for Hewlett Packard ink-jet printers.
@paragraph{}

The printer module was designed by me some years ago when I needed to present
a program at my University (Universidad Tecnologica Nacional) and I wanted
to add to the source code listing a header, footer, lines number, page number,
date/time of the printing, project and author. So that's what the routines
does. I know they are limited but they generate a very good listing, much
better than just printing the text without any formating.
@paragraph{}

@refMenu1{cmeSetUpPrinter}

@c --------------------------------------------------------------------------
@c @subsection Change directory

@c [DOS]
@c @paragraph{}

@c By default the editor saves new files and loads files from the directory
@c where you started the editor. If you need to save or load various files
@c from a different directory select the directory here just once. For more
@c information about it, see @xref{File Open}.
@c @paragraph{}

@c @refMenu1{cmeChangeDrct}

@c --------------------------------------------------------------------------
@subsection Shell

Calls the default command interpreter indicated by the @il{COMSPEC}
enviroment variable. I guess you know that by typing exit you'll get back to the
editor.
@paragraph{}

@refMenu1{cmeDosShell}

@c --------------------------------------------------------------------------
@subsection Quit
@cindex backups, delete at exit

This option exits the editor deleting all the back-up, desktop and project
files located in the current directory. That's useful if you want to keep the
directory clean.
@paragraph{}

When you use this option a dialog will appear asking for confirmation, you
can avoid this dialog in the future by checking the "don't show again"
option.
@paragraph{}

@refMenu{cmeQuitDelete,Alt+Q}

@c --------------------------------------------------------------------------
@subsection Exit

This option just exits the program. The editor asks for each modified editor
window if you want to save the changes. All the settings are stored
in the desktop file automatically.
@paragraph{}

@refMenu{cmeQuit,Alt+X}

@c --------------------------------------------------------------------------
@section Edit

This menu contains all the editing operations that have a menu shortcut.
@paragraph{}

@c --------------------------------------------------------------------------
@subsection Undo

This option reverts the last edit operation. Upto 32 operations can be
reverted.
@paragraph{}

@refMenu{cmcUndo,Alt+BackSpace}

@c --------------------------------------------------------------------------
@subsection Redo

This option takes back the last @il{Undo}. @x{Undo}.
@paragraph{}

@refMenu1{cmcRedo}

@c --------------------------------------------------------------------------
@subsection Cut

The selected text is copied to the clipboard and deleted from the text.
@x{Clipboard}.
@paragraph{}

@refMenu{cmcCut,Shift+Del}

@c --------------------------------------------------------------------------
@subsection Copy

The selected text is copied to the clipboard. @x{Clipboard}.
@paragraph{}

@refMenu{cmcCopy,^Ins}

@c --------------------------------------------------------------------------
@subsection Paste

The text that's currently selected in the clipboard is inserted at the cursor
position. @x{Clipboard}.
@paragraph{}

@refMenu{cmcPaste,Shift+Ins}

@c --------------------------------------------------------------------------
@subsection Show clipboard

This option shows the clipboard window. @x{Clipboard}.
@paragraph{}

@refMenu1{cmeShowClip}

@c --------------------------------------------------------------------------
@subsection Clear

Deletes the selected text. It isn't copied to the clipboard.
@paragraph{}

@refMenu{cmcClear,^Del}

@c --------------------------------------------------------------------------
@subsection Set Local

This option pops up the local configuration dialog. The values in this
dialog are valid only for the current editor window.
@paragraph{}

The first group of options are related to the editing modes.
@x{Editing Modes}.
@paragraph{}

The syntax highlight group of options allows to choose the type of highlight.
@x{Syntax Highlighting}.
@paragraph{}

Additionally the window allows to indicate the tab size and the column where
the wrap cuts the lines.
@paragraph{}

@refMenu{cmcSetLocalOptions,Alt+L}

@c --------------------------------------------------------------------------
@subsection Set Global

This option pops up the global configuration dialog. The values in this
dialog are used as default values. If you exit the dialog using the
@il{Ok} button these values @b{aren't} applied to any of the editor windows,
they just act as default values for newly opened and created
files. If you exit the dialog using the @il{To all} button these values
are applied to @b{all} the editor windows. To set the options for just one
window @x{Set Local}.
@paragraph{}

The options are related to the editing modes. @x{Editing Modes}.
@paragraph{}

Additionally the window allows to indicate the tab size and the column where
the wrap cuts the lines.
@paragraph{}

@refMenu{cmcSetGlobalOptions,Alt+G}

@c --------------------------------------------------------------------------
@subsection Expand all tabs

This option converts all the tabs to spaces. @x{Real Tabs}.
@paragraph{}

The tabs are expanded to the current tab size, check this value before using
this option.
@paragraph{}

@refMenu1{cmcExpandAllTabs}

@c --------------------------------------------------------------------------
@subsection Compact text

This option converts spaces to tabs where possible. @x{Real Tabs}.
@paragraph{}

Be careful, if the tab size is too small the editor will generate tons of
tabs, even in places where you may not want a tab.
@paragraph{}

@refMenu1{cmcCompactBuffer}

@c --------------------------------------------------------------------------
@subsection Copy to Windows Clipboard

Copies the selected text to Windows' clipboard. Of course you must be
running Windows to be able to use this ;-)). Don't expect this feature to
work always though, as Windows has bugs in the WinOldAp module; which is used
to provide this function.
@paragraph{}

There is a command called @code{cmcCutClipWin} you can use to cut a portion
of text copying it to Windows' clipboard.
@paragraph{}

@refMenu1{cmcCopyClipWin}
@refMenu1{cmcCutClipWin}

@c --------------------------------------------------------------------------
@subsection Paste from Windows Clipboard

Pastes the Windows' clipboard content at the cursor's position. Of course
you must be running Windows and have some text in the clipboard.
Don't expect this feature to work always though, as Windows has bugs in
the WinOldAp module; which is used to provide this function.@paragraph{}

@refMenu1{cmcPasteClipWin}

@c --------------------------------------------------------------------------
@subsection Copy to file Clipboard

Copies the selected text to a special file used as clipboard. This option is
usually available on UNIX as a replacement for the Windows clipboard
functions. The file is created in a user specific directory, for this reason
the information is only available to one user.
@paragraph{}

@refMenu1{cmcCopyClipFile}

@c --------------------------------------------------------------------------
@subsection Paste from file Clipboard

Pastes text from a special file used as clipboard. This option is
usually available on UNIX as a replacement for the Windows clipboard
functions. The file is created in a user specific directory, for this reason
the information is only available to one user.
@paragraph{}

@refMenu1{cmcPasteClipFile}

@c --------------------------------------------------------------------------
@subsection Push cursor position

It stores the cursor position (x,y) in a stack. You can restore it later
using @x{Pop cursor position}. The stack can hold up to eleven nested
positions; if you try to push a 12th value the oldest is discarded.
@paragraph{}

@refMenu1{cmcPushCursorPos}

@c --------------------------------------------------------------------------
@subsection Pop cursor position

It restores the cursor position (x,y) from a stack. You can store the
position using @x{Push cursor position}. The stack can hold up to eleven
nested positions; if you try to push a 12th value the oldest is discarded.
@paragraph{}

@refMenu1{cmcPopCursorPos}

@c --------------------------------------------------------------------------
@subsection Case (Menu)

This submenu contains operations to convert blocks or single characters to
uppercase or lowercase and similar operations
@paragraph{}

@c --------------------------------------------------------------------------
@subsubsection Block to upper

Converts all the selected characters to uppercase.
@paragraph{}

@refMenu1{cmcToUpper}

@c --------------------------------------------------------------------------
@subsubsection Block to lower

Converts all the selected characters to lowercase.
@paragraph{}

@refMenu1{cmcToLower}

@c --------------------------------------------------------------------------
@subsubsection Character toggle

Converts the character under the cursor to lowercase if it was uppercase and
@il{vice versa}.
@paragraph{}

@refMenu1{cmcToggleCharCase}

@c --------------------------------------------------------------------------
@subsubsection Block invert

Converts all the selected uppercase characters to lowercase and vice versa.
@paragraph{}

@refMenu1{cmcInvertCase}

@c --------------------------------------------------------------------------
@subsubsection Block alternate

It will convert the first character to uppercase, the second to lowercase and
so on. If you want the reverse you can use the command to invert a block.
@x{Block invert}.
@paragraph{}

@refMenu1{cmcAltCase}

@c --------------------------------------------------------------------------
@subsection Insert new line (do not move)

It inserts a new line character at cursor position but without modifying the
cursor position. Note it doesn't apply indentation or other special things to
the inserted line.
@p{}

@refMenu{cmcInsertNewLine,Ctrl+N}

@c --------------------------------------------------------------------------
@section Search

This menu contains the search and replace commands of the editor. The search
function also includes advanced tools specifically designed for programmers,
like the options to jump to a function definition or a symbol.
@paragraph{}

@c --------------------------------------------------------------------------
@subsection Find

This command searches a string in the current editor. The dialog contains the
following fields:
@paragraph{}

@itemize @bullet
  @item Text to find: The text you want to find.
  @item Case sensitive: Use this option if the case of the text to search
is important.
  @item Whole words only: When this option is set the editor searches for whole
words. If not the text to search can be only part of a word.
  @item Regular expressions: Use this option if the text to search is a
regular expression. A description of the syntax used by regular
expressions can be found in the libc. @x{Regular Expressions}. Three
types of regular expression are supported. @x{Regular Expressions Options}.
  @item Only inside comments: Matches will be returned only if the first
character is inside a comment. Every type of comment supported by the syntax
highlighting is supported. It doesn't have any sense for plain text.
  @item Only outside comments: Matches will be returned only if the first
character is outside a comment. If the previous option is also enabled this
option takes precedence.
  @item Scope - Global: The search will ignore the selected text.
  @item Scope - Selected text: The search will be done only inside the
selected text.
  @item Origin - From cursor: The search will start from the position of the cursor.
  @item Origin - Entire scope: The search will start from the beginning of the text.
@end itemize

The regular expressions search is slow and this can be noticed in large
files. Don't use it if the search can be done without it. The editor will
automatically disable the regular expressions search if the
@il{Text to find} contains only alphanumeric characters. This can be disabled
@x{Regular Expressions Options}.
@paragraph{}

To repeat the search use the @il{Search again} command. @x{Search again}.
@paragraph{}

@refMenu{cmcFind,^Q-F}

@c --------------------------------------------------------------------------
@subsubsection Regular Expressions Options

This dialog is accessed from the @code{RegEx Ops} button in the Find or
Replace dialogs. Here you can indicate some important options about the
regular expressions:
@paragraph{}

RegEx style:
@paragraph{}
@itemize @bullet
  @item Basic POSIX: old style POSIX regular expressions.
  @item Extended POSIX: new style POSIX regular expressions.
  @item Perl Compatible: Perl like regex, using the PCRE library.
@end itemize

Replace text:
@paragraph{}
@itemize @bullet
  @item Normal text: the match is replaced by the text in the replace text area.
  @item Dollar tags: the text to replace is parsed searching for @code{$n} tags.
These markers are replaced by the correspondent subexpression. If you
know Perl that's just like using the $0, $1, @il{etc.@:} after a search.
If you never used Perl and don't know what a subexpression is, just play a
little and you'll get the idea; use $n where n is the desired subexpression.
@end itemize

Optimize:
@paragraph{}
@itemize @bullet
  @item Try to use normal search: if the editor detects that the search string
contains plain text will use a simple search even when regular expressions
are enabled. That's about ten times faster.
  @item Ever use RegEx: the editor doesn't try to be smart and always uses what
you selected.
@end itemize

For more information about regular expressions @x{Regular Expressions}.

@c --------------------------------------------------------------------------
@subsection Replace

This command searches portions of text and replaces it with another text.
The options for the search are the same as in the @il{Find} command.
@x{Find}. The additional replace options are:
@paragraph{}

@itemize @bullet
  @item New text: The text used to replace the matching text.
  @item Prompt on replace: When this option is enabled the editor asks for
confirmation before doing the replace.
  @item Replace all: Use it to replace all the possible ocurrences.
@end itemize

To repeat the search use the @il{Search again} command. @x{Search again}.
@paragraph{}

@refMenu{cmcReplace,^Q-A}

@c --------------------------------------------------------------------------
@subsection Search again

This option repeats the last search.
@paragraph{}

@refMenu{cmcSearchAgain,^L}

@c --------------------------------------------------------------------------
@subsection Name current function

It shows the name of the function at the position of the cursor in the status
line of the window. It has the same limitations of the @il{Jump to function}
option. @x{Jump to function}.

@refMenu{cmcWhichFunctionIs}

@c --------------------------------------------------------------------------
@subsection Jump to function
@cindex functions, heuristic jump to

his option opens a dialog with the list of functions in your source
file you can choose to jump to. The functions are searched
in the source file so you don't need to compile it. As the parser uses
heuristics it may fail. For an option that uses a more reliable but also
slower and complicated search see the @il{Jump to symbol} option.
@x{Jump to symbol}.
@p{}

The @code{Browse} button sends the list of functions to the message window
so you can browse the list and visit each function. @x{Message Window}.
@p{}

Currently only a few languages are supported, they are:
@p{}

@itemize @bullet
@item C/C++
@item Clipper 5.x
@item Syntax Highlight Files
@item Texinfo sources (chapters, sections, @il{etc.})
@item Assembler files (labels)
@item PHP
@end itemize

In C sources fails are common if your code has an unbalanced number of
curly brackets. Here is a piece of code that made the heuristic get
lost:
@paragraph{}

@example
#ifndef MSI_USE_GETDELIM
   if (readPipe(textMsgPipe, id, buf, maxLen))
   @{
      *buflen = strlen(buf);
#else
   if ((bytes = readPipe(textMsgPipe, id, buf)) > 0)
   @{
      *buflen = bytes - 2;
#endif
    ....
   @}
@end example

Here the editor saw two open curly brackets but only one close bracket.
To avoid this you should add:
@paragraph{}

@example
    ....
#ifndef MSI_USE_GETDELIM
   @}
#else
   @}
#endif
@end example

Currently the parser tries to be smart and only check half of the sequence,
just like if all @code{#if} conditions were true. It means the parser won't
get lost with this specific problem, but very complex situations may break
it nonetheless.

@refMenu{cmcJumpToFunction,Alt+F2}

@c --------------------------------------------------------------------------
@subsection Jump to prototype

This option pops up a dialog with the list of C function prototypes in your
source file. You can then choose one to jump to. The prototypes are
searched in the source file so you don't need to compile it. As the parser
uses an heuristic approach it may fail, especially if your code has an
odd number of curly brackets.
@paragraph{}

@refMenu1{cmcJumpToPrototype}

@c --------------------------------------------------------------------------
@subsection Jump to symbol
@cindex tags, jump to tag
@cindex functions, jump to
@cindex symbols, jump to
@cindex variables, jump to

This option uses @file{TAGS} files to search for symbols. In order to make it
work you should read about @file{TAGS} files first. The editor will try to
help you to generate the @file{TAGS} file if you don't have one.
@x{TAGS files}.
@p{}

The word to the left of the cursor will be used to start a search in the list
of available symbols. You can make incremental searches in the list and
pressing @key{Enter} the editor will jump to the symbol.
@p{}

More about tags? @x{TAGS files}.

@refMenu{cmeSearchTag,Ctrl+F2}

@c --------------------------------------------------------------------------
@subsection Go to line

Allows you to indicate to which line you want to jump to.
@paragraph{}

@refMenu{cmcGotoEditorLine,^J}

@c --------------------------------------------------------------------------
@subsection Class browser
@cindex browsing classes

This option uses @file{TAGS} files to search for symbols. In order to make it
work you should read about @file{TAGS} files first. The editor will try to
help you to generate the @file{TAGS} file if you don't have one.
@x{TAGS files}.^
@p{}

First the editor will create an index of available classes from the
@file{TAGS} files and then will do a search using the word to the left of the
cursor. If an exact match was found the editor will go directly to browse
this class, otherwise you'll get a list of available classes to choose one.
You can make incremental searches in this list typing the first letters of
the class name.
@p{}

The main browser dialog contains three buttons offering different information
about the selected class. They are:
@p{}

@itemize @bullet
@item This class: shows a list of the members for this class. You can select
any of them to jump to the member code or go back to the main dialog.
@item This and parents: shows a list of the members for this class and all
the parent classes. The members for this class are first, then come the
members of the parents, then the members of the grandparents and so on.
The information is more compact and you'll only see the name of the class where
the member was found and the level (one for the parent, two for grandparents,
@il{etc.}).
@item Sorted: This option is the same as the previous but the list is
alphabetically sorted.
@end itemize

In addition to these buttons you'll see a list of parent and child classes.
Selecting a class from those lists and pressing the corresponding button you
can browse the selected class.
@p{}

More about tags? @x{TAGS files}.

@refMenu1{cmeClassBrowser}

@c --------------------------------------------------------------------------
@subsection Word completion
@cindex completion, words
@cindex automatic word completion

This option uses @file{TAGS} files to search for symbols. In order to make it
work you should read about @file{TAGS} files first. The editor will try to
help you to generate the @file{TAGS} file if you don't have one.
@x{TAGS files}.
@p{}

The word to the left of the cursor is used to perform a search in the list of
available symbols. If a partial match is found a list of available symbols
will pop-up. To select the symbol you want you can use the arrow cursors or
continue typing until you reach the desired symbol. When you type
@key{Enter}, @key{Space} or any symbol the select word will be inserted
completing the word. Pressing @key{Esc} or @key{Tab} will abort the process.
@p{}

More about tags? @x{TAGS files}.

@refMenu{cmeWordCompletion,Alt+Right}

@c --------------------------------------------------------------------------
@subsection Jump to last cursor position
@cindex last cursor position

This command moves the cursor to the position it was before the last
movement. You can use it to go back after a search.
@p{}

@refMenu{cmcJumpLastCursorPos,Ctrl+Q-P}

@c --------------------------------------------------------------------------
@subsection Jump to last undo position
@cindex last cursor position, alternative

This command moves the cursor to the position it was before the last
movement sequence. This is equivalent to undo the last group of movements.
@p{}

@refMenu1{cmcLastPosCur}

@c --------------------------------------------------------------------------
@section Macro

This submenu has the options to record and replay macros.
@paragraph{}

@c --------------------------------------------------------------------------
@subsection Record (Macro)

Starts recording all the operations you do in the current editor
window.
@paragraph{}

@refMenu{cmcRecordMacro,Shift+F10}

@c --------------------------------------------------------------------------
@subsection Stop (Macro)

Stops the macro recording.
@paragraph{}

@refMenu{cmcStopMacro,Alt+F10}

@c --------------------------------------------------------------------------
@subsection Play (Macro)

Replays the saved macro. A macro saved in one window can be used in another.
@paragraph{}

@refMenu{cmcPlayMacro,^F10}

@c --------------------------------------------------------------------------
@subsection Choose (Macro)

This option lists all the available @il{sLisp macros} so you can choose one
to execute.
@paragraph{}

To learn more about these macros: @x{sLisp macros}.
@paragraph{}

@refMenu1{cmcChooseMacro}

@c --------------------------------------------------------------------------
@subsection Repeat (Macro)

It re-runs the last selected macro. @x{Choose (Macro)}. That's useful
if the macro isn't assigned to a key and you need to use it several times.
@paragraph{}

To learn more about these macros: @x{sLisp macros}.
@paragraph{}

@refMenu{cmcRepeatMacro,Shift+F3}

@c --------------------------------------------------------------------------
@subsection Generate Code

This option translates the recorded macro into an @il{sLisp macro}. The
generated code is inserted at the cursor's position.
@paragraph{}

To learn how to record a macro: @x{Record (Macro)}.
@paragraph{}

To learn more about these macros: @x{sLisp macros}.
@paragraph{}

@refMenu1{cmcGenCodeForMacro}

@c --------------------------------------------------------------------------
@subsection Run selected code

It interpretes the selected text as an sLisp macro.
@p{}

@refMenu1{cmcRunSel_sLisp}

@c --------------------------------------------------------------------------
@subsection Enter code to run

It asks for a text and interpretes it as an sLisp macro. The maximum length is
one kilobyte.
@p{}

@refMenu1{cmcRunEnter_sLisp}

@c --------------------------------------------------------------------------
@subsection Pseudo Macro (menu)

It shows a list of all the pseudo macros available for the current syntax
highlighting mode. The purpose of this option is just to show you what's
available; of course you can choose any from the list but that's much slower
than using them directly.
@paragraph{}

The letters enclosed in brackets are the triggers for the pseudo macro. To
learn more about pseudo macros: @x{Pseudo Macros}.
@paragraph{}

@refMenu1{cmcChoosePMacrosList}

@c --------------------------------------------------------------------------
@section Rectangle

This menu contains the rectangular block operations. As they are a bit
hard to code and these functions are normally ignored by the users, I put
them in a very visible menu.
@paragraph{}

@c --------------------------------------------------------------------------
@subsection Start (Rectangle)

Selects the top-left corner of the rectangular area.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu{cmcSelRectStart,^K-Shift+B}

@c --------------------------------------------------------------------------
@subsection End (Rectangle)

Selects the bottom-right corner of the rectangular area.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu{cmcSelRectEnd,^K-Shift+K}

@c --------------------------------------------------------------------------
@subsection Hide (Rectangle)

Hides the rectangular selection.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu{cmcSelRectHide,^K-Shift+H}

@c --------------------------------------------------------------------------
@subsection Copy (Rectangle)

Copies the rectangular selection into the clipboard. This clipboard isn't
the same clipboard used by the normal selections and is overwritten each
time you copy to it.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu{cmcSelRectCopy,^K-Shift+C}

@c --------------------------------------------------------------------------
@subsection Paste (Rectangle)

Inserts the contents of the rectangular clipboard at the cursor position.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu{cmcSelRectPaste,^K-Shift+P}

@c --------------------------------------------------------------------------
@subsection Cut (Rectangle)

Copies the rectangular selection into the clipboard and then deletes the
selected text.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu{cmcSelRectCut,^K-Shift+T}

@c --------------------------------------------------------------------------
@subsection Clear (Rectangle)

Deletes the selected text.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu{cmcSelRectDel,^K-Shift+L}

@c --------------------------------------------------------------------------
@subsection Move (Rectangle)

Moves the selected text to the cursor's position.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu{cmcSelRectMove,^K-Shift+M}

@c --------------------------------------------------------------------------
@subsection To upper (Rectangle)

Converts all the characters inside the rectangle to uppercase. This
operation basically does a cut of the block, then processes all the
characters and finally makes a paste of the modified block. As a side
effect of this operation tabs inside or crossing the rectangle boundaries
are converted to spaces.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu1{cmcSelRectToUpper}

@c --------------------------------------------------------------------------
@subsection To lower (Rectangle)

Converts all the characters inside the rectangle to lowercase. This
operation basically does a cut of the block, then processes all the
characters and finally makes a paste of the modified block. As a side
effect of this operation tabs inside or crossing the rectangle boundaries
are converted to spaces.
@paragraph{}

To learn more about rectangular blocks: @x{Rectangular Blocks}.
@paragraph{}

@refMenu1{cmcSelRectToLower}

@c --------------------------------------------------------------------------
@section Windows

This menu contains the options to handle the windows in the editor.
@paragraph{}

@c --------------------------------------------------------------------------
@subsection Size/move

You can resize the windows by dragging the bottom right corner of the window.
You can move the windows by dragging the title line of the window.
@paragraph{}

Additionally this command allows the same operations to be done without the
mouse. Once you entered in this mode the border of the window changes it's
color and you can move the window using the arrow keys. To resize the window
use the arrow keys holding the @key{Shift}. Furthermore @key{Home},
@key{End}, @key{PgUp} and @key{PgDown} can be used to move the window to one
end of the desktop. When you're done you can end this mode by pressing
@key{ESC} or @key{ENTER}.
@paragraph{}

@refMenu{cmeResize,^F5}

@c --------------------------------------------------------------------------
@subsection Zoom

Changes the size of the window to be as large as the whole desktop. The
second time you use this command the window is resized to it's previous size.
It's the equivalent of the maximize and restore options of other editors.
@paragraph{}

@refMenu{cmeZoom,F5}

@c --------------------------------------------------------------------------
@subsection Tile

Arranges all the windows in a way that you can see all at the same time.
@paragraph{}

@refMenu1{cmeTile}

@c --------------------------------------------------------------------------
@subsection Cascade

Arranges all the windows in such a way that they overlap.
@paragraph{}

@refMenu1{cmeCascade}

@c --------------------------------------------------------------------------
@subsection Next (Window)

Selects the next window. The windows are linked in a circular list, this
command selects the next window in the list. To change the order of the
windows you can directly select a window with the mouse or @key{ALT} plus
a number. That window will become the current one, and the
other will be the @il{previous} window.
@paragraph{}

Use it to select the most recently used windows.
@paragraph{}

@refMenu{cmeNext,F6}

@c --------------------------------------------------------------------------
@subsection Previous (Window)

Selects the previous window. The windows are linked in a circular list, this
command selects the previous window in the list. To change the order of the
windows you can directly select a window with the mouse or @key{ALT} plus
a number. That window will become the current one, and the
other will be the @il{previous} window.
@paragraph{}

Use it to select the most recently used windows.
@paragraph{}

@refMenu{cmePrev,Shift+F6}

@c --------------------------------------------------------------------------
@subsection Close

Closes the current window. If the content wasn't saved the editor will ask
if you want to.
@paragraph{}

@refMenu{cmeClose,Alt+F3}

@c --------------------------------------------------------------------------
@subsection List

Pops up the List of Windows dialog. This dialog contains the list of all the
editor windows, the special windows and the closed windows.
@paragraph{}

The editor windows are numbered starting from two and the list is sorted by
number. If a window isn't saved an asterisk is placed between the number and
the name.
@paragraph{}

The special windows are: the message window (the number of lines is
indicated), the project window, the clipboard window (the bytes used by it
is indicated) and the InfView windows.
@paragraph{}

The closed windows list is sorted alphabetically and holds the last closed
windows. The editor stores important information about these windows so if
you close and re-open one of them the size of the window and other values
are restored.
@paragraph{}

You can jump to any of the windows by selecting it with the mouse, with
the arrow keys and @key{ENTER}, double clicking, or by using the
@il{Go} button.
@paragraph{}

A press of @key{Delete} or using the @il{Delete} button will delete the
closed windows or close any open editor window.
@paragraph{}

@refMenu{cmeListWin,Alt+0}

@c --------------------------------------------------------------------------
@subsection User Screen

Shows the DOS screen. Press any key to go back to the editor.
@paragraph{}

@refMenu{cmeUserScreen,Alt+F5}

@c --------------------------------------------------------------------------
@section Tool&Ops

This menu contains all the configuration submenues and some useful tools.
@paragraph{}

@c --------------------------------------------------------------------------
@subsection Options

This submenu contains the configuration submenues. You can find the local and
global edition options in the Edit menu. @x{Edit}.
@p{}
Some of the deeper submenues are explained here because the documentation
tools limit how deep subsections can be nested.
@p{}

@c --------------------------------------------------------------------------
@subsubsection Customize Colors

This command allows to customize the colors used by the editor. Almost all
the colors are configurable.
@paragraph{}

The first list, called @il{Group}, is the list of things used by the editor.
Each entry in the group list has one or more colors in the @il{Item} list.
First select the group you want to customize and then press @key{Tab} to
move the cursor to the items list. To customize a color just select it in the
list of items; the dialog will show a text example in the bottom right corner
and the @il{Foreground} and @il{Background} colors will be indicated. Using the
mouse or moving with @key{Tab} and using the arrow keys you can select any
of the available colors; the sample text area will show the resulting combination.
@paragraph{}

Exiting the dialog with @key{ENTER} or with the @il{Ok} button the new colors
will be applied. The colors are stored in the desktop file. If you are using
one centralized desktop file these colors will be used each time you run
the editor, if not the colors will be used only when you run the editor in
that very same directory.
@paragraph{}

To learn more about the scope of the desktop files and how to indicate
default values: @x{Desktop Files}.
@paragraph{}

If you want to use other colors not listed in this dialog you must
customize the palette. @x{Color Palette}.
@paragraph{}

@refMenu1{cmeSetColors}

@c --------------------------------------------------------------------------
@subsubsection Color Palette

This option allows to configure the palette of colors used by the editor. I
think you know about palettes but I wrote a little explanation, just
in case. @x{Text mode attributes}.
@paragraph{}

The @il{Color} radio buttons are used to select the index you want to
customize. The @il{Red}, @il{Green} and @il{Blue} scroll bars can be used to
customize the color. To modify one of the components use the mouse or use
the @key{R}, @key{G} and @key{B} to increase the values and @key{Shift}+@key{R},
@key{Shift}+@key{G} and @key{Shift}+@key{B} to decrease the values.
@paragraph{}

Exiting the dialog with @key{ESC} restores the values you had before selecting
this option. Choosing the @il{Default} button the colors are set to the
default values of VGA cards.
@paragraph{}

These settings are stored in the desktop file. @x{Desktop Files}.
@paragraph{}

@refMenu1{cmeEditPalette}

@c --------------------------------------------------------------------------
@subsubsection Color Theme

With this option you can choose from a list of predefined groups of colors.
@p{}

Currently only a couple of color themes are available, users are encouraged to
contribute their own themes.
@p{}

@refMenu1{cmeColorTheme}

@c --------------------------------------------------------------------------
@subsubsection Editor General
@cindex backups, enable/disable
@cindex backups, style
@cindex backups, memorize
@cindex desktop files, do not create
@cindex tcedit.dst, do not create
@cindex desktop files, style
@cindex tcedit.dst, style
@cindex closed windows, number
@cindex message window, options
@cindex project window, vertical

This will open the general configuration dialog containing several
options.
@paragraph{}

The @il{Save options} groups control various settings about which and how
files are created by the editor.
@paragraph{}

@itemize @bullet
@item Make backups: When enabled the editor keeps a backup of your files
using the @file{.bkp} extension. It saved me many times.
@item UNIX style backups: When enabled the backups are created appending a
tilde symbol to the file extension. This is recommended only for systems that
support long file names, not pure DOS.
@item Hidden backups: The backups are created as hidden files, it can be used
to keep backups, but at the same time make them less annoying.
@item Remember bkps to delete: When you exit with @code{Quit} the editor
deletes backup files. To do it the editor deletes files ending with
@code{bkp}, but if you use UNIX style backups or just edit files in a
directory other than the current it's hard to know where these files
are located. For this reason the editor keeps a list of created backup files.
If you exit normally this list is lost, so the next time you use the editor
and exit with @code{Quit} only the backups created during this session will
be deleted. This behavior can be modified choosing this option, when enabled
the editor will store the list in the desktop file and retrieves it the next
time you start the editor. By default this option is disabled because users
that don't know about this mechanism and use a centralized desktop file
could end up with a very long list of backup files, wasting memory and
disk space.
@item Don't create desktop files: When enabled the editor creates only one
desktop file and not one per directory. @x{Desktop Files}.
@item Save desktop files hidden: Just what the name says. That's useful if
you want to create desktop files in each directory but don't want to
see them in directory listings.
@item Tile windows vertically first: It affects the @il{Windows|Tile} option.
Normally this option starts splitting the screen by dividing the height of
windows. When this option is selected the width is divided first.
@item Save UNIX files as UNIX: When enabled the editor saves to disk UNIX
files in UNIX format. That means that the conversion is done only
internally and the format of the file on disk isn't altered when you
save.
@item Do not remember cursor position: If you enable it the editor won't
remember the last cursor position of each editor window.
@item Do not warn about read-only files: It disables the dialog that warns
about opening read-only files. Disabling it you won't be asked about
reverting the read-only attribute until you try to save the file.
@item Open read-only files as R.O. buffers: When enabled the editor won't
allow you to edit files with the read-only attribute. Note:
it doesn't disable the warning, use the above mentioned option for
this.
@c @item Open only specified files: When enabled and you specify one or more
@c file names in the command line the editor will close all the files already
@c opened before opening the files specified by you. It helps to keep the
@c desktop clean if you use only one global desktop file.
@end itemize

In the open, save, @il{etc.@:} dialogs you can sort backup files in a special
way so they don't interfere with the rest of the files.
@x{File open dialog}.@*
You can also configure the editor to avoid creating backup files for some
particular filenames or directories. @x{Do not create backups for}.
@p{}

The @il{Clock} group allows to turn on/off the clock and to choose 24 hs
or AM/PM style. The clock is displayed in the top right corner of the screen.
@paragraph{}

The @il{Max. editor copies} controls how many copies of the same file can be
opened at the same time. By default the value is one, so when you try to open
a file twice the editor will just show you the first copy. Specifying a value
different than one will allow you to open more copies of the same file. Only
the first copy can be modified and the rest are read-only snap-shots of the
file. For more information: @x{Open Read-only copy}.
@paragraph{}

The @il{Max. closed to remember} value specifies how many closed files are
remembered in the list of windows. This value can't be less than three and
can't be greater than two hundred. If you reduce this value and there are
already more files remembered the editor won't reduce the number
immediately, instead you must choose which files to remove by hand.
@paragraph{}

The @code{+ Desktop} button opens a second dialog containing options about
what is stored in the desktop files. Each section selects if the
option will be remembered always (ever), only when no files are specified in
the command line or never.
@p{}

@itemize @bullet
@item Remember editor windows: it affects the opened files.
@item Remember other windows: it affects other windows, like the help
windows.
@item Remember closed windows: it affects the list of closed files.
@end itemize

The second dialog contains a button to return to the first dialog.
@p{}

The @code{+ Others} button opens a third dialog containing options to
configure the behavior of the message window when the last or first error in
the list is reached.
@p{}

@itemize @bullet
@item Just stop: nothing particular is done, the editor just stops.
@item Indicate with a message: a message indicating you reached the first
or last pops up.
@item Wrap (circular list): the list becomes a circular list. So when you
reach the last message the editor jumps to the first and @il{vice versa}.
@item Make a beep: a sound is generated.
@end itemize

Additionally you can choose if you want project and message
windows to be vertically or horizontally oriented in this dialog.
@p{}

@itemize @bullet
@item Use the vertical direction: message and project windows are vertically
oriented. By default they are positioned at the left side. When this option
is selected the project window has only one column.
@item Use the right side: use the right side of the screen instead of the
left side. That's used only when the direction is vertical.
@end itemize

One important detail is that this options affects the size of newly opened
files. If you already opened windows in this project the editor will have
them memorized. So you should set up this options before creating a project.
@p{}

To control the size of the windows when you open a new file you have two
options.
@p{}

@itemize @bullet
@item Use reserved width or 7 (hz dir): In this case the editor will make
windows smaller than the desktop by substracting the value entered in
reserved width, for vertical direction projects, or a fixed ammount of seven
for horizontal direction projects.
@item Avoid message and project windows: When selected the editor will try to
avoid using the desktop surface used by the message and project windows. The
size computed is the size of these windows without zooming. If the resulting
size is too small the window will overlap.
@end itemize

This dialog also has a button to go back to the main dialog.
@p{}

These settings are stored in the desktop file. @x{Desktop Files}.
@paragraph{}

@refMenu1{cmeEdGralOptions}

@c --------------------------------------------------------------------------
@subsubsection Check for modified files
@cindex newer, files on disk
@cindex reloading newer files
@cindex checking if file changed

When you edit a file the editor uses a copy of this file stored on memory.
The copy on disk can be changed by another user or by a program. If it
happends you can be working on a different file and you'll destroy those
changes when saving. For this reason the editor must check if the
modification time of the file changed. The editor does this check when:
@p{}

@enumerate
@item You run an external program. This program could generate some output
file and it could be one of the opened files.
@item You select an editor window. This is done in the @code{idle loop}, so
this check could be delayed a fraction of a second.
@item Periodically for the focused file.
@end enumerate

The configuration dialog can be used to disable or fine tune these checks.
The @code{Seconds between checks} option refers to the periodical checks.
The other options are:
@p{}

@itemize @bullet
@item Don't check after executing an external program. It disables the
checks done after running an external program.
@item Don't check while idle. It disables the the checks done periodically
and also the checks done when you select a an editor window. That's because
both are done when the editor have some free time.
@end itemize

When the editor detects a file on disk is newer than the file on memory a
dialog asking if you want to load the new file pops up. This question will be
done only once and no matters what you answer the editor will asume the
problem is solved. This is to avoid an endless storm of questions.
@p{}

If you choose to load the file from disk the editor will check if the memory
copy is also modified. In this case a collision between your changes and the
external changes can lose data. For this reason the editor offers four
options:
@p{}

@enumerate
@item Load file from disk (discard changes): This is the default action, use
it if you want to get a fresh copy discarding any changes done in memory.
@item Abort operation: The editor does nothing and you must solve the problem
manually.
@item Load and show differences: This is like the first option, but the
editor will invoke @code{diff} and load it's output. You can analize the
differences between your changes and the external changes to solve the
problem.
@item Don't load and show differences: This is like the second option, but
the editor invokes @code{diff} like in the third.
@end enumerate

The last two options are offered only if GNU diff is installed in your
system. You can get GNU diff from the GNU site (http://www.gnu.org/).
@p{}

Note that when the editor offers a diff output this is loaded from a temporal
file that is discarded as soon as loaded. For this reason the editor marks
this window as read only. If you want to use this file to as input for
@code{patch} just use the @code{Save As} option.
@p{}

@refMenu1{cmeSetModiCkOps}

@c --------------------------------------------------------------------------
@subsubsection Screen Saver
@cindex screen saver

This dialog customizes the screen saver. Note the question mark at the end of
the term "screen saver" I did it because the plasma screen saver isn't too
good to be used as a real saver for your screen.
You can enable or disable, choose the time the editor will wait before
starting the screen saver and the screen saver style. The @b{Test} button can
be used to see how the screen saver looks like.
@paragraph{}

If you leave the mouse pointer in the upper right corner of the screen for
a few seconds the screen saver is activated. This time is three seconds by
default and can be configured entering the amount of seconds in the second
box labeled @il{Time}.
@paragraph{}

Two types of screen savers are supported: internal and external. Internal
screen savers are hardcoded in the editor. External screen savers are
external programs started by the editor. If you select an external screen
saver from the list the @b{Info} and @b{Help} buttons are enabled. Pressing
these buttons you can get more information about the screen saver. You can
pass additional parameters to the external screen saver filling the
@il{External Saver} box.
@paragraph{}

If you want to write your own screen saver please download the sources of the
editor and read the explanations found in the @il{scrnsave} directory. An
external screen saver is basically a simple program that supports some
special command line options and returns some specified return values.
@paragraph{}

@refMenu1{cmeScreenSaverOpts}

@c --------------------------------------------------------------------------
@subsubsection SDG Options

These options customize the SDG module (SET's Documentation Generator).
@mxref{Top,SDG Documentation,,SDG,SDG}.
@paragraph{}

@itemize @bullet
@item Format file: Indicates the name of the format file used to generate
the documentation.
@item Intermediate file: The name of the temporal file used in the process.
@item Base output: The base name of the output file. Doesn't include the
extension.
@item Directory of formats: The place where the editor will search for the
format file.
@item Keep intermediate: When enabled the temporal file isn't deleted, so
you can see possible errors in it.
@end itemize

The SDG module uses the files listed in the project to collect the
documentation from the comments. @x{Project}.
@paragraph{}

These settings are stored in the desktop file. @x{Desktop Files}.
@paragraph{}

@refMenu1{cmeSDGDialog}

@c --------------------------------------------------------------------------
@subsubsection Run program (which one)

The editor can run an external program and collect the errors reported by it
if you press the shortcut (@kbd{^F9}). A good example is the make program. Here
you can select the name of the program. If you need to run more than one
command separate it with @code{;}.
@paragraph{}

The editor will redirect the stderr (standard error output) and stdout
(standard output) of the program and then will analize it looking for errors.
The dialog includes a list of parsing algorithms to analize the errors from
the external program. To learn how to configure the editor for other formats
or just fine tune any of them @x{Error messages from an external application}.
@paragraph{}

The other options found in this dialog are a little bit complex. Here I'll
try to explain each of these options but I recommend to just try them to see
how they work.
@paragraph{}

Option @il{Use OS screen to run the program}: The editor will try to restore
the contents of the screen. So it will look like as it was before running the
editor. Meaning the program will be executed and the editor will redraw
all the contents of the desktop and windows afterwards. This mechanism is
useful when the program you want to run is interactive or doesn't use the
standard output. Is important to understand that on some platforms and
terminals the editor can't restore the contents of the screen and will just
clean it to the grey over black color. It's also important to understand that
when this option is enabled the program can't be executed in multitasking
mode; it means the option @il{Don't try to run in background} will be
implicitly selected.
@paragraph{}

Option @il{Don't try to run in background}: On some platforms (currently only
Linux) the editor can execute the external program as a child process. It
means the program will execute in parallel with the editor (in background).
When the editor does this you'll see the message window indicate the
program is running but won't say when you are back in the editor. Instead the
output of the external program will start to fill the message window. You can
select any other window and continue working while the external program runs.
When the external program ends the editor will also collect the rest of the
messages and errors in the background. While the editor is running the external
program and/or parsing the remaining messages the status bar will show an
option @code{Ctrl+C Stop}; clicking on it or pressing the indicated key the
editor will stop the background process and will also stop collecting
messages. The purpose of this option: When this
option is enabled the editor won't try to run the external program in
parallel even if the platform supports it. That's faster, but if the
external program is slow you'll be forced to wait until it finishes and you
won't be able to stop the program from the editor.
@paragraph{}

Option @il{Always parse in background}: If enabled the editor will collect the
messages and errors in the background even if the platform doesn't support the
execution of the external program in the background. On platforms that don't
support the execution of the external program as a thread the editor will
block until the external program ends and then will parse the messages and
errors in the background. This is useful when the amount of messages and errors
is big and the parsing will take a long time. In this way you can continue
working while the editor does this job. You must understand that's even
slower but you can at least use the time for reading or editing text.
@paragraph{}

Option @il{Jump to the first error}: If enabled the editor jumps to the
file and line of the first error reported by the external program.
@p{}

Option @il{Don't redirect stdout}: Complements the
@code{Use OS screen to run the program} option. When enabled the editor
collects errors only from the standard error and not from the standard
output. This is useful for interactive applications that sends its output to
the standard output.
@p{}

The @il{Message window scroll} group of options are mutually exclusive and
give some control over the behavior of the message window. When you start
executing the external program the message window will automatically get the
focus. As messages and errors are added to this window the window scrolls
and shows the last message. When the external program finishes and the editor
parses all the messages and errors the message window will get the focus
again. Finally, if the editor found errors, the message window will scroll to
the first line. This is the default behavior and you'll be able to see each
of this steps only if the editor is running the external program in the
background and/or parsing the messages and errors in the background. This
behavior corresponds to the @il{Ever} (always) option. If you select the
@il{Never} option the editor won't scroll the message window. In this case you can
browse the messages even while the editor is collecting them. Finally you can
choose @il{Only if not focused}. In this case you'll be able to browse the
messages when the message window is selected, but if you select an other window
the editor will start to scroll the message window. The fastest option is
@il{Never} but then you won't see if the external program finished executing,
unless you have the message window selected all the time.
@paragraph{}

The @il{Lines per pass} option is associated with the speed of parsing. This
option takes effect only when the messages and errors are parsed in the
background. What this option indicates is how many lines of messages and
errors will be parsed before releasing the CPU. A bigger value will make the
parsing faster but will make the editor slower and you'll start having
problems to select windows and write text. You must experiment with this
parameter. On my machine a value of 20 is acceptable.
@paragraph{}

All of these settings are stored in the desktop file. @x{Desktop Files}.
@paragraph{}

For more information about the behavior of the message window
@x{Message Window}.
@paragraph{}

@refMenu1{cmeConfRunCommand}

@c --------------------------------------------------------------------------
@subsubsection Keyboard

This is a submenu but due to limitations in the documentation tools I was
forced to put it with the rest of the options listed in the @il{Options}
submenu.
@paragraph{}

It contains all the options to customize the keyboard.

@c --------------------------------------------------------------------------
@subsubsection Key assignment

With this command you can fully customize the keys used by the editor windows.
It doesn't include the menues, for that you must edit the @file{menubind.smn}
file.
@paragraph{}

To learn how to use this command consult: @x{How to configure the keyboard}.
@paragraph{}

@refMenu1{cmeEditKeyBind}

@c --------------------------------------------------------------------------
@subsubsection Setup Alt keys

It allows you to select how the editor interpretes the left and right alt
keys. For more information: @x{Alt key configuration}.
@paragraph{}

@refMenu1{cmeSetUpAltKeys}

@c --------------------------------------------------------------------------
@subsubsection Key pad behavior

[DOS]
@paragraph{}

Here you can choose how the keypad is interpreted by the editor. Two options
are provided. One is the BIOS default, in this mode the @key{NumLock} changes
between arrows and numbers. In the other mode the behavior is similar, but
holding shift and pressing a number will behave like an arrow key shifted,
that's very common in DOS applications so that's the default.
@paragraph{}

@refMenu1{cmeKeyPadBehavior}

@c --------------------------------------------------------------------------
@subsubsection Back to defaults

This option restores the default key assignments of the editor. Use it if you
messed up the keyboard configuration and you want to get back
the original values.
@paragraph{}

@refMenu1{cmeKbBackDefault}

@c --------------------------------------------------------------------------
@subsubsection Consult scan codes

Used to consult the keyboard scan codes: @x{Consulting scan codes}.
This dialog must be closed using the mouse to press the @code{OK} button
because it displays the scan codes for the keys, even for @key{ESC} and
@key{ENTER}.
@p{}

@refMenu1{cmeSeeScanCodes}

@c --------------------------------------------------------------------------
@subsubsection Screen Options

This command opens the screen options configuration dialog. Here you can
customize the video mode or window size. This dialog is available only when
you are running in a terminal that can control the screen size. If you are
looking for the screen saver: @x{Screen Saver}.
@p{}

Not all hardware drivers support it and not all the options are usable for
all the drivers. With some you can't control the screen size, like in
@b{Linux}, in other cases you have total control, like when you run the
editor in @b{X11}, and in others you have limited control, like in @b{DOS}.
@p{}

The first group of options defines how the editor will try to set the video
mode. The available options are:
@p{}

@itemize @bullet
  @item Don't force: The editor won't try to change the screen size.
  @item Same as last run: The editor will remember the last size used and
will try to restore the closest possible size.
  @item External program: It currently makes only sense in @b{DOS}. It can be
used when you have an external program that can set the video mode for you.
In this case you must also indicate the command line for it in the
@b{External program} box.
  @item Closest to specified size: The editor will try to select a screen
size that's as close to the values indicated in @b{Width}, @b{Height},
@b{Chars width} and @b{Chars height} boxes as possible. Note that some drivers
support only a small set of fixed values and others have silly limitations
imposed by the operating system.
  @item Specified mode number: This is mainly for @b{DOS}. Use it if you know
about a video mode supported by your video card that isn't known by the
editor. In this case you must indicate the video mode number in the
@b{Mode number} box.
@end itemize

Even when the video mode mechanism is for @b{DOS} you can use one of the video
modes known by the editor even when running on @b{X11} or other terminals
where the screen size can be changed at will. The following is a list of
known video modes:
@p{}

@table3{Mode,Width x Height,Char Cell}
@titem3{0x0003, 80 x 25,9 x 16}
@titem3{0x0103, 80 x 28,9 x 14}
@titem3{0x0703, 80 x 30,9 x 16}
@titem3{0x0803, 80 x 34,9 x 14}
@titem3{0x0203, 80 x 35,9 x 10}
@titem3{0x0303, 80 x 40,9 x 10}
@titem3{0x0403, 80 x 43,9 x  8}
@titem3{0x0503, 80 x 50,9 x  8}
@titem3{0x0108, 80 x 60,9 x  8}
@titem3{0x0D03, 82 x 25,8 x 16}
@titem3{0x0903, 90 x 30,9 x 16}
@titem3{0x0A03, 90 x 34,9 x 14}
@titem3{0x0B03, 94 x 30,9 x 16}
@titem3{0x0C03, 94 x 34,9 x 14}
@titem3{0x0109,132 x 25,9 x 14}
@titem3{0x010A,132 x 43,9 x 11}
@titem3{0x010B,132 x 50,9 x 10}
@titem3{0x010C,132 x 60,9 x  8}
@endtable-{}

@refMenu1{cmeSetScreenOps}

@c --------------------------------------------------------------------------
@subsubsection Encodings

This dialog is used to select the encodings used by the editor. This is a
complex topic and you'll have to play a little bit with these options before
you can get all the funtionality. Usually you won't need to use it unless you
deal with more than one encoding.
@p{}

Currently the editor can only use files where one letter corresponds to just
one character. It limits the editor to 256 different symbols. This is the
common case for most operating systems and environments. Which symbols are
represented by these 256 values is called an encoding.
@p{}

The encodings are also known as code pages. An example of a code page is the
@b{DOS} code page 437 used by PC VGA boards or the ISO 8859-1 encoding used
by most POSIX systems as a default encoding. Currently more than 47 encodings
are supported. These encodings cover the latin, cyrillic and greek alphabets.
If your alphabet or favorite encoding isn't supported please consider
contributing.
@p{}

In most cases the editor will detect the encoding currently used by the
operating system without problems. A special case is the @b{GNU/Linux} OS
where the concept of code page doesn't really exist and you can find all kinds
of errors in the fonts and unicode maps.
@p{}

This dialog can have two, three or four encodings to select, they are:
@p{}

@itemize @bullet
  @item Application: which encoding the application uses, ie. used in your
documents.
  @item Input: how the data from the keyboard is encoded. It is usually the
same encoding used by the screen. If the application and input code pages
don't match the editor will translate the data from the keyboard to the
application encoding.
  @item Screen: the encoding if the screen. Not all hardware drivers support
it because some of them work with a fixed code page and this value is known.
Here you indicate how the font used by your hardware or OS is encoded. If
this value doesn't match the application code page the editor will translate
the data before sending it to the screen.
  @item Second font: how the secondary font is encoded. This is available
only when the driver supports more than one font at the same time.
@end itemize

If any of these settings doesn't have the @b{Force encoding} option selected
then the editor will use what was detected.
@p{}

If you force the screen encoding the selected value must match the OS
encoding. The exception is when you select a font in the @b{Fonts} dialog. In
this case the editor will recode the selected font to match the encoding.
Don't forget this interaction with the @b{Fonts} dialog. @x{Fonts}.
@p{}

Note that you can easily edit documents encoded in a code page different
than the one used by the OS without doing any specific recoding. Example: if
you are using @b{X11} and the ISO 8859-1 encoding but you want to edit a DOS
file encoded using the 850 code page you just need to select the application
encoding as @b{PC 850} and force it. Your keyboard will generate ISO 8859-1
values, they will be translated into 850 encoding and put in your document.
At the same time the text encoded using 850 code page will be translated to
ISO 8859-1 before displaying it.
@p{}

@refMenu1{cmeEncodings}

@c --------------------------------------------------------------------------
@subsubsection Fonts

This dialog is used to select the fonts used by the editor. Not all hardware
drivers support custom fonts and some only support only one font. The
editor can handle up to two fonts at the same time. However, the use of two
fonts is complex.
@p{}

Only the fonts marked with @b{Load font} are used, don't forget to enable it
before leaving this dialog.
@p{}

The size of the fonts must be the same, that's why even on systems that
supports two fonts only one size can be selected.
@p{}

The offered fonts are the ones provided by the editor and not the OS. This is
because some systems doesn't provide fonts and the systems that provide
fonts usually provides only a few fixed width fonts. The font format used
is documented in the Turbo Vision library.
@p{}

The fonts marked with @il{limited} don't cover all the encodings supported
by the editor. @x{Encodings}.
@p{}

When you load a font the encoding for this font will be the value indicated
by the screen encoding option selected in the @b{Encodings} dialog. If you
change this encoding the editor will automatically change the encoding of the
font.
@p{}

@refMenu1{cmeFonts}

@c --------------------------------------------------------------------------
@subsubsection User Words
@cindex syntax highlight, defining user words

This option is used to define reserved words defined by the user. A very
common use is to define @code{typedef}s you normally use in your programs.
The user words are language dependant. They are highlighted with a special
color different than the color used for reserved words.
@paragraph{}

The first dialog is used to select the language, the names are the ones
defined in the syntax highlighting file (@x{Syntax Highlighting}). Selecting one of
the names and pressing @key{ENTER} pops up the second dialog.
@paragraph{}

The next dialog is used to add or remove words to the list. Pressing
@key{ENTER} you confirm the changes and they are saved to disk. If you exit
with @key{ESC} the old list is preserved.
@paragraph{}

The user words are stored in a file called @file{userword.txt}, in the same
directory all other configuration files are stored. Such a file isn't
included in the distribution because those words must be defined by the
user. You can edit the file by hand if you want, the format is
very simple. The start of a list is marked with @code{.} followed by the name
of the language. The items of the list are marked with @code{+}. Any line
starting with a different character will be ignored during the parsing.
@paragraph{}

Note: The menu option is "Tool&Ops|Options|User Words".
@paragraph{}

@refMenu1{cmeEditUserWords}

@c --------------------------------------------------------------------------
@subsubsection Default global edition

To understand how this menu option works you must know some details about the
global options of the editor. @x{Set Global}.
@paragraph{}

The global options are good, but sometimes you want to make some small
differences depending on the kind of file you are editing. For example: I
want the @il{Intelligent C indent} mode enabled for C, but not for most of the
files, I also want to wrap lines for Texinfo files and files without syntax
highlighting. That's impossible to achieve just using the global options,
that's when this option comes into play.
@paragraph{}

The mechanism is like this: each time you open a new file the editor will
copy the default global options to it and select the syntax highlighting
according to various things, mainly the extension. Once the editor
selects the syntax highlighting the next step is to transfer some options that
apply only to the selected syntax highlighting. By default the list of options
to apply is empty but you can add some using this menu option.
@paragraph{}

The list of options indicates which settings will be enabled, or disabled,
in addition to the global options. That's something very important to keep
in mind, the list does not replace the global options, it modifies them. So
the list will say things like "also enable the intelligent C indent",
"disable the wrap lines", @il{etc.}
@paragraph{}

The first dialog shows the list of syntax highlighting defined in the
@file{syntaxhl.shl} and has three buttons. The @code{Edit} button is the
default button, so pressing @key{ENTER} you'll edit the settings for the
selected syntax highlighting. The @code{No SHL} button is used to edit the
options that will be applied for files with no syntax highlighting
associated to.
@paragraph{}

Once you selected a syntax highlighting a dialog with the list of the settings
for it will appear. The first time it will be empty because those are defined
by the user, and therefore no defaults are provided. In this list
the settings that will be enabled in addition to the global options are
marked with a @code{+} before the name of the option. The options that will
be disabled are marked with a @code{-}. The options are the same described
in the editing modes section. @x{Editing Modes}.
@paragraph{}

The dialog contains an @code{Add} and a @code{Delete} button like other
dialogs. You can also use the @key{Insert} and @key{Delete} keys. When adding
a new setting to the list a dialog containing the list of available settings
is displayed. Note that this list contains all the settings that are available,
once you add one of them to the previous dialog it is removed from this list.
@paragraph{}

After selecting one setting to add a new dialog will be displayed. This
dialog will ask information related to this setting. Most settings are flags
that can be @il{added} or @il{removed} from the global options, but some of
them are just values that will overwrite the global options. Examples of the
last type are the tab size and the wrap column; in this case the dialog will
ask for the value.
@paragraph{}

The values are stored in a very simple format in the @file{deflopts.txt}
file. You can edit this file by hand, but in this case you'll need to know
the names of the settings. The format is very simple, a line starting with
@code{.} starts a section, the full stop is followed by the name of the
highlighting affected. Flags that will be added (enabled or ored) are marked
with a @code{+} as in the dialog, flags that will be substracted (disabled
or anded) are marked with a @code{-} again like in the dialog, in fact the
dialog shows the same string as those in the file. If the setting is numeric
it will ever start with @code{+} and after the name a @code{=} and the
asigned value will follow. Just play a little bit and see the resulting file.
@paragraph{}

@refMenu1{cmeEditDeflOpts}

@c --------------------------------------------------------------------------
@subsubsection File open dialog

This command is used to configure some details of the file open dialog.
@x{File Open}.

@refMenu1{cmeFileOpenOptions}

@c --------------------------------------------------------------------------
@subsubsection Do not create backups for
@cindex backups, selective

Sometimes you don't want to create backups for some particular files. In my
case I use a tool called @il{cvs}. It generates some temporal files and calls
the editor so I can write some information. Those files are short and
temporal, creating backups for them doesn't make any sense.
@p{}

This command shows a configuration dialog where you can enter a list of
regular expressions. If any of these regular expressions match with the file
name of the file you are about to save then the editor won't create a backup
file for it. The regular expressions are Perl style because I think they are
much more intuitive than POSIX regex.
@p{}

The list shown in this dialog is stored in a file called @file{nobkp.txt}.
The exact place of the file depends on your system like other files created
by the editor.
@p{}

Note that files listed here aren't remembered in the list of closed editors.
That's because the editor assumes those files are temporal and you won't need
to use them again.
@p{}

@refMenu1{cmeEditNoBkp}

@c --------------------------------------------------------------------------
@subsubsection Search files under cursor in
@cindex files, search

When you press @kbd{Ctrl+Enter} the editor tries to load the file that's in
the text at the cursor position. If the cursor is in an include line the
editor will extract the name of the header. In any other case the editor will
try to find where the name starts and ends.
@p{}

If the file isn't located in the current directory the editor will try to
find the file in the list of directories indicated by this option.
@p{}

This list is stored in the desktop file.
@p{}

@refMenu1{cmeIncludeList}

@c --------------------------------------------------------------------------
@subsubsection List of tag files
@cindex tags, list of files

This dialog controls which tag files are loaded to search for symbols. To
learn more about tags please read the corresponding chapter. @x{TAGS files}.
@p{}

When you add a file the editor tries to load it and shows how many symbols it
contains.
@p{}

After selecting a new tag file a dialog will ask if you want to add it
using a relative path. This is a very important question. If you are using
one centralized desktop file and you have just a few projects you can add a
list of tag files in this desktop file, but the list must contain absolute
entries. If you are entering a list of tag files for a project or a local
desktop file I recommend using relative paths, but it depends on your needs.
@p{}

@refMenu1{cmeTagFiles}

@c --------------------------------------------------------------------------
@subsubsection Tag files options

To maintain the tag files you should use a makefile. This
makefile will update the tag files when any of your sources changes.
@p{}

To make things easier the editor provides an option to automatically keep
the tag files updated. This option can be enabled from this dialog and only
works if you are using a project.
@p{}

When this option is enabled and you perform a search that involves tags the
editor will automatically check if any of the files included in your project
is newer than the tag files. If newer files were found the editor will
invoke ctags to update the tags. If you delete the tag files the editor will
create a new one.
@p{}

This option works with a tags file called @file{tags} located in the same
directory as the project. This file will be listed in the list of tag files
to search but marked with @code{automatic}. You won't be able to remove this
entry from the list manually.
@p{}

When new items are added to the project they are marked in a way that their
symbols will be added to the tags file, but when you remove items symbols
from this file aren't removed. If this is annoying just remove the
@file{tags} file and let the editor create a new one.
@p{}

@refMenu1{cmeTagsOps}

@c --------------------------------------------------------------------------
@subsubsection Calendar options

The editor can mark holidays in the calendar using a different color. As
holidays depends on the country this feature needs to know:
@p{}

@enumerate
@item What's your country
@item About the holidays celebrated in your country.
@end enumerate

The first is achieved using the contents of the @var{LANG} environment
variable and a file called @file{holidays.conf}. This dialog can be used to
force the country when the @var{LANG} isn't enough or you don't want to set
this variable.
@p{}

The second is achieved using plug-ins. Currently the editor supports it only
for systems that implements the @code{dlopen} family of functions. If you
can't find a plug-in for your country and you know how to write small C
programs consider wrtiting a plug-in for your country. The information about
how to do it is contained in the sources distribution. Look for a directory
called @file{holidays}, it contains a @file{README} file. If you need
assistance contact the author. Please consider contributing the plug-in so
other people from your country can share the benefits.
@p{}

@refMenu1{cmeHolidaysConf}

@c --------------------------------------------------------------------------
@subsubsection Advice dialogs

In some situations the editor offers some advice to guide new users. These
are called @il{advice dialogs}. They can be disabled using a check box in the
dialog.
@p{}

This option is used to enable or disable any of the advice dialogs. Texts
marked with an @code{X} indicates the corresponding dialog is enabled. Use
the @key{space} key to change the desired dialog.
@p{}

@refMenu1{cmeAdviceDiagConf}

@c --------------------------------------------------------------------------
@subsection Calculator (command/menu)

This command shows the calculator: @x{Calculator}.
@paragraph{}

@refMenu{cmeCalculator,Alt+F4}

@c --------------------------------------------------------------------------
@subsection SDG

Runs the documentation module: @mxref{Top,SDG Documentation,,SDG,SDG}.
@paragraph{}

To configure the SDG module: @x{SDG Options}.

@refMenu{cmeSDG,F9}

@c --------------------------------------------------------------------------
@subsection Run program

Runs the desired program. To customize which program to run:
@x{Run program (which one)}.
@paragraph{}

@refMenu{cmeRunCommand,Ctrl+F9}

@c --------------------------------------------------------------------------
@subsection Grep

This command pops up the @il{Powered Grep} dialog. Grep is a very powerful
tool to search text in files. To be able to use it you @b{must} have the
grep tool installed and in the path. It isn't shipped with the editor.
@paragraph{}

@itemize @bullet
@item Pattern Box: The text you want to search for. You can use regular
expressions here. @x{Regular Expressions}.
@item Files to search: The mask used to select the files grep will
search through. Wildcards and some limited basic regular expressions
are supported here.
@item Directories to search: The list of directories where the search will
be performed.
@end itemize

The @il{Source of pattern} options are used to define the text that will be
searched for:
@paragraph{}

@itemize @bullet
@item Pattern box is the pattern: grep will search the text indicated in the
pattern box.
@item Pattern box is a file name: to search words contained in a text file.
@item Use clipboard selection: use the clipboard selection instead
of the pattern box text. @x{Clipboard}.
@end itemize

The @il{Type of pattern} option selects how the pattern is interpreted. The
options are directly related to the grep switches @code{-G}, @code{-E} and
@code{-F}. You can select basic regular expressions, extended regular
expressions or just a list of matching values separated by carriage returns.
@x{Regular Expressions}.
@paragraph{}

The @il{Place to search} group is used to select which files are examined in
the search:
@paragraph{}

@itemize @bullet
@item Use files to search: The files to search content is the mask.
@item Search in opened windows: The search is performed in all the opened
text files.
@item Search in project: The search is performed in all the project files.
@x{Project}.
@item Recurse in subdirs: When enabled the editor will run grep not only
in the indicated directories but in any subdirectory contained therein
as well. That's the main reason because I call it @b{Powered} Grep.
@end itemize

The @il{Options} group contains various options that are self-explanatory.
They include: case sensitive search, whole word and whole line matching and
inverse matching. The last reports the lines that don't match, so be careful.
@paragraph{}

After the search the matched lines are displayed in the message window and
by pressing @kbd{Alt+F7} and @kbd{Alt+F8} you can examine them.
@paragraph{}

To learn more about the message window @x{Message Window}.
@paragraph{}

@refMenu1{cmeGrepDialog}

@c --------------------------------------------------------------------------
@subsection HTML Accents

The following options are useful for people using ISO Latin 1 accents in your
HTML code. Even when the current code page is different than ISO Latin 1.

@subsubsection Convert accents to tags

It converts all the accents in the text to ISO-Latin-1 HTML tags. That's
useful when editing html files because you can type accents naturally and
can simply use this option to generate the right tags. It works
for any code page selected.
@paragraph{}

@refMenu1{cmeHTMLAccents}

@subsubsection Convert tags to accents

It converts all the ISO-Latin-1 HTML tags into accents. That's useful when
reading html files because you can convert the tags to symbols. It works
for any code page selected.
@paragraph{}

@refMenu1{cmeHTMLTag2Accent}

@c --------------------------------------------------------------------------
@subsection Export as HTML

This option is used to export the current text file as HTML. The default
options generates a very good WYSIWYG result. This option works for any
syntax highlighting mode and for any color configuration you want.
@paragraph{}

Under DOS you can customize the editor's palette, this feature will export
the customized colors too.
@paragraph{}

Note that due to limitations in the HTML language the editor can change the
background color on a word-by-word basis only.
@paragraph{}

The available options are:
@paragraph{}

@itemize @bullet
@item File name as title: uses the full path and name of the file as the
title for the generated HTML.
@item Same background color as the editor: defines the background of the HTML
file to be equal to the background of the editor's window.
@item Monospaced font: sets the font for the HTML to @il{Courier New}.
@item Bold attribute: sets the font for the HTML to @il{bold}.
@end itemize

You can also choose between colorized or simple output. Using colors the size
of the file is increased a lot but the result is very nice.
@paragraph{}

@refMenu1{cmeExportAsHTML}

@c --------------------------------------------------------------------------
@subsection Insert key name
@cindex keys, names

This command brings up a dialog asking you to press a key. When you press a key
the dialog is closed and the name of the key is inserted at the cursor
position. You can use it to configure the menues (@file{menubind.smn}).
@x{How to configure the keyboard}.

@refMenu1{cmcInsertKeyName}

@c --------------------------------------------------------------------------
@subsection Remap code page

With this command you can change the code page encoding of the current
document. This operation will translate all the characters from the current
encoding to a new one. Characters that don't have an equivalent in the new
code page are converted to spaces.
@paragraph{}

The dialog asks for the original code page ('from' list) and the new code page
('to' list). Additionally you can allow the editor to also translate the first
32 values. Translating the first 32 values can be dangerous; for this
reason the editor won't translate carriage return, line feed and tabs even if
you choose to remap the first values.
@paragraph{}

This operation affects the buffer globally so you can't use undo. Therefore
you should keep a copy of the file and don't save it if the results aren't
what you expected.
@paragraph{}

This option is very useful to exchange texts between different operating
systems.
@paragraph{}

@refMenu1{cmeRemapCodePage}

@c --------------------------------------------------------------------------
@subsection Profile Editor

This option is used to measure the speed of the editor. Use large files
and to make results comparable always use the same one.
@paragraph{}

@refMenu1{cmcProfileEditor}

@c --------------------------------------------------------------------------
@subsection Redraw screen
@cindex screen, redraw
@cindex redrawing the screen

This command forces a redraw of the screen. It might be needed if some
application running in the background messed up your console.
@paragraph{}

@refMenu1{cmeReDraw}

@c --------------------------------------------------------------------------
@subsection Paste Emacs mode
@cindex syntax highlight, paste mode

Pastes a comment at the start of the file indicating the Emacs mode and the
tab size used for this file. That's very useful if the file doesn't have
an extension or the extension is ambiguous. It is also a good idea to do it if
you'll send the file to another person and want to indicate which tab size
you used.
@paragraph{}
The editor understands this comment and sets the syntax highlighting and tab
size to the value indicated.
@paragraph{}

@refMenu1{cmcPasteEmacsMode}

@c --------------------------------------------------------------------------
@subsection Block quoted printable decode
@cindex quoted printable
@cindex MIME quoted printable

This option decodes the selected text assuming it is encoded with the quoted
printable MIME spec. That's useful if you have an e-mail with non-ASCII
characters and it was encoded with this method. That's very useful for
spanish accents.
@paragraph{}

@refMenu1{cmcQuotedPrintDecode}

@c --------------------------------------------------------------------------
@subsection Un/Indent block

This submenu contains the block indentation operations.

@c --------------------------------------------------------------------------
@subsubsection Indent one space

Indents a block one space. For more information @x{Indentation}.

@refMenu1{cmcIndentBlkOne}

@c --------------------------------------------------------------------------
@subsubsection Unindent one character

Unindents a block one character. For more information @x{Indentation}.

@refMenu1{cmcUnIndentBlkOne}

@c --------------------------------------------------------------------------
@subsubsection Indent one tab or gap

Indents a block as if you used the @key{Tab} key in each line.
For more information @x{Indentation}.

@refMenu1{cmcIndentBlk}

@c --------------------------------------------------------------------------
@subsubsection Unindent one tab or gap

Unindents a block as if you used the @key{Backspace} key in all of the
lines. For more information @x{Indentation}.

@refMenu1{cmcUnIndentBlk}

@c --------------------------------------------------------------------------
@subsubsection Comment indent

This command inserts a comment at the start of each line of the selected
block. The comment used is the one defined in the syntax highlighting file as
@code{EOLComment1}; if none is defined or the file doesn't have any syntax
highlighting this command does nothing. @x{EOLComment1}.
@p{}

If no text is selected this command first selects the current line and then
applies the indentation.
@p{}

@refMenu1{cmcCommentIndent}

@c --------------------------------------------------------------------------
@subsubsection Comment unindent

This command removes as many chars from each selected line as the length of
a comment sequence. The comment used is the one defined in the syntax
highlighting file as @code{EOLComment1}; if none is defined or the file doesn't
have any syntax highlighting this command does nothing.
@x{EOLComment1}.
@p{}

This command doesn't check if each line you selected starts with the defined
comment, so be careful.
@p{}

If no text is selected this command first selects the current line and then
applies the indentation.
@p{}

@refMenu1{cmcCommentUnIndent}

@c --------------------------------------------------------------------------
@subsubsection Arbitrary indent

This command pops up a dialog asking for a text to be used as indentation.
The text will be inserted at the start of each line of the selected block.

@refMenu1{cmcArbitraryIndent}

@c --------------------------------------------------------------------------
@subsection Delete memorized backups
@cindex backups, delete

Deletes all the memorized backups. This includes all the backups created while
the current project/desktop file was opened. If you want to also delete
backup files created during previous sessions you must enable a special
option that makes the editor keep a list across sessions.
@x{Editor General}.
@paragraph{}

@refMenu1{cmeDeleteBkps}

@c --------------------------------------------------------------------------
@section Project

The project files are used to indicate groups of files. Each project has
its own desktop file so you can have different settings for different
groups of files. @x{Desktop Files}.
@paragraph{}

There are several reasons to use projects:
@paragraph{}

@itemize @bullet
@item If you want to work on a group of files and you will be editing these
files for a long time use a project. Then you will be able to select which
file to edit from the project window, as this window is sorted alphabetically
it's easy to make incremental searches (typing the first letters) to find the
file. Additionally the editor saves the window position and other stuff for
all the files listed in the project, even if they aren't listed in the closed
windows list. I use it for my web site files; they are more than 44 and the
list of windows (@kbd{Alt+0}) doesn't help.

@item If you are using the SDG module to collect the comments of the
files you need to use a project to specify them.

@item You can use a project to list a set of files to search with grep.
Each time you want to search in these files you just open this project and
perform the search.
@end itemize

By default the project window is located at the bottom of the desktop, but
you can change this. @x{Editor General}.
@p{}

This window shows only the names of the files and the relative path only when
names are repeated. You can change it to display the relative path for all
files pressing @kbd{Alt+V} when the project window is selected.
@p{}

@c --------------------------------------------------------------------------
@subsection Open (Project)

Opens a project file. To create a new file just enter a new name in the
dialog.
@paragraph{}

@refMenu1{cmeOpenPrj}

@c --------------------------------------------------------------------------
@subsection Close (Project)

Close the project file.
@paragraph{}

@refMenu1{cmeClosePrj}

@c --------------------------------------------------------------------------
@subsection Save (Project)

Saves the current project. It's a good idea to save the project after adding or
removing a lot of files.
@p{}

@refMenu1{cmeSavePrj}

@c --------------------------------------------------------------------------
@subsection Save desktop here

Saves a desktop file in the working directory. A desktop file is created even
if the editor is configured to use only one central desktop file. This is
useful to locally store settings without creating a project.
@p{}

@refMenu1{cmeSaveDesktop}

@c --------------------------------------------------------------------------
@subsection Export project

Creates a text file containing the names of the project items. The file
contains one file per line.
@p{}

@refMenu1{cmeExportPrj}

@c --------------------------------------------------------------------------
@subsection Import project items

Imports the names given in the file as project items. The file with the file
names to import must contain one file per line. Relative paths are
recommended. The editor will check if the file exists and if that's a
regular file, if not the item will be rejected.
@p{}

At the end of the import process the editor informs how many items were
added, how many were already in the project and how many file names didn't
correspond to existing files.
@p{}

@refMenu1{cmeImportPrj}

@c --------------------------------------------------------------------------
@section Help

@c --------------------------------------------------------------------------
@subsection InfView

Well, I think you figured it out, that's the help.
@paragraph{}

@refMenu{cmeInfView,F1}

@c --------------------------------------------------------------------------
@subsection Another InfView

It opens another InfView window. The editor @b{always} opens one window that's
used by the help system. When you close this window the editor just hides it
and when you press @key{F1} the window is un-hided and the help is displayed.
That allows the existence of the @il{Previous help} command. But some times
you could want to brise one or more help files without losing the help
window, in this case you need more than one InfView opened.
@paragraph{}

@refMenu1{cmeAnotherInfView}

@c --------------------------------------------------------------------------
@subsection Tip of the day

Once a day the editor shows a usage tip when you start it. Each tip talks about one
interesting feature that most of the people overlook. Reading them
you'll discover a lot of interesting things about the editor.
@paragraph{}

Each tip has one or more buttons at the right, which represent a link to a
help topic related to this tip. If you want to learn more about the tip's
topic you can browse the help using the buttons.
@paragraph{}

There are three options at the bottom of the window, they are self
explanatory. The first disables the annoying tips ;-), the second shows the
tips in a dialog box once a day and the third shows the same text in the
message window (once a day of course). The third option is less annoying than
the second but you lose the link buttons.
@paragraph{}

The text displayed by the tips can be found in the @file{editor.tip} file. You can
edit it to show anything but be careful because the parser isn't very
tolerant to typos.
@paragraph{}

To learn more about the message window @x{Message Window}.
@paragraph{}

@refMenu1{cmeTipOfTheDay}

@c --------------------------------------------------------------------------
@subsection Syntax help

When programming in a language like C you probably can't remember the exact
name of all the library functions; the djgpp libc help contains around 650
nodes and the Allegro help around 400. Placing the cursor over the name of a
library function and pressing @key{^F1} you'll get help about this function.
If the name isn't exactly typed you'll get a list of the closest matches. The
following topics explain how to configure it.

@c --------------------------------------------------------------------------
@subsubsection Options (Syntax help)

This dialog box allows the configuration of the syntax help.
@xref{Syntax help}.
@paragraph{}

The search method used can be:
@paragraph{}
@itemize @bullet

@item Exact: Only exact matches are reported.
@item Substring: Partial matches are reported.
@item Fuzzy: It uses a special algorithm that reports words similar to the
one you are searching.
@end itemize

The available options are:
@paragraph{}
@itemize @bullet

@item Case sensitive: The search interpretes lower case characters as different
than uppercase characters.
@item Sort by score: The matches are sorted by score when reported. When
disabled the sorting criteria is alphabetical. A greater score means the
match is more similar to the word you are searching. A score of 1000
means exact match.
@item Fuzzy value: That's used only when the selected mode is the fuzzy mode.
It indicates the minimal score a word must have to be displayed as
a possible match. Experiment with different values and see the scores
reported.
@end itemize

@refMenu1{cmeSyntaxHelpOps}

@c --------------------------------------------------------------------------
@subsubsection Files to search (Syntax help)

Here you can indicate in which info files the editor will search the name of
the function; the default is OS dependent. @xref{Syntax help}.
@paragraph{}

You can specify an info node or just the name of the file. In the first case
the editor will read all the cross references found in this node, in the
second the editor will use all the nodes of the file. Normally the node that
contains all the relevant references is called Index, but there are
exceptions; one interesting case is libc.
@paragraph{}

In the dialog the editor shows which nodes are searched in. If the name
has a question mark to the left it means the editor didn't read the file
yet, pressing @key{^F1} over any word the editor will search it and hence
will read the help files. If the name has an asterisk it means some error
was encoutered when trying to read this file. Finally if no mark is indicated
it means the editor successfully read the file, additionally the number of
nodes found is indicated to the right. You can add or remove nodes from the
list.
@paragraph{}

@refMenu1{cmeSyntaxHelpFiles}

@c --------------------------------------------------------------------------
@subsubsection Search (Syntax help)

It makes the syntax search and report the matches found. If only one match
was found the editor jumps to this node. @xref{Syntax help}.
@paragraph{}

@refMenu{cmeSyntaxHelp,^F1}

@c --------------------------------------------------------------------------
@chapter Editing Modes

  The editor has various settings that control the function and aspect of
the editor.
@paragraph{}

  The settings are:
@paragraph{}

@section Overwrite
@cindex Overwrite

  This setting controls if the typed characters are inserted in the buffer or
replace the original ones. @x{Insert and Delete}
for a detailed explanation.

@section Autoindent
@cindex Autoindent

  This setting controls what happens when you press @key{ENTER}. If this setting
is off the cursor goes to the column 1 of a new line. If the
mode is on the editor will try to mimic the indentation of the code by 
inserting spaces or tabs. @x{Optimal Fill}.

@section Real Tabs
@cindex Real Tabs
@cindex Use Real Tabs
@cindex TABs

  This setting controls what happens when you press @kbd{@key{TAB}}. If this
setting is on the editor will insert an ASCII 9 at this position.
@paragraph{}

  An ASCII 9 is a TAB, that means that the width of this char is enough to
move the cursor to the next tabulator column. In the editor the tabulator
columns are equidistant and the positions are controled by the Tab Size value.
@paragraph{}

  If this setting is off the editor won't put any ASCII 9 in your text.
The behavior is configured by the @il{Tab indents} option. Read the section
about it for more information. @x{Tab indents}.
@paragraph{}

  You can also indent using spaces when this option is disabled. For more
information consult the @il{Use indent size} option.
@x{Use indent size}.
@paragraph{}

  In the past (versions older than 0.4.44) another thing controlled by this
setting was the behaviour of the @key{Backspace} key, but now that's
controlled by the @il{Backspace unindents} option. @x{Backspace unindents}.
@paragraph{}

  The editor is much more coherent when you choose to use TABs or not use
TABs. If you mix the two modes you'll get some unexpected results, especially
in the indentation of the blocks.
@paragraph{}

  If you never use tabs, it's better you work with this setting off.
Then you'll get much from the editor.
@paragraph{}

  Now you can say: @il{But I really need tabs because I'm editing a make file!} or
@il{because I will send the file using an ultra slow link} @il{and I want the compression
granted by the tabs.} In these cases you can first expand all tabs, then
work without real tabs and at the finish of your work compact all possible
spaces and generate a file with tabs.
@x{Miscellaneous} section.
@paragraph{}

  Most tabs users also like to enable the @il{Optimal Fill} option. @x{Optimal Fill}.@*
I also suggest using the following options to complement the indentation when
using tabs: @il{Autoindent} @b{ON}, @il{Intelligent C indent} @b{OFF}, @il{Optimal
Fill} @b{ON}, @il{Do not move inside tabs} @b{ON}, @il{Tab smart indents}
@b{OFF}, @il{Use indent size} @b{OFF} and @il{Backspace unindents} @b{OFF}.
@paragraph{}

@section Persistent Blocks

  This setting controls the behaviour of the selected area.
@paragraph{}
  @x{Block modes} chapter for a detailed explanation.
@paragraph{}

@section Intelligent C indent
@cindex Intelligent C indent

  This mode was designed to be used jointly with the Pseudo Macros
(@x{Pseudo Macros}) and the Real Tabs mode off to achieve an
easy way to indent the code that does a better job than the Autoindent mode.
@paragraph{}

  In this mode the spaces inserted after pressing @key{ENTER} depend on
the first word in the last line. For example, if you have:
@paragraph{}

@smallexample
if (a==b)_
@end smallexample

  With the cursor in the '_' position and press @key{ENTER} you'll get:
@paragraph{}

@smallexample
if (a==b)
  _
@end smallexample

  Now you can do either of two things, 1) press space and write the code that will
be executed by the if, or 2) if this a multiline code press @{ and @key{ENTER}.
In the last case you'll get:

@smallexample
if (a==b)
  @{
   _
@end smallexample

  Now type your first line of code. Press @key{ENTER}. Write your next line.
Press @key{ENTER} again and then @key{Backspace}:

@smallexample
if (a==b)
  @{
   1st line;
   2nd line;
  _
@end smallexample

  Now type @} and press @key{ENTER} one more time:

@smallexample
if (a==b)
  @{
   1st line;
   2nd line;
  @}
_
@end smallexample

  As you can see the code is perfectly aligned without a significant work
on your part.
@paragraph{}

  I tried to make this mode as smart as possible, but it still needs more
work. If you have suggestions contact me.
@paragraph{}

  Another important thing is that this indentation has a personal style,
my style ;-), so it may be you don't like it. If that's the case you can
do the following things:
@paragraph{}

@itemize @bullet
  @item Use another way of indentation offered by the editor. For example,
turn on the Real Tabs mode and indent with tabs.
  @item Customize the @file{cpmacros.pmc} file (@x{Pseudo Macros}), actually this
file is coherent with this mode.
  @item The editor isn't configurable like Emacs or Brief using a language,
but is written in C++. If you know C++ contact me and I'll help you to write
the routines that you need to get an indentation in your own style :-).
@end itemize

@subsection Can you explain more about the behavior of this mode?

  I'll try to describe the behaviour of the mode:
@paragraph{}
  Each time you press @key{ENTER} the editor inserts a @samp{\r\n} string in your
text, after that the editor searches one line located above the new line that
has at least one character on it. This line is taken as reference. The
editor analyzes this line searching for:
@paragraph{}

@itemize @bullet
   @item The first non-blank character on this line.
   @item The first word on this line.
   @item The first parenthesis.
   @item The balance of parentheses on the line.
   @item The last non-blank and non-comment character in the line.
@end itemize

  Now, if the line contains @{ at the beginning the editor goes to the first
column after the @{.
@paragraph{}
  If the line contains @} at the start the editor will go to the same column
of the @} and then will perform a @key{Backspace}. If the Real Tabs
mode is off, that's an unindent. @x{Real Tabs}.
@paragraph{}
  If the line starts with a C++ comment the effect is the same as in
Autoindent. @x{Autoindent}.
@paragraph{}
  If the line starts with a C comment the editor will try to skip the
comment and analyze the rest of the line, but if the comment doesn't end
on this line the editor will go to the column where the @samp{/} is.
@paragraph{}
  If the line starts with @samp{/} the editor goes to this column.
@paragraph{}
  If the line has more @samp{(} than @samp{)} the editor will go to the column of the
first non-blank after the first @samp{(}.
@paragraph{}
  If the line has more @samp{)} than @samp{(} the editor will search the line where the
number of parentheses is balanced, then will analyze this line. If the whole
line still generates an unbalanced situation the editor will go to the
first used column in the line that was found the first time. But if this
line will leave all brackets balanced the editor will take the first word on the
line and will use it as reference.
@paragraph{}
  At last, and according to the word found, the editor will use this
word as reference. The editor recognises the following keywords:
@paragraph{}

@table2-auto{Keyword,Action}
@clear table-set-center
@titemR{@samp{do},+2 but not if @dots{} ;}
@titemR{@samp{if},+2 but not if @dots{} ;}
@titemR{@samp{for},+3 but not if @dots{} ;}
@titemR{@samp{else},+2}
@titemR{@samp{case},+5}
@titemR{@samp{while},+2 but not if @dots{} ;}
@titemR{@samp{switch},+2}
@titemR{@samp{break},unindent}
@titemR{@samp{return},unindent}
@titemR{@samp{default},+5}
@endtable-{}

  The numbers represent how many spaces are added with reference to the first letter
of the word.  'not if @dots{} ;' means that, if the line ends with
a semicolon, the editor will do the same as for Autoindent. @x{Autoindent}. The
unindent is performed with @key{Backspace}.
@paragraph{}

  Seasick? @x{Do you have more examples?}.
@paragraph{}

  Note: Some of these features were added in v0.2.14 of the editor based on a
suggestion of @email{Bradford L.@: Spencer, stud73@@nortel.ca} about the
behaviour of the mode on a line like this @samp{printf("Num: %d",} with the
rest of the parameters on the next line.
@paragraph{}

@subsection Do you have more examples?

  Well here are some other examples. I used a strange convention, like this:
if I say type `a[ENTER]@{', type the letter @kbd{a}, then press @kbd{@key{ENTER}} and
finally press the `@{' key.
@paragraph{}

Example 1: (similar to one explained before but is to show the
convention)
@paragraph{}

@smallexample
Type:
if (a==1)[ENTER]@{[ENTER]a=2;[ENTER]b=3;[ENTER][BACKSPACE]@}[ENTER]

You'll get:

if (a==1)
  @{
   a=2;
   b=3;
  @}
[<--- cursor here]
@end smallexample


Example 2: A switch/case example
@paragraph{}

@smallexample
Type:
switch(a)[ENTER]@{[ENTER]case 1:[ENTER]a=2;[ENTER]b=3;[ENTER]break;
[ENTER]case 2:[ENTER]b=5;[ENTER]break;[ENTER][BACKSPACE]@}[ENTER]

You'll get:

switch(a)
  @{
   case 1:
        a=2;
        b=3;
        break;
   case 2:
        b=5;
        break;
  @}
[<--- cursor here]
@end smallexample


Example 3: A call to a function that takes a lot of parameters
@paragraph{}

@smallexample
Type:
printf([SPACE]"Num: %d",[ENTER]a[SPACE]);[ENTER]

You'll get:

printf( "Num: %d",
        a );
[<--- cursor here]
@end smallexample


Example 4: A lot of parentheses
@paragraph{}

@smallexample
Type:
if[SPACE]([SPACE](a==1)[SPACE]||[ENTER](b==2)[SPACE]||[ENTER]
c[SPACE])[ENTER]

You'll get:

if ( (a==1) ||
     (b==2) ||
     c )
  [<--- cursor here]
@end smallexample


Example 5: Comment trying to interfere part 1
@paragraph{}

@smallexample
Type:
/*-a-*/for[SPACE](x=1;x;--x)[ENTER]

You'll get:

/*-a-*/for (x=1;x;--x)
          [<--- cursor here]
@end smallexample


Example 6: Comment trying to interfere part 2
@paragraph{}

@smallexample
Type:
for[SPACE](x=1;x;--x);[SPACE]//-b[ENTER]

You'll get:

for (x=1;x;--x); //-b
[<--- cursor here]
@end smallexample


 Note: Of course you can fool the editor but as you can see it is relatively
smart ;-).
@paragraph{}

@section Column cursor
@cindex Column cursor

  This setting enables a strange feature of the editor. When on the column
where the cursor is is highlighted. This feature is very good
to check if parts of your code are aligned correctly.
@paragraph{}

  If you like this mode but think it's very uncomfortable to use all the time
contact me and if I get enough feedback I'll create a hotkey for it to be
turned on/off quickly.
@paragraph{}

@section Row cursor
@cindex Row cursor

  This setting is similar to the column cursor but acts on the row
where the cursor is. If you enable the two modes you'll get a cross on the
screen showing where the cursor is.
@paragraph{}

@section Match pair highlight
@cindex Match pair highlight

  This mode acts showing the pairs of (/), [/] and @{/@} on the fly. Each
time you type one of these symbols the editor will search the matching
pair, if the editor finds it and the match is on the screen both will be
highlighted, if the match is outside the screen the editor will inform the
position on the status line, and if there is no match the editor will
inform the situation in the status line too.
@paragraph{}

  That's very useful when you are typing complex parenthetical expressions or
a very nested code. You can use it together with the @il{cmcSearchStart},
@il{cmcSearchEnd}, @il{cmcSearchOpPar}, @il{cmcSearchClPar}, @il{cmcSearchOpCor} and
@il{cmcSearchClCor} commands. (@x{Miscellaneous}).
@paragraph{}

  If you want to get highlight not only after typing but also when moving the
cursors you'll need to enable the @il{Match pair on the fly} option.
@x{Match pair on the fly}.
@paragraph{}

@section Match pair on the fly
@cindex Match pair highlight all the time

  This mode is very similar to the @il{Match pair highlight} mode. If you
don't know how it works please read the @il{Match pair highlight} section
first. @x{Match pair highlight}.
@paragraph{}

  The main difference is that this mode highlights the pair when the cursor
is @b{over} the character to search.
@paragraph{}

  The highlight is done half a second after you stop typing to avoid interfering
with your typing. But if you have a fast machine, not just a 386, you can
configure the editor to do the search without waiting.
@x{Do not wait to search the pair}.
@paragraph{}

@section Do not wait to search the pair

  This option works only when @il{Match pair on the fly} is enabled. When
enabled the editor doesn't wait to do the search of the complementary pair.
I think this could impact the performance of scrolling on very slow machines
and that's why it's optional. @x{Match pair on the fly}.
@paragraph{}

@section Transparent Blocks
@cindex Blocks, transparent

  When this mode is on you can see the syntax highlighting of selected blocks. Normally
the selection affects the background and foreground colors, but when using transparent
blocks only the background is affected.

@section Optimal Fill
@cindex TABs, indenting with
@cindex Real Tabs when indenting

  This mode was added for the people that use ASCII 9 tabulators in their code
(@x{Real Tabs}). Normally the editor uses spaces to indent the code or, in general,
to fill any gap in the text. When you enable this mode the editor will use as many
tabs as possible to fill these gaps. That's what the tab users normally expect.

@section Wrap Words
@cindex wrapping

  Even when the editor is mainly intended for programmers it became apparent that some other
user groups want to use it too.
@paragraph{}
  The word wrap added to the editor is a very simple one, it just inserts a new line
if you type a word beyond the wrap column, that's all. You won't get automatic reformat
functions like in text editors intended for love letters (like the one from the Bill
Gates company).
@paragraph{}
  The wrap column box is used to enter the column that triggers the wrap.

@section Do not move the cursor on Paste
@cindex Paste, do not move the cursor

  That's a global setting. When it's on the cursor isn't moved after pasting. Normally
the cursor is moved to the end of the pasted block, but sometimes it's better if the
cursor isn't moved.

@section Scroll Lock centers
@cindex centering the screen while typing

  When this mode is on the Scroll Lock key has a special meaning. If the Scroll Lock
LED of your keyboard is on then the editor centers the current line in the window. The
effect is very strange but the advantage is that you don't need to follow the movement
of the line with your eyes because it's always in the same place.

@section See Tabs
@cindex TABs, highlight/see

  In this mode the tabs are highlighted, two colors are used for this purpose,
one for even and the other for odd numbered tabs. In this way you can clearly
see where a tab is located and the size of the tab. The colors can be
customized from the Colors menu option. @xref{Customize Colors}.
@paragraph{}

  This mode was introduced in v0.4.23 and is globally enabled by default.

@section Do not move inside tabs
@cindex TABs, skipping/through
@cindex cursor through tabs

  In this mode the cursor can't be placed inside a tab character. This
definition is fuzzy and confusing so here I'll try to explain it better. One
tab character can be expanded to one or more characters when displayed on the
screen. Normally you can place the cursor in any of the spaces that belong to
a tab character. I think this behavior is the best because you are free to
move the cursor to any place you want, but tab users get confused when they
type and discover they had the cursor in the middle of a tab. It produces a
cursor jump. To avoid this kind of surprise a lot of editors don't allow
to position the cursor in these spaces, only in the first space.
@paragraph{}

  This mode was introduced in v0.4.23 and is globally enabled by default.

@section Tab indents
@cindex No real tabs
@cindex Tab as spaces

  When @il{Use real tabs} option is disabled the editor will insert enough
spaces to move the cursor to the next tab-stop or indent position. But if
this option is enabled the editor will insert enough spaces to move the
cursor to the beggining of the next word in the previous line.
Confused? Sorry for my English, an example will clarify that:
@paragraph{}

This is a line above the line you are
@paragraph{}

That's the line where the cursor is, at column one.
@paragraph{}

  After pressing TAB you'll get:
@paragraph{}

This is a line above the line you are
@paragraph{}

     That's the line where the cursor is, at column one.
@paragraph{}

  Now you'll ask, Why this? Is that useful? The answer is that's very useful
to keep your code indented. Experiment using that under a line with if, for,
@il{etc.}
@paragraph{}

  Another option is to indent like the Tab key but using a size different
than the tab size. This can be done disabling this option and enabling
@il{Use indent size}. @x{Use indent size}.
@paragraph{}

@section Use indent size
@cindex Indent amount
@cindex TABs as spaces

  When the @il{Real Tabs} and @il{Tab indents} options are disabled you can
indent with the tab key but using spaces. Sometimes people want to use tabs
of eight spaces because this is the most common value for consoles and
printers but, at the same time, they want to indent by a different amount of
spaces pressing tab. In this situation you must enable this option and
configure the indentation amount in the @il{Indent size} box.
@paragraph{}

@section Do not purge spaces
@cindex Spaces, purging at the end of line

  Normally the editor purges any space after the last visible character in a
line. That's very useful to save disk space and to avoid problems with end of
line continuation sequences, like in C language. But sometimes you may want
to avoid it for some reason. Enabling this option the editor won't
try to remove extra spaces at the end of lines.
@paragraph{}

@section Backspace unindents
@cindex Backspace behavior
@cindex Unindenting with backspace

  When this option is enabled the @key{Backspace} deletes as many spaces as
necessary to move the cursor to the first used column of the previous line.
Basically it keeps the indentation. However, this is true only when all the
characters located to the left of the cursor are spaces or tabs.
@paragraph{}

  In versions older than 0.4.44 this option was implicitly enabled when the
@il{Real Tabs} option was disabled. When loading old desktop files the editor
enables/disables this option based in the @il{Real Tabs} option.
@paragraph{}

@section Column Markers
@cindex columns, marking

  Column markers highlight a column of text. This option is useful for
programming languages where the column is important or when you just need to
have some column positions as references.
@p{}

  You can set various column markers at the same time, just enable this
option and enter a list of columns in the associated text box. The columns
should be separated by spaces and sorted incrementally. The editor will
format the list in this way.
@p{}

@section Syntax Highlighting
@cindex syntax highlighting extensions

  The editor can highlight the syntax of your code. The available modes
are:
@paragraph{}

@itemize @bullet
  @item No highlighting, all the code is with the same color.
  @item C/C++ Highlighting.
  @item Pascal Highlighting.
  @item Clipper Highlighting.
  @item User defined. Including already defined for:
  @itemize @bullet
    @item 4DOS batch files
    @item 80x86 assembler (AT&T syntax)
    @item 80x86 assembler (Intel syntax)
    @item 8x51 assembler
    @item Ada
    @item BASIC
    @item C/C++
    @item Cascading Style Sheets version 2
    @item Clipper 5.x
    @item Command Line Errors File
    @item Environment files
    @item Fortran
    @item HTML
    @item Internationalization files (.po)
    @item Java
    @item Java Script
    @item Makefiles
    @item Menu files
    @item Modula 2
    @item Netwide Assembler (NASM)
    @item Objetive C
    @item Pascal
    @item PDP11 assembler
    @item Perl
    @item PIC assembler (Microchip)
    @item PLM/51
    @item PMacros files
    @item PostScript
    @item Python
    @item Ruby
    @item SDG format files
    @item sLisp macros
    @item SQL
    @item The syntax highlight file itself
    @item TCL/Tk
    @item TeX
    @item Texinfo
    @item UNIX shell scripts
@c Currently SDH doesn't support it in other column that 1, sorry.
@end itemize
@end itemize

  The kind of highlighting is chosen automatically using the extension of the
file. Additionally the editor supports Emacs-like mode selection. Emacs
searches the name of the editing mode in the first kilobyte and last three
kilobytes of text. The editing mode is delimited by @code{-*-} and the
editor will use it instead of the file extension to select the highlighting mode.
That's very useful for files without extensions like the new C++ headers.
To add even more flexibility I'm supporting another technique used by some
C++ headers from Silicon Graphics and Hewlett Packard, in these headers the
mode is located in the last lines using some special keywords.
@paragraph{}

  The editor also supports the convention used for UNIX script files. If a
file starts with @code{#!} this line indicates the program that must be
executed to interpret the script. The editor reads this line and extracts the
name of this program and searches it in the @code{ShellScript} definition.
@paragraph{}

  The C/C++ highlighting was designed for the GNU C compiler.
@paragraph{}
  The Pascal highlighting was designed for the GNU Pascal compiler.
@paragraph{}
  The Clipper highlighting was designed for the CA-Clipper 5 compiler.
@paragraph{}

  The highlighting can be customized, @x{Syntax Highlighting File}.

@chapter Syntax Highlighting File

  The highlighting can be customized editing the @file{syntaxhl.shl} file. You can add
syntax highlighting to almost any kind of files, a good example is the fact that the files
used to configure the editor have their own syntax highlighting.
@paragraph{}

  The file declares the settings for each kind of files. Each declaration ends with an
@code{End} marker. The @code{#} acts as a start of command if it appears in the first
column.
@paragraph{}

  Important things you have to know to add a new syntax highlighting:
@paragraph{}
@itemize @bullet
  @item In previous versions when adding a new highlight mode it ought to have
been added at the end of the file, now this isn't mandatory.
  @item The editor remembers various settings of loaded files even after
closing the file. This includes the syntax highlighting, so if you add
a new one or added a new extension to the list and you open a file
that you already opened the editor will remember the last settings
and doesn't use the new setting. In this case you must force it by
hand.
  @item If you feel that this new highlight mode can be used by other users send
it to me and I'll include it in the next release. Many of the
currently included syntax highlightings were contributed by users.
@end itemize
@paragraph{}

  If you want to add some keywords to a language for personal use don't do it
in the @code{Keywords} section because you will need to edit this file each
time you install a new release of the editor. The editor provides another
file for it and also a nice user interface to add and delete words defined by
the user. @x{User Words}.
@paragraph{}

  The next sections covers the supported settings.
@paragraph{}

@section AllowedInsideNames

  Some languages include symbols inside names, you can list these symbols here.
Normally the editor allows letters, digits and underscore. These characters are allowed
inside the names and not at the start of the name. @x{CanStartAName}.

@section CanStartAName

  Some languages includes symbols at the start of names, you can list these symbols
here. Normally the editor allows letters and underscore. These characters are allowed
at the start of the name and not inside. @x{AllowedInsideNames}.

@section Case

  When this setting is 1 all the keywords become case sensitive. If the keywords aren't
case sensitive don't use it.
@paragraph{}
  This should be declared as one of the first settings because it affects how
other definitions are loaded in memory. I suggest using it before @code{Name} and
@code{Files} and after the others.

@section CloseComment1

  Used to indicate the end of a multiline comment. The lenght is limited to four
characters. If the file format has two different terminations use
@code{CloseComment2} for the second.
@paragraph{}
  For more information @x{Format of short syntax highlighting definitions}.

@section EmacsModes
@cindex syntax highlighting, Emacs modes

  It indicates which Emacs modes will use this highlighting. The modes must be
separated by commas. The modes are't case sensitive.
@paragraph{}
  As in Emacs the editor looks at the first kilobyte of text and at the last
three kilobytes for the mode delimited by @code{-*-}.
@paragraph{}
  The priority is as follows: @code{EmacsModes}, @code{ShellScript} and
finally the extension (@code{Files}). @x{ShellScript}. @x{Files}.

@section EOLCInFirstCol

  When this setting is on the one line comments starts only if the sequence of
characters is present in the first column.

@section EOLCInFirstCol1

  That's like EOLCInFirstCol but affects only the EOLComment1 and not both.
@x{EOLCInFirstCol}.

@section EOLCInFirstCol2

  That's like EOLCInFirstCol but affects only the EOLComment2 and not both.
@x{EOLCInFirstCol}.

@section EOLCInFirstUse1

  That's like EOLCInFirstCol1 but the starting sequence may be the first
non-blank character and does not need to be located in the first column.
@x{EOLCInFirstCol1}.

@section EOLCInFirstUse2

  That's like EOLCInFirstCol2 but the starting sequence may be the first
non-blank character and does not need to be located in the first column.
@x{EOLCInFirstCol2}.

@section EOLComment1

  Used to indicate the start of a comment that ends at the end of the line. The lenght
is limited to four characters. If the file format has two different terminations use
@code{EOLComment2} for the second.
@paragraph{}
  For more information @x{Format of short syntax highlighting definitions}.

@section Escape

  Indicates which character acts as escape character inside strings or to concatenate
lines.

@section EscapeAnywhere

  Indicates that escape characters can be found anywhere, not just inside
strings or at the end of lines like in C.

@section Files
@cindex syntax highlighting, extensions

  It indicates which extensions will use this highlighting mode. The extensions must be
separated by commas. The extensions are case sensitive, be careful.
@paragraph{}
  The editor can also choose the highlighting using the Emacs mode or the
program used to execute the file if that's an UNIX script.
@paragraph{}
  The priority is as follows: @code{EmacsModes}, @code{ShellScript},
@code{FullNameMatch}, @code{NameMatch} and finally the extension
(@code{Files}). @x{ShellScript}. @x{EmacsModes}. @x{FullNameMatch}.
@x{NameMatch}.

@section FullNameMatch
@cindex syntax highlighting, matching a path

  It can be used to indicate a regular expression to match the full path and
name of the file. If the expression matches the editor will use this syntax
highlighting.
@paragraph{}
  The regular expression must be in Perl format. You can read about it in
any book about Perl.

@section HexMarker

  This setting indicates what prefix is used for hexadecimal numbers. No postfix
is supported yet. The lenght is limited to four characters.
@paragraph{}
  For more information @x{Format of short syntax highlighting definitions}.

@section Keywords

  It can be used as many times as needed and is used to indicate the reserved keywords
of the language. The separator is the comma.

@section Name

  It sets the name of the syntax highlighting. This name is used in the local settings
dialog (cmcSetLocalOptions).

@section NameMatch
@cindex syntax highlighting, matching a name

  It can be used to indicate a regular expression to match the name of the
file. If the expression matches the editor will use this syntax highlighting mode.
@paragraph{}
  The regular expression must be in Perl format. You can read about it in
any book about Perl.

@section NoCheckNumbers

  When this setting is on the numbers aren't highlighted.

@section OpenComment1

  Used to indicate the start of a multiline comment. The lenght is limited to four
characters. If the file format has two different starts use @code{OpenComment2} for
the second.
@paragraph{}
  The maximum length is four characters, for more information about the format:
@x{Format of short syntax highlighting definitions}.

@subsection Format of short syntax highlighting definitions

  All the characters after the equal sign are taken as part of the field. Blank spaces
after the equal sign are ignored, so @samp{Field= //} is equivalent to @samp{Field=//}.
@paragraph{}
  As the field may start with spaces and spaces at the end of line are invisible
you can quote the text using the double quote letter. If you do it the first character
after the equal sign must be the double quote, if you left an space like this:
@samp{Field= "} the double quote will be interpreted as part of the field.
@paragraph{}
  When quoting text the back slash is the escape character, so this: @samp{Filed="\""}
will be interpreted as asigning @samp{"} to @code{Field}.

@section PartialKeywords

  When this setting is enabled the list of the editor will highlight partial matches of
the keywords. For example, suppose a keyword is defined as @samp{key} and you type
@samp{keytable}, in this case the editor will highlight the @samp{key} part of the
word. This feature is experimental and makes the highlighting quite slower.

@section PMacros

  Indicates the name of the pseudo macros file used for this kind of files. Using
different files for different formats you can assign common triggers to different
actions. For example, you can use i( to trigger an if() @{@} else @{@} in C and
an if then else in BASIC. @x{Pseudo Macros}.

@section Preprocessor

  Indicates which symbol starts a preprocessor line.

@section RelaxNumberCheck

  This is used when a number can start a name and that isn't a error.
Normally the editor takes it as a wrong number but when this
option is enabled the check for numbers is relaxed and they aren't highlighted as
wrong values.

@section ShellScript
@cindex syntax highlighting, shell scripts

  It indicates which scripts will be highlighted. You must indicate the names
of the programs associated with this script. The names are case sensitive.
@paragraph{}
  The editor looks for the @code{#!} characters at the start of the file, if
found the name of the program is extracted and searched in this list.
@paragraph{}
  The priority is as follows: @code{EmacsModes}, @code{ShellScript} and
finally the extension (@code{Files}). @x{EmacsModes}. @x{Files}.

@section ShortString

  Used to indicate the start and end of strings, used for small strings or characters.
The string ends at the end of line if not explicitly closed.

@section SpecialSymbol

  That's used to mark pairs of characters that form a particular symbol that will
generate problems if the editor sees them as separated symbols. It was created to
avoid problems with @samp{$#} in Perl and bash scripts and with @samp{@@@@} in Texinfo
files. You can define more than one character here.
@paragraph{}
  The characters that can be combined with it are specified using the
@code{SpecialSymbolCont} definition.

@section String1

  Used to indicate the start and end of strings, used for long strings. You can specify
more than one character, in this case any of them can open or close the string.
@paragraph{}
  The editor supports up to three diferent strings declared as @code{String1},
@code{String2} and @code{String3}.

@section Symbols1

  Used to indicate which characters are allowed to be symbols, normally used for boolean and
arithmetic symbols.

@section Symbols2

  Used to indicate what characters are allowed to be symbols, normally used for flow control
and subindex symbols.

@section UseInternal

  That's optional. When a highlighting mode has this setting the editor will use the internal
routines and will ignore almost all the settings. Only the extensions (@x{Files}) and
pseudo macros (@x{PMacros}) settings are used.
@paragraph{}
  The value assigned can be: 1 for GNU C highlighting, 2 for standard Pascal and 3 for
Clipper.

@chapter Pseudo Macros
@cindex Pseudo Macros
@cindex cpmacros.pmc

  This feature is very useful to save some keystrokes. With this feature you
can create a lot of shortcuts to make your life easier.
@paragraph{}

@section Please enlighten me - what is that?

  So now, What's a Pseudo Macro? It's like a macro but it's triggered by two
things: one the text before the cursor, and two the @kbd{^Space} combination.
@paragraph{}

  And what's the result? The result is customizable, but by default there are
some predefined behaviours. For example, in a C source window type the following
two characters: @kbd{#i} and then press @kbd{^Space} @dots{} (to create an empty
file with .c extension go to File|Open and type a new name, foo.c for example).
@paragraph{}

  Surprised? I bet! You got: #include <.h> and the cursor just at the right
place to write the name of the header.
@paragraph{}
Now write the famous stdio word, press @kbd{@key{End}}, then @kbd{@key{Enter}} twice and now write
the following two letters: @kbd{ma} and then @kbd{^Space} @dots{}
@paragraph{}

  I bet this time you had an inkling of what will happen so you aren't that
surprised ;-). Anyways, Surprise! Now type @kbd{pr} and the magic keys and @dots{}
@code{printf("");} appears. To end the happy history now type "Hello world!" That's
all. You wrote the hello world program at a very good speed.
@paragraph{}

  Now you know what I mean when I say pseudo-macros.
@paragraph{}

@section How can I customize that?

  It's very easy. Each syntax highlighting has its own pseudo macros file. Which
file belongs to which syntax highlighting is indicated in the @file{syntaxhl.shl}
file. @xref{Syntax Highlighting File}. In the case of C/C++ the file is called
@file{cpmacros.pmc} and is located in the same directory where the rest of the
configuration files are installed. This file contains the definitions for each
pseudo macro that can be triggered in C/C++ files. You can define as many
pseudo macros as you want.
@paragraph{}

  Important: If you are using RHIDE consult the RHIDE documentation to know
where the @file{cpmacros.pmc} file is stored.
@paragraph{}

  The @file{cpmacros.pmc} file is a very good example and is self-explanatory but
I'll include one example here.
@paragraph{}

@format
Trigger: "i("
Mode: 0,1,0,1,0
 "if (@@0)\n"
 "  @{@@1\n"
   "@}\n"
 "\belse\n"
 "  @{@@2\n"
   "@}"
@end format

  The Trigger keyword defines the two letters before the cursor that will
trigger the pseudo macro.
@paragraph{}
  The Mode keyword indicates the mode that the editor will use when inserting
the text. The modes are:
@paragraph{}

@itemize @bullet
  @item Overwrite               @x{Overwrite}
  @item Autoindent              @x{Autoindent}
  @item Use Tabs                @x{Real Tabs}
  @item Persistent blocks       @x{Block modes}
  @item Intelligent C indent    @x{Intelligent C indent}
@end itemize

  Each mode can be 0 or 1. The editor will return to the original mode after
expanding the pseudo macro. In this case the macro is expanded like this: No
overwrite, autoindent, don't use tabs, the blocks are persistent
and don't be smart when indenting.
@paragraph{}

  The rest is the code to insert enclosed by ". You can use \b to indicate
backspace, \n for newline and \\ to indicate a simple \. If you want to
insert a @@ you have to type it twice @@@@, because this character
has a special meaning (see below).
@paragraph{}

  After the insertion the cursor is positioned in the place marked with @@0.
Don't forget to signal this point or the cursor will be positioned at the
beginning of the file. The places marked with @@1, @@2 and @@3 are saved in
the markers 7, 8 and 9.
@paragraph{}

  Currently I defined pseudo macros only for C/C++ and Perl. I did it in a way
that you can use the same pseudo macro for both languages. For example:
@code{#i} is expanded to @code{#include <.h>} for C/C++ files and to
@code{request "";} for Perl files. If you write similar pseudo macros for other
languages please send me the file and I'll add it to the next release.
@paragraph{}

@chapter sLisp macros
@cindex macros from menu
@cindex menues and macros

  The editor uses a lisp like language to store macros. The macros are stored in a file
called @file{macros.slp}.
@paragraph{}

  The macros can be assigned to keys (@x{How to configure the keyboard}), selected
from the @il{Macro} menu or from the menu. From the @il{Macro} menu you can choose a
macro from the list. If you want to repeat it you can do so with one keystroke.
@p{}

  To add a new macro to the list you must edit the @file{macros.slp} file. You can
write the new macro by hand or you can use the @il{Macro} menu to record a macro and
then generate the sLisp code for this macro.
@p{}

  To assign a macro to a menu entry you must edit the @file{menubind.smn}. The macros
are called using @code{cm(name)} where @il{name} is the name of the macro you want to
trigger.
@p{}

  To assign a piece of sLisp code to a menu entry you must use
@code{cm((code))}. Here is an example:
@p{}

@example
 MenuItemC: "Test macro from menu", cm((ShowInMessageWindow "Hi! ;-)"))
@end example

  Don't insert spaces between the starting and ending parentheses pairs.
@p{}

  You can also assing a piece of sLisp code to a key.
@x{How to configure the keyboard}.
@p{}

@section How to write a sLisp macro

  I'll show you an example and then I'll explain each part of the example:
@paragraph{}

@example
(defmacro 'Testing 1 2 3 ;-)'
 (eval
  (SendCommands cmcLineEnd)
  (InsertText (+ 'Hi!' CR 'How are you?'))
  (SendCommands cmcLineUp cmcLineEnd)
 )
)
@end example

  That defines a macro called "Testing 1 2 3 ;-)" that will be expanded to all the code
inside of the @code{eval} sentence. The @code{SendCommands} command sends one or more
commands to the editor. The @code{InsertText} command inserts one string in the code.
To concatenate strings use the @code{+} operator. Currently you can use the @code{\n}
escape sequence inside a string to indicate a carriage return, but in the example above
@code{CR} - a constant - is used to concatenate strings.
@paragraph{}

@section How strings are parsed

  sLisp strings can be delimited by single or double quotes (@code{'} or
@code{"}). Currently both produce the same result but in the future it could
change to be similar to Perl.
@paragraph{}

  A few C escape sequences are supported inside strings. This means the
@code{\ } character has a special meaning. Here are the values supported:

@table2{Character,Interpreted as}
@titemR{n,an OS dependant carriage return (\r\n for DOS and \n for UNIX)}
@titemR{l,simple line feed (ASCII 10 for DOS and UNIX)}
@titemR{r,simple carriage return (ASCII 13 for DOS and UNIX)}
@titemR{t,tab (ASCII 9 for DOS and UNIX)}
@endtable-{}

  In strings that will be inserted in the text you should use the @code{\\n}
escape sequence to maintain compatibility across different OSs. You can also
use the built-in constant called @code{CR}.

@section Running programs with a macro

  There is a sLisp command called @code{RunProgram}. It takes a string as
parameter which can contain one or more programs separated by @code{;} or the
commands separator used by your command shell.
@paragraph{}

  The standard output and error are redirected and the results are sent to
the Message Window. If the program is a GNU tool and reported errors the
editor will parse these errors and will allow you to directly jump to the file
and line where the error was reported.
@paragraph{}

To learn more about the message window @x{Message Window}.
@paragraph{}

@c ************************************************************************************
@section Editor specific commands

  This section describes commands related to files being edited.
@paragraph{}

@c --------------------------------------------------------------
@subsection AskString

  (AskString @var{title} @var{message})
@paragraph{}

  Pops up a dialog asking for user input. The text is returned as an sLisp
string variable. If the user canceled the input, the string has zero length.

@c --------------------------------------------------------------
@subsection ComplChoose

  (ComplChoose @var{options} @var{delimiter} [@var{flags}])
@paragraph{}

  Brings up a floating drop-down list with the options. The
@var{options} parameter is a delimited string, the delimiter is
specified by the @var{delimiter} parameter.
@paragraph{}

  The function returns the option selected by the user or an empty string if
the user aborted.
@paragraph{}

  The list is sorted alphabetically, the user can choose the item using the
cursors or doing an incremental search. Only characters allowed for reserved
words are accepted, any symbol will choose the currently selected item, other
characters will abort.
@paragraph{}

  The @var{flags} parameter fine tunes the behavior of the routine. Currently
only one thing can be changed. By default the string returned contains the
character that produced the selection appended at the end of the string.
Passing 1 for @var{flags} the character isn't concatenated.
@paragraph{}

@c --------------------------------------------------------------
@subsection defmacro

  (defmacro @var{name} @var{expression})
@paragraph{}

  Defines a new editor macro called @var{name}. When this macro is called the
@var{expression} is evaluated. @x{How to write a sLisp macro}.
@paragraph{}

@c --------------------------------------------------------------
@subsection EvalString

  (EvalString @var{string})
@p{}

  Executes the sLisp code contained in the @var{string} variable.
@p{}

@c --------------------------------------------------------------
@subsection FindAgain

  (FindAgain)
@p{}

  Repeats the last search. It should be used when you didn't gave control to
the user since the last search because the user could perform a different
search changing the compiled search. Returns the text found or an empty string
if no match could be found. @x{FindString}.
@p{}

@c --------------------------------------------------------------
@subsection FindString

  (FindString @var{string} [@var{options_flags}])
@p{}

  Performs a search for the provided @var{string}. Returns the text found or
an empty string if no match could be found. This operation moves the cursor
position as in an interactive search. The match becomes temporally
highlighted in the text.
@p{}

  Even when the @var{options_flags} argument is optional it is strongly
recommended to provide it. If nothing is provided the user options will be
used instead. The options are provided as flags combined with the @code{|}
operand. Some of the flags doesn't have any sense when combined with others,
you should avoid doing it. The available flags are:
@p{}

Search style:
@p{}

@itemize @bullet
  @item edfCaseSensitive: perform a case sensitive search.
  @item edfWholeWordsOnly: don't match partial words.
  @item edfRegularEx: the string is a regular expression. Note this flag must
be indicated in adition to the type of regular expressions used.
@end itemize

Scope:
@p{}

@itemize @bullet
  @item edfSearchInComm: search only inside comments.
  @item edfSearchOutComm: search only outside comments.
  @item edfOnlySelection: search only inside the selected text.
  @item edfFromCursor: start searching from the cursor position. That's the
default action.
  @item edfFromBeggining: start searching from the beggining of the selected
scope.
@end itemize

Regular expressions options:
@p{}

@itemize @bullet
  @item edfBasicRegEx: use basic POSIX regular expressions. Used in
combination with edfRegularEx.
  @item edfExtendedRegEx: use extended POSIX regular expressions. Used in
combination with edfRegularEx.
  @item edfPerlRegEx: use Perl regular expressions. Used in combination with
edfRegularEx.
  @item edfOptimizeRegEx: if the string to search doesn't contain special
characters and regular expressions are enabled perform a normal search. This
makes the search much more faster. This is the default action so you don't
really need to specify this flag.
  @item edfNoOptimizeRegEx: it is the opposite of edfOptimizeRegEx flag. It
disables the optimization. Use it when you are sure the string is a regular
expression even when it doesn't look like a regular expression. This option
was created just in case the optimization fails to detect a real regular
expression.
@end itemize

Others:
@p{}

@itemize @bullet
  @item edfShowFuncName: display the name of the function where the match was
found in the status line.
@end itemize

  A very important detail about regular expressions: In sLisp the @code{\}
character is the escape character. It means that you have to use @code{\\} to
get @code{\}.
@p{}

  The following example searchs for the @code{Hello} word followed by a digit
using Perl regular expressions. Then prints the result of the search in the
message window and after it repeats the search.
@p{}

@example
(eval
 (= "str" (FindString "Hello\\d" (| edfRegularEx edfPerlRegEx)))
 (if str
    (ShowInMessageWindow (+ "Found: " str))
    (ShowInMessageWindow "Not found.")
 )
 (= "str" (FindAgain))
 (if str
    (ShowInMessageWindow (+ "Found: " str))
    (ShowInMessageWindow "Not found.")
 )
)
@end example

  To learn more about the search options consult the find command (@x{Find})
and the regular expression options (@x{Regular Expressions Options}). You
could be also interested in learning more about POSIX regular expressions
(@x{Regular Expressions}), for Perl regular expressions consult some Perl
reference. This command is complemented by @code{FindAgain} (@x{FindAgain}),
@code{ReplaceString} (@x{ReplaceString}) and @code{ReplaceAgain}
(@x{ReplaceAgain}) commands.
@p{}

@c --------------------------------------------------------------
@subsection ForceUpdate

  (ForceUpdate)
@paragraph{}

  It forces an update at this point of the macro. That's useful if you want
to stop to ask the user something or the macro will take some time to complete
and don't want to give the impression the editor hangs.
@paragraph{}

@c --------------------------------------------------------------
@subsection GetCursorX

  (GetCursorX)
@p{}

  Returns the X cursor coordinate. Note the coordinates are computed from
zero.
@p{}

@c --------------------------------------------------------------
@subsection GetCursorY

  (GetCursorY)
@p{}

  Returns the Y cursor coordinate. Note the coordinates are computed from
zero.
@p{}

@c --------------------------------------------------------------
@subsection GetCurWindowNumber

  (GetCurWindowNumber)
@p{}

  Returns the window number for the currently selected edition window.
@p{}

@c --------------------------------------------------------------
@subsection GetMaxWindowNumber

  (GetMaxWindowNumber)
@p{}

  Returns the window number for the edition window with the biggest window
number. The lowest number is two.
@p{}

@c --------------------------------------------------------------
@subsection getenv

  (getenv @var{name})
@paragraph{}

  This command returns the content of the environment variable called
@var{name}. Internal variables of the editor are also accessable. If the
variable doesn't exist an empty string is returned.
@paragraph{}

@c --------------------------------------------------------------
@subsection GetSelection

  (GetSelection)
@paragraph{}

  This command returns the selected text in the editor as a sLisp string.
@x{How to write a sLisp macro}.
@paragraph{}

@c --------------------------------------------------------------
@subsection GetSyntaxAtCursor

  (GetSyntaxAtCursor)
@paragraph{}

  This command returns the syntax highlighting flags for the cursor position.
That's very specific and can be used to find out if the cursor is inside a
comment, string or preprocessor code.
@paragraph{}

  To understand how it works use the following macro and trigger it in many
places to see what you get:
@paragraph{}

@example
(defmacro 'Test edfWE'
  (eval
   (ShowInStatusLine (+ "" (GetSyntaxAtCursor)))
  )
)
@end example

  The following table explains the flags returned:
@paragraph{}

@table2{Flag,Meaning}
@titemR{edfComInside,Inside an end-of-line comment}
@titemR{edfEndCom,This line ends a multiline comment}
@titemR{edfEndCom2,This line ends a multiline comment type 2}
@titemR{edfExtCom,This line extends a multiline comment}
@titemR{edfExtCom2,This line extends a multiline comment type 2}
@titemR{edfExtOneLineCom,The end-of-line comment is extended to the next line}
@titemR{edfExtPrepro,The preprocessor line follows in the next}
@titemR{edfExtString,Inside a string}
@titemR{edfExtString2,Inside a string type 2}
@titemR{edfExtString3,Inside a string type 3}
@titemR{edfInsideCom,Inside a multiline comment}
@titemR{edfInsideCom2,Inside a multiline comment type 2}
@titemR{edfPrepro,Inside preprocessor code}
@titemR{edfStartCom,This line starts a multiline comment}
@titemR{edfStartCom2,This line starts a multiline comment type 2}
@titemR{edfStartInCom,This line is commented out by the previous}
@titemR{edfStartInCom2,This line is commented out by the previous (type 2)}
@titemR{edfStartString,This line startes inside a string}
@titemR{edfStartString2,This line startes inside a string type 2}
@titemR{edfStartString3,This line startes inside a string type 3}
@endtable-{}

  Something very important is that the editor will only analyze the line up
to the cursor's position. So if the cursor is inside a string the editor
will think this line extends a string.

@c --------------------------------------------------------------
@subsection GetSyntaxLang

  (GetSyntaxLang)
@p{}

  Returns the language used for syntax highlight in the current editor. If
none syntax highlight is in use it returns an empty string.
@p{}

@c --------------------------------------------------------------
@subsection InsertText

  (InsertText @var{string} [@var{selected} [@var{move}]])
@paragraph{}

  Inserts the @var{string} at the cursor's position. By default the cursor is moved
behind the insertion and the inserted text isn't selected. If @var{selected} is 1
the text is selected. If the @var{move} parameter is 0 the cursor isn't moved and if
the parameter is 1 the action depends on the current editor's setup.
@paragraph{}

@c --------------------------------------------------------------
@subsection MessageBox

  (MessageBox @var{message} [@var{options}])
@p{}

  Pops up a small dialog showing the @var{message} to the user. The
@var{options} can take the following values (use 'or' to combine them):
@p{}

@itemize @bullet
@item edfMBCancelButton: has a @code{Cancel} button.
@item edfMBNoButton: has a @code{No} button.
@item edfMBOKButton: has an @code{Ok} button.
@item edfMBOKCancel: has an @code{Ok} and a @code{Cancel} button.
@item edfMBYesButton: has a @code{Yes} button.
@item edfMBYesNoCancel: has a @code{Yes}, a @code{No} and a @code{Cancel} button.
@item edfMBConfirmation: use @b{Confirmation} as caption.
@item edfMBError: use @b{Error} as caption.
@item edfMBInformation: use @b{Information} as caption.
@item edfMBWarning: use @b{Warning} as caption.
@end itemize

@c --------------------------------------------------------------
@subsection OpenFile

  (OpenFile @var{string})
@paragraph{}

  Opens the file @var{string} in a window and makes it the current one. If the
file doesn't exist it does nothing. Always returns 1.
@paragraph{}


@c --------------------------------------------------------------
@subsection ReplaceAgain

  (ReplaceAgain)
@p{}

  Repeats the last search and replace operation. It should be used when you
didn't gave control to the user since the last search because the user could
perform a different search changing the compiled search. Returns a boolean
value indicating the status of the last search. @x{ReplaceString}.
@p{}

@c --------------------------------------------------------------
@subsection ReplaceString

  (ReplaceString @var{string} @var{replacement} [@var{options_flags}])
@p{}

  Performs a search and replace operation. Returns a boolean value indicating
the status of the last search. Consult the @code{Find} command
(@x{FindString}) and the replace options of the editor
(@x{Replace}) for more information.
@p{}

  In addition to the @code{Find} options you have the following options:
@p{}

@itemize @bullet
  @item edfPromptOnReplace: ask confirmation to the user.
  @item edfReplaceAll: repeat the search and replace operation until no match
can be found in the current scope.
  @item edfNormalText: used to indicate that the @var{replacement} string is
a simple text and not a replacement template. This is the default behavior.
  @item edfTagsText: used to indicate that the @var{replacement} string
contains @code{$n} tags. For more information consult the section for the
regular expressions dialog of the editor (@x{Regular Expressions Options}).
@end itemize

  The following example searchs for the @code{Hello} word followed by a digit
using Perl regular expressions and replaces the text by the digit followed by
an space and the @code{Bye} word. Then prints the result of the operation in the
message window.
@p{}

@example
(eval
 (if (ReplaceString "Hello(\\d)" "$1 Bye"
      (| edfRegularEx edfPerlRegEx edfTagsText))
  (ShowInMessageWindow "Replaced.")
  (ShowInMessageWindow "Not replaced.")
 )
)
@end example

@c --------------------------------------------------------------
@subsection RunProgram

  (RunProgram @var{program_name} [[@var{flags}] @var{parser}])
@paragraph{}

  Calls the desired program. You can pass more than one using the @code{;}
separator or any separator supported by your shell. Under DOS @code{;} is ok
even when command.com doesn't support it. The stderr and stdout are
redirected and captured by the message window of the editor.
@paragraph{}

  Use the operator @code{+} to concatenate strings and pass arguments.
@paragraph{}

  Using @code{edfRunUserScreen} for the @var{flags} argument the editor will
use the user screen when running the external program. Using
@code{edfRunNoRedirect} the editor won't redirect the standard output. For
interactive applications that uses standard input and output you should both
flags combined using the or operator. @x{Operator | (bitwise or)}.
@paragraph{}

  The @var{parser} parameter tells the editor which error parser will be used
to parse the output of the external program. By default the GNU one is used.
@paragraph{}

  To learn more about the message window @x{Message Window}.
@paragraph{}

@c --------------------------------------------------------------
@subsection RunProgramRedir

  (RunProgramRedir @var{program_name} [@var{input_text}])
@paragraph{}

  This function is similar to RunProgram, but the result isn't dumped to
the message window, instead the output of the program is returned as a
string.
@paragraph{}

  Additionally you can specify a text to send to the standard input of the
program you are calling. You can easily call external filters with it. I provide
an example of how to replace a selected text with the output of an external
filter in the @file{macros.slp} file.
@p{}

  Be careful, that's a very powerful command, but very dangerous too.
@paragraph{}

@c --------------------------------------------------------------
@subsection SelectionExists

  (SelectionExists)
@p{}

  Returns 1 if some text is selected and the selection is visible.
@p{}
   
@c --------------------------------------------------------------
@subsection SelectWindowNumber

  (SelectWindowNumber @var{number})
@p{}

  Selects the indicated window. Positive numbers are reserved for edition
windows, except window number one that's the project window. Negative numbers
are used for special windows. The function returns a boolean value indicating
if the desired window was selected.
@p{}

  When you select an edition window it becomes the target of all sLisp
operations.
@p{}

  The available constants for special windows are:
@p{}

@itemize @bullet
 @item edfWinASCII
 @item edfWinCalendar
 @item edfWinClipboard
 @item edfWinHelp
 @item edfWinMP3
 @item edfWinMan
 @item edfWinMessage
 @item edfWinPrj
@end itemize

@c --------------------------------------------------------------
@subsection SendCommands

  (SendCommands @var{command} ...)
@paragraph{}

  Sends all the listed commands to the editor. The editor commands are sLisp constants
that start with @code{cmc}. These commands are the same explained in the keyboard
section as @code{cmcXXXXX}.
@paragraph{}

@c --------------------------------------------------------------
@subsection SetCursorXY

  (SetCursorXY @var{x} [@var{y}])
@p{}

  Sets the cursor coordinates. Note the coordinates starts from zero. If the
@var{y} argument is omitted only the X coordinate is changed. This function
returns the current Y coordinate, it doesn't have to be the same value you
indicated in the @var{y} argument because the editor limits this value to the
last line in the current buffer.
@p{}

@c --------------------------------------------------------------
@subsection ShowInMessageWindow

  (ShowInMessageWindow @var{string} [@var{clear}])
@p{}

  Prints the desired string in the message window. That's a very good way to
show a result to the user.
@p{}

  If the message window isn't selected or visible it gets the focus and
becomes visible. The optional parameter allows you to clean the contents of
the window. @x{Message Window}.
@p{}

@c --------------------------------------------------------------
@subsection ShowInStatusLine

  (ShowInStatusLine @var{string})
@paragraph{}

  Prints the passed string in the status line of the current editor. Tabs
are converted to one space and the message stops at the first carriage
return or line feed. That's a very good way to show a result to the user.
@paragraph{}

@c --------------------------------------------------------------
@subsection WhichEditor

  (WhichEditor [@var{option}])
@paragraph{}

  This command takes one optional parameter and returns the file name of the current
file under edition.
@paragraph{}

  The optional parameter can be:
@paragraph{}

@table3{Parameter,Meaning,Example}
@titemR{edfWEFull (0),Full name and path,\@samp\{c:/temp/test.txt\}}
@titemR{edfWEFullNoExt (1),Same as 0 but without extension,\@samp\{c:/temp/test\}}
@titemR{edfWEPath (2),Path for the file,\@samp\{c:/temp/\}}
@titemR{edfWEDisk (3),Disk drive,\@samp\{c:\}}
@titemR{edfWEExtension (4),File extension,\@samp\{.txt\}}
@titemR{edfWENameNoExt (5),Name without extension,\@samp\{test\}}
@endtable-{}


@c --------------------------------------------------------------
@subsection WordUnderCursor

  (WordUnderCursor [@var{max_length} [@var{options}]])
@paragraph{}

  This command takes one optional parameter and returns the word that's
located under the cursor. That's very useful for things like searching
help about the function the user is typing or things like that.
@paragraph{}

  The maximum length is optional and if you don't specify it 256 is used.
Values under 4 or over 32768 are adjusted to fit this range for security
issues.
@paragraph{}

  The @var{options} parameter is 0 by default. Passing 1 the editor will
return the word located to the left of the cursor, if the cursor is located
at the first character after this word.
@paragraph{}


@c ************************************************************************************
@section General sLisp commands

  This section describes general sLisp commands that can be used from the editor and
the SDG configuration files.
@paragraph{}

@c --------------------------------------------------------------
@subsection and

  (and @var{exp1} @var{exp2} ...)
@paragraph{}

  Returns the logical and of the provided expressions. The values are
evaluated from left to right. If at any point the result is zero then zero is
returned and the rest isn't evaluated.
@paragraph{}

  Each value is evaluated as one or zero.
@paragraph{}

  (and 20 "hello" 4)@*
  Returns 1.
@paragraph{}

  (and 20 4 2)@*
  Returns 1.
@paragraph{}

@c --------------------------------------------------------------
@subsection Operator = (assign)

  (= @var{variable} @var{value})
@p{}

  This is a shortcut for the @code{setv} command. @x{setv}.
@p{}

@c --------------------------------------------------------------
@subsection Operator & (bitwise and)

  (& @var{exp1} @var{exp2} ...)
@paragraph{}

  Returns the bitwise and of the provided expressions. The values are
evaluated from left to right. If at any point the result is zero then zero is
returned and the rest isn't evaluated.
@paragraph{}

  (& 20 4 2)@*
  Returns 0.
@paragraph{}

  (& 20 4)@*
  Returns 4.
@paragraph{}

@c --------------------------------------------------------------
@subsection cond

  (cond @var{condition} @var{exp} [@var{condition2} @var{exp2} ...])
@paragraph{}

  Evaluates the conditions until one is true and returns the associated
expression. If all conditions are false it returns 0.
@paragraph{}

  (cond 0 1 2 3)@*
  Returns 3.
@paragraph{}

  (cond 1 "Hi!" 0 "Bye")@*
  Returns "Hi!".
@paragraph{}

@c --------------------------------------------------------------
@subsection Operator -- (decrement)

 (-- @var{expression})
@p{}

  Returns the integer expression decremented by one. Currently only
integer values are supported.
@p{}

  If the @var{expression} is an string and it corresponds to the name of a
defined integer variable the variable is decremented and the resulting value
is returned.
@p{}

  (-- 8)@*
  Returns 7.
@p{}

  (setv "a_var" 4)
  (++ "a_var")@*
  Returns 3.
@p{}

@c --------------------------------------------------------------
@subsection Operator != (different)

  (!= @var{exp1} @var{exp2})
@p{}

  Returns  zero if both expressions represent the same value. Currently
both expressions must be of the same type.
@p{}

  (== 1 2)@*
  Returns 1
@p{}

  (== 2 (+ 1 1))@*
  Returns 0
@p{}

  (== "Hello" "Hello")@*
  Returns 0
@p{}

@c --------------------------------------------------------------
@subsection Operator == (equal)

  (== @var{exp1} @var{exp2})
@p{}

  Returns an integer different than zero if both expressions represent the
same value. Currently both expressions must be of the same type.
@p{}

  (== 1 2)@*
  Returns 0
@p{}

  (== 2 (+ 1 1))@*
  Returns 1
@p{}

  (== "Hello" "Hello")@*
  Returns 1
@p{}

@c --------------------------------------------------------------
@subsection eval

  (eval @var{expression} ...)
@paragraph{}

  This command is used to specify more than one action where just one is expected.
Additionally you could write sLisp code in a string and then evaluate it. The
expressions are evaluated from left to right, the last evaluated result is returned.
@paragraph{}

@c --------------------------------------------------------------
@subsection exitloop

  (exitloop )
@p{}

  Exits from a loop. @x{loop}.
@p{}
  
@c --------------------------------------------------------------
@subsection gstr

  (gstr @var{string} @var{position})
@paragraph{}

  Returns the @var{position}th character of the @var{string}. The first character is in
the 0 position.
@paragraph{}

  (gstr "hello" 4)@*
  Returns "o".
@paragraph{}

@c --------------------------------------------------------------
@subsection if

  (if @var{condition} @var{statement_1} [@var{statement_2}])
@paragraph{}

  It evaluates @var{condition}, if the boolean value of it is true then
@var{statement_1} is evaluated. If the value is false and you provided a
second statement then @var{statement_2} is evaluated. If the value is false
and the second statement is missing nothing is evaluated and the resulting
value is 0.
@paragraph{}

  (if "hello" 4)@*
  Returns 4.
@paragraph{}

  (if "" 4 3)@*
  Returns 3.
@paragraph{}

  (if 0 4)@*
  Returns 0.
@paragraph{}

@c --------------------------------------------------------------
@subsection Operator ++ (increment)

 (++ @var{expression})
@p{}

  Returns the integer expression incremented by one. Currently only
integer values are supported.
@p{}

  If the @var{expression} is an string and it corresponds to the name of a
defined integer variable the variable is incremented and the resulting value
is returned.
@p{}

  (++ 8)@*
  Returns 9.
@p{}

  (setv "a_var" 4)
  (++ "a_var")@*
  Returns 5.
@p{}

@c --------------------------------------------------------------
@subsection left

  (left @var{string} @var{number})
@paragraph{}

  Returns the first @var{number} characters of the @var{string}.
@paragraph{}

  (left "hello" 4)@*
  Returns "hell".
@paragraph{}

@c --------------------------------------------------------------
@subsection length

  (length @var{string})
@paragraph{}

  This function returns the number of characters in @var{string}.
@paragraph{}

  (length "hello")@*
  Returns 5.
@paragraph{}

@c --------------------------------------------------------------
@subsection loop

  (loop @var{expression} ...)
@p{}

  Evaluates the expressions until an @code{exitloop} command is found.
@p{}

  (= "i" 0)@*
  (loop@*
   (InsertText (tostr i))@*
   (if (== i 5) (exitloop))@*
   (++ "i")@*
  )@*
  Inserts "012345" text.
@p{}

@c --------------------------------------------------------------
@subsection Operator ~ (negated)

  (~ @var{value})
@paragraph{}

  Returns the @var{value} negated (at bit level).
@paragraph{}

  (~ "hello")@*
  Returns 0.
@paragraph{}

  (~ "")@*
  Returns 0xFFFFFFFF.
@paragraph{}

  (~ 1)@*
  Returns -2.
@paragraph{}

@c --------------------------------------------------------------
@subsection not

  (not @var{value})
@paragraph{}

  Returns the @var{value} negated.
@paragraph{}

  (not "hello")@*
  Returns 0.
@paragraph{}

  (not "")@*
  Returns 1.
@paragraph{}

  (not 1)@*
  Returns 0.
@paragraph{}

@c --------------------------------------------------------------
@subsection or

  (or @var{exp1} @var{exp2} ...)
@paragraph{}

  Returns the logical or of the provided expressions. The values are
evaluated from left to right. If any of them is non-zero the result is
non-zero and the rest isn't evaluated.
@paragraph{}

  (or 20 4 2)@*
  Returns 20.
@paragraph{}

@c --------------------------------------------------------------
@subsection Operator | (bitwise or)

  (| @var{exp1} @var{exp2} ...)
@paragraph{}

  Returns the bitwise or of the provided expressions. The values are
evaluated from left to right. If at any point all bits are one the rest of
the values isn't evaluated.
@paragraph{}

  (| 20 4 2)@*
  Returns 22.
@paragraph{}

@c --------------------------------------------------------------
@subsection Operator + (plus)

  (+ @var{value1} @var{value2} ...)
@paragraph{}

  Returns the result of adding all the parameters. The type of the result is determined
by the first parameter. Currently you can't mix strings and integers but if you bug me
enough I'll add it. Adding strings means concatenation.
@paragraph{}

  (+ "hel" "lo")@*
  Returns "hello".
@paragraph{}

  (+ 3 5)@*
  Returns 8.
@paragraph{}

  (+ "hello" 1)@*
  Syntax error.
@paragraph{}

@c --------------------------------------------------------------
@subsection repeat

  (repeat @var{times} @var{expression} ...)
@p{}

  Evaluates the expressions until an @code{exitloop} command is found or the
@var{times} number of iterations is reached.
@p{}

  (= "i" 0)@*
  (repeat 6@*
   (InsertText (tostr i))@*
   (++ "i")@*
  )@*
  Inserts "012345" text.
@p{}

@c --------------------------------------------------------------
@subsection right

  (right @var{string} @var{number})
@paragraph{}

  Returns the last @var{number} characters of the @var{string}.
@paragraph{}

  (right "hello" 3)@*
  Returns "llo".
@paragraph{}

@c --------------------------------------------------------------
@subsection setv

  (setv @var{variable} @var{value})
@paragraph{}

  Assigns @var{value} to the @var{variable}. If the @var{variable} wasn't yet defined
the variable is created. The @var{variable} parameter must be a string representing
the name of the variable, it may also be an expression. This command have a
shortcut. @x{Operator = (assign)}.
@paragraph{}

  (setv "counter" 1)@*
  Assigns 1 to the @var{counter} variable, if @var{counter} doesn't exist counter is created.
@paragraph{}

  (setv (+ "counter" "1") 1)@*
  Assigns 1 to the @var{counter1} variable, if @var{counter1} doesn't exist counter1 is
created.
@paragraph{}

@c --------------------------------------------------------------
@subsection ShortFileName

  (ShortFileName @var{file_name})
@paragraph{}

  Returns the short name for @var{file_name}. That's useful only for Windows
and if long file names are supported. It can be used to pass a file name to
an external program that doesn't support long file names.

@c --------------------------------------------------------------
@subsection sstr

  (sstr @var{string} @var{position} @var{value})
@paragraph{}

  Changes the @var{position}th character of @var{string} to the first character of
@var{value}. The first character is at 0.
@paragraph{}

  (sstr "hello" 1 "a")@*
  Returns "hallo".
@paragraph{}

@c --------------------------------------------------------------
@subsection strcasecmp

  (strcasecmp @var{s1} @var{s2})
@paragraph{}

  This function is the same as @code{strcmp} but this version isn't case
sensitive. @x{strcmp}.
@paragraph{}

@c --------------------------------------------------------------
@subsection strcmp

  (strcmp @var{s1} @var{s2})
@paragraph{}

  This function compares @var{s1} and @var{s2}. The returned value is zero
if the strings are equal, a positive number if @var{s1} comes after @var{s2}
in the ASCII table, else a negative number.
@paragraph{}

@c --------------------------------------------------------------
@subsection strstr

  (strstr @var{string} @var{search} [@var{start_pos}])
@paragraph{}

  Searches the string @var{search} in the string @var{string} starting at
@var{start_pos} position. If @var{start_pos} is not provided the search is
done from the beginning of @var{string}. The returned value is the offset of
@var{search} in @var{string} or -1 if the value wasn't found.
@paragraph{}

  (strstr "hello" "el")@*
  Returns 1.
@paragraph{}

@c --------------------------------------------------------------
@subsection strxlt

  (strxlt @var{string} @var{search} @var{replace})
@paragraph{}

  Searches for the character listed in @var{search} in the passed @var{string}
replacing each ocurrence by the correponding value found in @var{replace}.
@paragraph{}

  (sstr "hello" "eo" "12")@*
  Returns "h1ll2".
@paragraph{}

@c --------------------------------------------------------------
@subsection substr

  (substr @var{string} @var{position} [@var{len}])
@paragraph{}

  Returns @var{len} characters of @var{string} starting at the indicated @var{position}.
If @var{len} is omitted all the characters in the string starting at @var{position} are
returned. The first character is at 0.
@paragraph{}

  (substr "hello" 1 3)@*
  Returns "ell".
@paragraph{}

  (substr "hello" 2)@*
  Returns "llo".
@paragraph{}

@c --------------------------------------------------------------
@subsection Operator - (substraction)

  (- @var{value1} @var{value2})
@paragraph{}

  Returns the result of substracting @var{value2} from @var{value1}. Both
variables must be integer.
@paragraph{}

  (- 20 3)@*
  Returns 17.
@paragraph{}

@c --------------------------------------------------------------
@subsection tostr

  (tostr @var{value})
@p{}

  Returns @var{value} converted into a string.
@p{}

  (tostr 2)@*
  Returns "2".
@paragraph{}

@c ************************************************************************************
@section Writing macros that use text filters

  The sLisp language provides the commands needed to take a selected text,
pass it to an external program, and collect their output. You can finally
replace the original text by the new text. This kind of programs are usually
called filters. Some applications of this are complex recoding using GNU
recode, text formating, code indentation using GNU indent, @il{etc.}
@p{}

  The following sections were contributed by Grzegorz Adam Hankiewicz and
explains how to use this feature.
@p{}

@c --------------------------------------------------------------
@subsection How to use Setedit for something it was not meant to

SET has always said that setedit is not a word processing
program. He's right, it's best at doing things like programming. But
once you get used to it the road to building another emacs is clear:
you start wanting to use it even to cook your breakfast. This
document, however, centers on how to control text format easily
under setedit, which is not that ambitious :)
@p{}

As you will notice, in some version SET added the "word wrap"
option. IMHO it should be removed, if you try to use it, it
will behave quite differently from what you expect (ie: if you
are writting tabbed lines, the editor will ignore them and puts
your cursor right away in the first column ignoring any possible
autoindentation options and tab uses you might have set for the
document). Also, it's setedit's choice of characters which will be
used to split the line. Bleah... it really sucks.
@p{}

But setedit is customizable. You can write macros in a lisp
like language. The language still doesn't allow you to control
tightly things like text formatting, but there's one cool option:
you can pipe a block selection to another external program and
the editor will substitute it with the output of this external
program. Certainly not the most optimized way of doing things, but
flexible enough to write a custom extension which treats your text.
@p{}

And here we go... the purpose will be to create a macro, which
feeds a text block to an external program which we will write. Simple
as that, all the power you wanted at your finger tips.
@p{}

@c --------------------------------------------------------------
@subsubsection Step 1. Building your macro.

Macros are written in sLisp, and stored somewhere in a @file{macros.slp}
file. This file can be a global read-only file or it can be located at
@file{~/.setedit/macros.slp}.  It's pure text, and somewhere (ie: at the
end of the file) you will insert the following chunk of code:
@p{}

@example
;*******************************************************************
;
; MACRO:   Block reformat
;
; DESCRIPTION: This script gets the current selection and feeds it to
; an external program. If no selection is present a message box will
; be printed.
;
;*******************************************************************/

(defmacro 'Block reformat'
 (eval
  (setv "input" (GetSelection))
  (if (length input)
   ; Call the filter
   (eval
    (setv "output"
     (RunProgramRedir
      ; filter line here
      "~/project/email-fmt.py/email-fmt.py "
      input
     )
    )
    (SendCommands cmcCut)
    (InsertText output 1)
   )
   ; Ask the user to select something first
   (MessageBox "Please select a text first")
  )
 )
)
@end example

Ok, don't worry about the syntax of the macro or how it's written,
if you are curious you can take a look at setedit's documentation
to find out what all that mess means. The important line is the
one which follows the comment @code{; filter line here}. That line
is actually the path to the external program we will be using,
which can be stored anywhere on your computer, it only needs to
have execution permission. I am the only user of my machine, so I
don't need to put things under /local/bin to feel comfortable :)
Please change that to point at your filter script.
@p{}

@c --------------------------------------------------------------
@subsubsection Step 2. The filter program.

The filter program has to be simple: receives text lines as input
and prints the result to stdout. You can say: @il{Hey, that calls some
weird Python script which I don't have... why don't
I call GNU's fmt command instead?}.  Good point. Do it. If you are
meaning to write simple texts that's ok. In fact, after the command
you can specify parameters to fmt like the width of the lines, and
there you go, you have a text formatting macro in Setedit. But if
you are meaning to answer emails (ie: setedit is your default
editor and mail programs like mutt call it to write messages) or
do something more sophisticated, you better use something like this
(big chunk of code follows):
@p{}

@example
#!/usr/bin/env python

import sys, popen2, tempfile, os

class LINE:
   pass

indentation = " \t>:;#"

def detect_indentation_characters(line):
   """Returns number of indentation chars minus trailing whitespace."""
   count = 0
   for f in line:
      if f in indentation: count = count + 1
      else: break

   return len(line[:count].rstrip()), count

def initial_scan(line):
   """Add attributes to the lines."""
   l = LINE()
   l.line = line
   l.total_length = len(line)
   l.ident, l.soft_ident = detect_indentation_characters(line)
   l.length = l.total_length - l.soft_ident
   return l

def same_indentation_lines(lines):
   """Returns number of lines with same indentation level."""
   f = 1
   while f < len(lines):
      if lines[f].ident != lines[0].ident:
         break
      else:
         f = f + 1

   return f

def reformat_lines(lines, temp_filename):
   """Dumps lines in list to file, the reads fmt's output."""
   assert lines
   ident = lines[0].ident
   length = max (70 - ident, 20)

   # create temporary file with content to ident
   file = open(temp_filename, "wt")
   num = 0
   while num < len(lines):
      string = lines[num].line[ident:]
      stripped = string.lstrip()
      if stripped:   file.write(stripped)
      else:          file.write(string)
      num += 1
   file.close()

   # call external tool and read it's stdout
   stdout, stdin = popen2.popen2 (["fmt", "-w", "%d" % length,
      "-u", temp_filename])
   stdin.close()
   if ident:   padding = "%s " % lines[0].line[:ident]
   else:       padding = ""
   new_lines = stdout.readlines()
   stdout.close()
   os.unlink(temp_filename)

   # output lines, taking care of last line's trailing '\n'
   for f in range(len(new_lines)-1):
      sys.stdout.write("%s%s" % (padding, new_lines[f]))
   if lines[num-1].line.find("\n") >= 0:
      sys.stdout.write("%s%s" % (padding, new_lines[-1:][0]))
   else:
      sys.stdout.write("%s%s" % (padding, new_lines[-1:][0][:-1]))

def main():
   lines = map(initial_scan, sys.stdin.readlines())
   temp_filename = tempfile.mktemp(".email-fmt.tmp")

   f = 0
   while f < len(lines):
      look = same_indentation_lines(lines[f:])
      reformat_lines(lines[f:f+look], temp_filename)
      f = f + look

if __name__ == "__main__":
   main()
# end of python code
@end example

Woah, that's more than the previous script. True, but this 86
line Python script is a cool wrapper: fmt doesn't
know exactly how you want to format your text. If you are replying
somebody's email, some text will have quotes. Wouldn't it be nice if
fmt could detect them? Yes, but it doesn't. Remember that the unix
style is doing one simple thing, but doing it extremely well.
@p{}

So we solve this with the Python script. It isn't really
long (try removing blank lines and comments), and it's pretty clear
(to any experienced functional programmer) what it does. It scans
the sent block of text for existant quote characters like those defined
in the indentation variable, which are used frequently by most email
programs. These lines will be kept together, and the script will
call fmt with them, but removing the quote characters and reducing
the line width. To the result, the script will add the apropiate
quote indentation level.
@p{}

This means that you can select say 20 lines of text which contain
three different quote indentation levels.  If these use the defined
indentation characters the script will split them, format them
separately and join them before returning them to setedit. The result
is obvious: a cool formatting feature which is cumbersome to build
into setedit, and which can be customized any way you want. You
can write your script in Python, ruby, perl, C, etc,
etc... you put the limit, not the program.
@p{}

@c --------------------------------------------------------------
@subsubsection Step 3. Binding your script to a keystroke.

Nice, we have the macro, we have the script, but how do we run
it? In a horrible world you would have to reproduce these steps to
format a text block:
@p{}

@itemize @bullet
@item Select text block
@item Open macro menu
@item Select @code{Select...}
@item Choose the macro
@end itemize

If you did it once, you can repeat the macro with @kbd{Shift+F3}, but
this is not nice, it prevents you from running other macros and
you aren't saved from the punishment of doing all that once each
time you run setedit, and since we want this for email replies,
the editor will be run independently for each answer. Ugh!
@p{}

Luckily you can bind a macro to a key (@x{Assigning a sLisp macro}).
The option is located under the menu option
called Tool&Ops, submenu Options, submenu Keyboard, submenu Key
assignment. Once you reach that, you can see all the key bindings for
the editor. Notice that none seem to use Alt for keystrokes, which
is nice because you can assume they are free for customizing. So you
just have to type a nice combo. I use @kbd{Alt+F} for "Formatting". Once
you have the combo you assign the macro "Block reformat" to it.
@p{}

Say ok to all menus and try it yourself: write a few lines with only
a word in each of them. Select those lines and press @kbd{Alt+F}. If
you did it right you will see all those words formatted in a
single paragraph. Now try that with email indentation. Think of all
the possibilities of using this trick along with the "rectangle
selection" feature of the editor.
@p{}

@c --------------------------------------------------------------
@subsubsection Examples.

I prepared some examples so you could see the good things of all
this work. All the examples are the result of selecting all lines
and using the macro. You can easily reproduce them yourself.
@p{}

Written in setedit:
@p{}

@example
 So I am just     a lazy boy typing this
 which I know will be
    formatted correctly with that cool
     python script                     written by a
       guy with funny name.
@end example

After the @kbd{Alt+F} combo:
@p{}

@example
So I am just a lazy boy typing this which I know will be formatted
correctly with that cool python script written by a guy with
funny name.
@end example

Written in setedit:
@p{}

@example
On  9 Jan 01 at 14:25, Grzegorz Adam Hankiewicz wrote:
> On Sun, 7 Jan 2001, Petr Vandrovec wrote:
> > (2) you can specify only xres 'x' yres '-' bpp '@@' fv, you cannot
> >     specify for example horizontal/vertical sync polarity, sync-on-green
> >     mode, or even shift picture left-right (modify
> >     left/right/upper/lower/hslen/vslen fields of var_screeninfo)
> > 
> > First problem is probably unresolvable without linking modedb to each
> > fbdev separately, as if you removing __init, others will come to you
> > with big staff.
> > 
> > Second problem is probably only 'invent how to write it' problem... You
> > can look at matroxfb picture size/refresh related parameters - all of
> > them should be parsed by modedb for benefit of all drivers...
> 
> Aha.. do you mean I have to add new options and switches to modedb, taking
> out the parsing code from the matroxfb module? For example, adding new
> modedb functions which have more parameters, to remain backwards
> compatible with the existant code?

In my opinion it should still take one char* and...
@end example

After the Alt+F combo:
@p{}

@example
On 9 Jan 01 at 14:25, Grzegorz Adam Hankiewicz wrote:
> On Sun, 7 Jan 2001, Petr Vandrovec wrote:
> > (2) you can specify only xres 'x' yres '-' bpp '@@' fv, you
> > cannot specify for example horizontal/vertical sync polarity,
> > sync-on-green mode, or even shift picture left-right (modify
> > left/right/upper/lower/hslen/vslen fields of var_screeninfo)
> >
> > First problem is probably unresolvable without linking modedb
> > to each fbdev separately, as if you removing __init, others will
> > come to you with big staff.
> >
> > Second problem is probably only 'invent how to write it'
> > problem... You can look at matroxfb picture size/refresh related
> > parameters - all of them should be parsed by modedb for benefit
> > of all drivers...
>
> Aha.. do you mean I have to add new options and switches to modedb,
> taking out the parsing code from the matroxfb module? For example,
> adding new modedb functions which have more parameters, to remain
> backwards compatible with the existant code?

In my opinion it should still take one char* and...
@end example

@c ************************************************************************************
@c ************************************************************************************
@chapter Calculator

  The calculator inside the editor was originally made by Laszlo Molnar.
Laszlo is a friend of mine from Hungary and is the author of the great DJP
progam (a djgpp exe compressor and now UPX, the best EXE compressor in all
the categories). Currently the editor is compiled with a new calculator with
some advanced features. This new calculator have the same features plus some
interesting additions and was developed by Burton Radons.
@paragraph{}
  The sources of the calculator are in the @file{parser.c} file. They are
free and you can use it for any purpose. There are three sources.
@paragraph{}
  Here is the documentation of the calculator written by Laszlo:
@paragraph{}

  The purpose of this program is to provide a simple but powerful
'calculator' for programmers, to help with coding and debugging, where GDB's
expression evaluator is not enough.
@paragraph{}

  You may say "Hey, I can write a better one with @il{flex} and @il{bison}", and you
may be right. I can make a better one too. But it'll be 4-5 times longer!
This calculator is only 10 kbytes of C code. What I think? It's not that bad.
@paragraph{}

  The parser algorithm I use is called 'Operator Precedence Parsing'
(I translated this from Hungarian, so I may be wrong ;-). It
works with 'operator precedence grammars' (a subset of LR(1) grammars),
which means that there can't be two non-terminating tokens next to each other
on the right side of your grammar rules. It's ideal for expression
evaluation.
@paragraph{}

  With this parser you can use numbers, operators, parentheses and functions
like in C.
@paragraph{}

Here are the operators in decreasing precedence:
@paragraph{}

@enumerate
@item
@code{~} unary not
@code{-} unary minus
@item
@code{**} power
@item
@code{*} multiplication
@code{/} division
@code{%} modulo
@item
@code{+} plus
@code{-} binary minus
@item
@code{@lt{}@lt{}} shift left
@code{@gt{}@gt{}} shift right
@item
@code{@lt{}} less than *
@code{@lt{}=} less or equal than *
@code{@gt{}} greater than *
@code{@gt{}=} greater or equal than *
@item
@code{==} equal to *
@code{!=} different than *
@item
@code{&} bitwise and
@item
@code{^} bitwise xor
@item
@code{|} bitwise or
@item
@code{&&} logical and *
@item
@code{||} logical or *
@item
@code{?:} conditional *
@end enumerate
@paragraph{}

  The operators marked with asterisk are available only in Burton's version.
@paragraph{}

  The calculator includes the following functions:
@il{sin\, cos\, tan\, sinh\, cosh\, tanh\, asin\, acos\, atan\, log\, log10\, exp\, abs\,
sqrt\, ceil} and @il{floor}.  They work as you expect.  Additionally the
calculator provides some radix conversion routines: @il{bin\, oct\, dec} and @il{hex}.
@paragraph{}

  The calculator uses doubles, but you can use numbers in the usual integer
formats also: 0x@dots{} for base 16, 0b@dots{} for base 2 and 0@dots{} for
base 8.  The result of the calculation is displayed as a double for base 10,
and converted to long long format for the other radixes.
@paragraph{}

  In addition the new calculator has the following features:
@paragraph{}

  You can define variables just by assigning a value to them. So if you enter
@il{x=5} you can use @il{x} in other calculation like this @il{x**2}. You can
also use the C/C++ assign plus operation. Post and pre increment and
decrement are also available.
@paragraph{}

  You can define functions like this @il{f(x)=x**2+2} so then entering
@il{f(5)} will give as result @il{27}.
@paragraph{}

  The C/C++ conditionals are available, so the following:
@il{f(5)>=27 ? 6 : 2} will give @il{6} assuming you defined @il{f(x)} as in the
above example.
@paragraph{}

  You can separate operations with commas as in C. The result of the last
operation is the result of the compound.
@paragraph{}

@chapter How to contact me
@cindex How to contact me

  If you have any suggestions or a bug report contact me at the address shown
in the author section. @x{About the Author}.
@paragraph{}

@section Bugs
@cindex Bugs

  If you find a bug please contact me, the Undo thing is the most complex
one and I know that needs some work on it.
@paragraph{}

  When reporting a bug please don't tell me: Some times some strange thing
happens @dots{} Try to find a pattern to the problem. What situation triggers
the problem? @dots{} with which file(s)? Then send me the file and the description.
@paragraph{}

  When sending me a file UUEncode it to avoid problems related with e-mail.
@paragraph{}

@chapter TAGS files

This chapter describes some details about @file{TAGS} files. They are
referreded as tags in the rest of the sections.
@p{}

I wrote a small ilustrated tutorial showing how to quickly use this. The
tutorial is available in the editor home page:
http://setedit.sf.net/tags.html. It is also included in some of the
distributions of the editor.
@p{}

I strongly recommend reading the documentation of the program to generate the
tag files.
@p{}

@section What are tags?
@cindex tags, what are?

TAGS files are plain text files containing a list of symbols from your source
code. For each symbol the file indicates in which file it's located and how to
find the symbol inside the file. Modern programs also include very important
information like which type of symbol is defined and if this symbol is part of
a bigger construct like a class.
@p{}

This information is very useful to do searches. The editor implements
facilities to jump to any defined symbol, browse classes and do word
completion using information from tag files.
@p{}

@section Which program is used to generate TAGS files?
@cindex tags, program to generate

A lot of programs generate tag files but the editor uses special features
only found in the @il{Exuberant Ctags} program. For this reason I recommend
using this program to generate the tag files. You can find this program at
Source Forge (http://ctags.sourceforge.net).
@p{}

@section How should I generate the tags?
@cindex tags, how to generate

It depends on your project and how you compile the project. It also
depends on how fast your system is. I currently use a tags file for the
editor and another for the Turbo Vision library. The best is to refresh the
tags file using the same makefile you use to compile your project. If your
system isn't very fast or your project is too big you could try using one
tags file for each directory in your project. The editor can be configured to
collect symbols from various tag files.
@p{}

The command line options I recommend to use with @file{ctags} are:
@p{}

@itemize @bullet
   @item -R recursive, to search in all subdirectories.
   @item --fields=+i+l+m+z Inheritance information, language of source file
that contains the tag, implementation information and type of tag.
@end itemize

Without the @code{+i} and @code{+z} option you won't be able to use the class
browser.
@p{}

@section Can these files be created and updated by the editor?
@cindex tags, how to maintain

I recommend using makefiles to maintain tag files because you have all
the control over when and how they are updated. But if you are using a fast
machine and want to simplify the process you can let the editor create and
maintain a tags file for your project. You'll find options for it in the
Tool&Ops | Options | Tag files menu option. @x{Tag files options}.

@section What is the easiest way to use tags?
@cindex tags, easy way

Here is an explanation about how to quickly use tag files:
@p{}

@enumerate
@item Install @il{Exuberant Ctags} (http://ctags.sourceforge.net).
@item Create a project (Project | Open). @x{Open (Project)}.
@item Add all the files you want to include to the project. You can import
the list of files from a text file. @x{Import project items}.
@item Enable automatic tag generation using a central file (Tool&Ops |
Options | Tag files | Options). @x{Tag files options}.
@item Perform a search, the tags file will be generated during this process
so be patient if your system is slow or your project is huge.
@end enumerate

@section What can I do with tags?

With the tag files you can:
@p{}

@enumerate
@item Jump to any defined symbol. @x{Jump to symbol}.
@item Browse C++ class hierarchy. @x{Class browser}.
@item Ask the editor to complete a partially typed symbol. @x{Word completion}.
@end enumerate

@section Technical details about tags

The editor loads the tags to memory to allow fast searches. For this reason
you must be aware that they consume lots of memory. In some tests I did using
GNU/Linux I found the amount needed to load a tags file is close to the size
of the file on disk. For this reason I recommend to avoid generating symbols
for files you don't need.
@p{}

The time to parse and load tag files can be annoying on slow systems. For
this reason the editor never loads the tag files until they are really
needed. That's why you'll notice a delay for the first search, because the
files are loaded at this time and not when the editor is started.
@p{}

Tag files don't catch all definitions, they aren't perfect, so please read
the man pages. They also lack some important information, like what type
a variable (int, float, @il{etc.}) is.
@p{}

@chapter Miscellaneous

@section Clipboard

The clipboard is just another editor window, which holds the text you used the
@code{Cut} and @code{Copy} commands on, and retrieve it with the @code{Paste}
command.
@paragraph{}

Unlike the windows clipboard the one provided with the editor doesn't lose
the old contents when you copy to it. This approach has the important
advantage that you can copy text from various parts to the clipboard and then
paste all the text in one place with just one operation. To do it select
the clipboard window, select the text to paste and the editor pastes the
text selected in the clipboard window.
@paragraph{}

The disadvantage is that all the text copied to the clipboard remains there
and if you are running on a machine with low memory and handling huge files
you can fill all the memory quickly. To avoid this check the clipboard size (with
@kbd{Alt+0}) and exit the program if it gets too big. That normally isn't needed
on machines with enough free disk space that can be used as swap.
@paragraph{}

@section Time and date modifiers formats

This values are the same used by the @code{strftime} function of the standard
@file{libc}. The editor uses it in the printing module. @x{Print Setup}.
@paragraph{}

@table2{Value,Meaning}
@titemR{@code{%A},The full weekday name (@code{Friday})}
@titemR{@code{%a},The abbreviated weekday name (@code{Fri})}
@titemR{@code{%B},The full month name (@code{October})}
@titemR{@code{%b\, %h},The abbreviated month name (@code{Oct})}
@titemR{@code{%C},Short for @code{%a %b %e %H:%M:%S %Y}
(@code{Fri Oct  1 15:30:34 1993})}
@titemR{@code{%c},Short for @code{%m/%d/%y %H:%M:%S} (@code{10/01/93
15:30:34})}
@titemR{@code{%e},The day of the month, blank padded to two characters
(@code{ 2})}
@titemR{@code{%D},Short for @code{%m/%d/%y} (@code{10/01/93})}
@titemR{@code{%d},The day of the month, zero padded to two characters
(@code{02})}
@titemR{@code{%H},The hour (0-24), zero padded to two characters (@code{15})}
@titemR{@code{%I},The hour (1-12), zero padded to two characters (@code{03})}
@titemR{@code{%j},The Julian day, zero padded to three characters
(@code{275})}
@titemR{@code{%k},The hour (0-24), space padded to two characters
(@code{15})}
@titemR{@code{%l},The hour (1-12), space padded to two characters(@code{ 3})}
@titemR{@code{%M},The minutes, zero padded to two characters (@code{30})}
@titemR{@code{%m},The month (1-12), zero padded to two characters
(@code{10})}
@titemR{@code{%n},A newline (@code{\n})}
@titemR{@code{%p},AM or PM (@code{PM})}
@titemR{@code{%R},Short for @code{%H:%M} (@code{15:30})}
@titemR{@code{%r},Short for @code{%I:%M:%S %p} (@code{03:30:35 PM})}
@titemR{@code{%S},The seconds, zero padded to two characters (@code{35})}
@titemR{@code{%T\, %X},Short for @code{%H:%M:%S} (@code{15:30:35})}
@titemR{@code{%t},A tab (@code{\t})}
@titemR{@code{%U},The week of the year, with the first week defined by the
first Sunday of the year, zero padded to two characters (@code{39})}
@titemR{@code{%W},The week of the year, with the first week defined by the
first Monday of the year, zero padded to two characters (@code{39})}
@titemR{@code{%w},The day of the week (0-6) (@code{5})}
@titemR{@code{%x},Short for @code{%m/%d/%y} (@code{10/01/93})}
@titemR{@code{%y},The year (00-99) of the century (@code{93})}
@titemR{@code{%Y},The year, zero padded to four digits (@code{1993})}
@titemR{@code{%Z},The timezone abbreviation (@code{EDT})}
@titemR{@code{%%},A percent symbol (@code{%})}
@endtable-{}

@section Regular Expressions

The editor supports regular expressions in the search and replace commands,
here is a description of the syntax.
@paragraph{}

Regular expressions (@dfn{RE}s), as defined in POSIX 1003.2, come in two
forms: modern REs (roughly those of @code{egrep}; 1003.2 calls these
@emph{extended} REs) and obsolete REs (roughly those of @code{ed};
1003.2 @emph{basic} REs).  Obsolete REs mostly exist for backward
compatibility in some old programs; they will be discussed at the end.
1003.2 leaves some aspects of RE syntax and semantics open; `(*)' marks
decisions on these aspects that may not be fully portable to other
1003.2 implementations.
@paragraph{}

A (modern) RE is one(*) or more non-empty(*) @emph{branches}, separated
by @samp{|}.  It matches anything that matches one of the branches.
@paragraph{}

A branch is one(*) or more @emph{pieces}, concatenated.  It will try to find
a match for the first, then for the second, etc.
@paragraph{}

A piece is an @emph{atom} possibly followed by a single(*) `*', `+',
`?', or @emph{bound}.
An atom followed by `*' matches a sequence of 0 or more occurences of the atom.
An atom followed by `+' matches a sequence of 1 or more occurences of the atom.
An atom followed by `?' matches a sequence of 0 or 1 occurences of the atom.
@paragraph{}

A @emph{bound} is a `@{' followed by an unsigned decimal integer, possibly
followed by `,' possibly followed by another unsigned decimal integer,
always followed by `@}'.  The integers must lie between 0 and
@code{RE_DUP_MAX} (255(*)) inclusive, and if there are two of them, the
first may not exceed the second.  An atom followed by a bound containing
one integer @samp{i} and no comma matches a sequence of exactly @samp{i}
occurences of the atom.  An atom followed by a bound containing one integer
@samp{i} and a comma matches a sequence of @samp{i} or more occurences of
the atom.  An atom followed by a bound containing two integers @samp{i}
and @samp{j} matches a sequence of @samp{i} through @samp{j} (inclusive)
occurences of the atom.
@paragraph{}

An atom is a regular expression enclosed in `()' (one occurence for the
regular expression), an empty set of `()' (matches the null string(*)),
a @emph{bracket expression} (see below), `.' (matching any single
character), `^' (matching the null string at the beginning of a line),
`$' (matching the null string at the end of a line), a `\\' followed by
one of the characters `^.[$()|*+?@{\\' (matches that character taken as
an ordinary character), a `\\' followed by any other character(*)
(matches that character taken as an ordinary character, as if the `\\'
had not been present(*)), or a single character with no other
significance (matching that character).  A `@{' followed by a character
other than a digit is an ordinary character, not the beginning of a
bound(*).  It is illegal to end an RE with `\\'.
@paragraph{}

A @emph{bracket expression} is a list of characters enclosed in `[]'.
It normally matches any single character from the list (but see below).
If the list begins with `^', it matches any single character (but see
below) @emph{not} from the rest of the list.  If two characters in the
list are separated by `-', this is shorthand for the full @emph{range}
of characters between those two (inclusive) in the used character set,
e.g. `[0-9]' matches any decimal digit in ASCII.  It is illegal(*) for
two ranges to share an endpoint, e.g. `a-c-e'.  Ranges are very
character set-dependent, and portable programs should avoid relying
on them.
@paragraph{}

To include a literal `]' in the list, make it the first character
(following a possible `^').  To include a literal `-', make it the
first or last character, or the second endpoint of a range.  To use a
literal `-' as the first endpoint of a range, enclose it in `[.' and
`.]' to make it a collating element (see below).  With the exception of
these and some combinations using `[' (see next paragraphs), all other
special characters, including `\\', lose their special significance
within a bracket expression.
@paragraph{}

Within a bracket expression, a collating element (a character, a
multi-character sequence that collates as if it were a single character,
or a collating-sequence name for either) enclosed in `[.' and `.]'
stands for the sequence of characters of that collating element.  The
sequence is a single element of the bracket expression's list.  A
bracket expression containing a multi-character collating element can
thus match more than one character, e.g. if the collating sequence
includes a `ch' collating element, then the RE @samp{[[.ch.]]*c} matches
the first five characters of ``chchcc''.
@paragraph{}

Within a bracket expression, a collating element enclosed in `[=' and
`=]' is an equivalence class, standing for the sequences of characters
of all collating elements equivalent to that one, including itself.
(If there are no other equivalent collating elements, the treatment is
as if the enclosing delimiters were `[.' and `.]'.)  For example, if o
and \o'o^' are the members of an equivalence class, then `[[=o=]]',
`[[=\o'o^'=]]', and `[o\o'o^']' are all synonymous.  An equivalence
class may not be an endpoint of a range.
@paragraph{}

Within a bracket expression, the name of a @emph{character class}
enclosed in `[:' and `:]' stands for the list of all characters
belonging to that class.
Standard character class names are:
@paragraph{}

@example
alnum	digit	punct
alpha	graph	space
blank	lower	upper
cntrl	print	xdigit
@end example

These stand for the character classes defined by @code{isalnum},
@code{isdigit}, @code{ispunct}, @code{isalpha}, @code{isgraph}
, @code{isspace} (@code{blank} is the same as @code{space}),
@code{islower}, @code{isupper}, @code{iscntrl}, @code{isprint},
and @code{isxdigit}, respectively.  A locale may provide others.
A character class may not be used as an endpoint of a range.
@paragraph{}

There are two special cases(*) of bracket expressions: the bracket
expressions `[[:<:]]' and `[[:>:]]' match the null string at the
beginning and end of a word respectively.  A word is defined as a
sequence of word characters which is neither preceded nor followed by
word characters.  A word character is an @code{alnum} character (as
defined by the @code{isalnum} library function) or an underscore.  This is
an extension, compatible with but not specified by POSIX 1003.2, and
should be used with caution in software intended to be portable to other
systems.
@paragraph{}

In the event that an RE would match more than one substring of a given
string, the RE matches the one starting earliest in the string.  If the
RE could match more than one substring starting at that point, it
matches the longest.  Subexpressions also match the longest possible
substrings, subject to the constraint that the whole match be as long as
possible, with subexpressions starting earlier in the RE taking priority
over ones starting later.  Note that higher-level subexpressions thus
take priority over their lower-level component subexpressions.
@paragraph{}

Match lengths are measured in characters, not collating elements.  A
null string is considered longer than no match at all.  For example,
@samp{bb*} matches the three middle characters of @samp{abbbc}, 
@samp{(wee|week)(knights|nights)} matches all ten characters of
@samp{weeknights}, when @samp{(.*).*} is matched against @samp{abc} the
parenthesized subexpression matches all three characters, and when
@samp{(a*)*} is matched against `bc' both the whole RE and the
parenthesized subexpression match the null string.
@paragraph{}

If case-independent matching is specified, the effect is much as if all
case distinctions had vanished from the alphabet.  When a letter
that exists in multiple cases appears as an ordinary character outside a
bracket expression, it is effectively transformed into a bracket
expression containing both cases, e.g. `x' becomes `[xX]'.  When it
appears inside a bracket expression, all case counterparts of it are
added to the bracket expression, so that (e.g.) `[x]' becomes `[xX]' and
`[^x]' becomes `[^xX]'.
@paragraph{}

No particular limit is imposed on the length of REs(*).  Programs
intended to be portable should not employ REs longer than 256 bytes,
as an implementation can refuse to accept such REs and remain
POSIX-compliant.
@paragraph{}

Obsolete (@emph{basic}) regular expressions differ in several respects.
`|', `+', and `?' are ordinary characters and there is no equivalent
for their functionality.  The delimiters for bounds are `\\@{' and
`\\@}', with `@{' and `@}' themselves being ordinary characters.  The
parentheses for nested subexpressions are `\(' and `\)', with `(' and
`)' themselves being ordinary characters.  `^' is an ordinary character
except at the beginning of the RE or(*) the beginning of a parenthesized
subexpression, `$' is an ordinary character except at the end of the RE
or(*) the end of a parenthesized subexpression, and `*' is an ordinary
character if it appears at the beginning of the RE or the beginning of a
parenthesized subexpression (after a possible leading `^').
Finally, there is one new type of atom, a @emph{back reference}:
`\\' followed by a non-zero decimal digit @emph{d} matches the same
sequence of characters matched by the @emph{d}th parenthesized
subexpression (numbering subexpressions by the positions of their
opening parentheses, left to right), so that (e.g.) @samp{\\([bc]\\)\\1}
matches `bb' or `cc' but not `bc'.
@paragraph{}

@section Desktop Files

Each time you run the editor it searches for a desktop file in the current
directory, if the editor can't find any desktop file it searches in the
directory indicated by the enviroment variable @code{SET_FILES}. If no
desktop files are found the editor uses internal default values. By
creating a desktop file in the @code{%SET_FILES%} directory you'll
indicate default values. To create a desktop file in this directory just
run the editor in the directory, customize it and leave the editor. This
feature is very useful to customize things like: Colors, Palette, Global
editor options, @il{etc.}
@paragraph{}

When you exit from the editor it saves all the settings, windows positions,
@il{etc.@:} to a desktop file stored in the current directory. Some people
don't like this and therefore a special mode in which the editor
stores just one desktop file in the @code{%SET_FILES%} directory and not
in each directory exists. This approach has the advantage of saving disk
space, but you won't have local settings. If you use this approarch and want
to keep a local configuration in a directory use a project. @x{Project}. To
store only one centralized desktop file: @x{Editor General}.
@paragraph{}

The desktop files have @file{.dst} as extension.
@paragraph{}

@section Text mode attributes

Text modes uses up to 16 colors for forground and 16 colors for background,
that's because the attributes of each character are stored in a 1 byte
allowing just 256 combinations. So four bits are dedicated to the background
color giving 16 combinations and the other four bits for the foreground.
@paragraph{}

As we have only 16 colors there is a big chance that our preferred colors
aren't included. For this reason the VGA chip uses a palette of colors. That
means that these 16 colors aren't fixed and you can indicate what colors to
use. The values are just index values and you can assign to it any color.
@paragraph{}

The VGA chip supports 18(6:6:6) bits per color giving 262,144 combinations. The
colors are created using the RGB (Red Green and Blue) method. That's simply
because the CRT (Cathode Rays Tube) of the monitor uses this method to
create the colors. You have 6 bits per component giving 64 different levels.
@paragraph{}

There is a little more of complexity added to the VGA card. The most
significant bit of the background is used to create blinking text. The editor
avoids this mode because it restricts the background combinations to 8 and
the editor doesn't need blinking text. The other funny thing of the attribute
is the most significant bit of the foreground color. It has a special
meaning but even when using it, it doesn't reduce the number of combinations.
That means that this bit can select two things at the same time. By now you'll be
asking: What? This bit can be used to select a second font, in this way you
can have upto 512 different characters on the screen. The editor can exploit
it but you must understand that this bit is used for the foreground color
too. You can customize the palette to reduce the number of foreground
combinations to 8 and defining the 9th color with the same value as the
0th color and so on. Then you can assign different colors and different fonts
to the things in the editor. You can for example use a font for the menues
and other for the text, or a font for the code and other for the comments.
The editor goes even further allowing different code page encodings for each
font. I really never saw it in any editor. You can use it for example to
write your code using a font with the ISO Latin 1 encoding (used by Linux
and Windows in the USA and part of Europe) and have your comments in russian
(using cyrillic characters).
@paragraph{}

To learn how to customize the palette: @x{Color Palette}.@*
To learn how to assign colors to the things used in the editor: @x{Customize Colors}.@*
To learn how to select a font and an encoding: @x{Screen Options}.@*

@section File Open

This dialog is used to select a file in various places. Even when it has
different names and purposes the dialog is always the same.
@paragraph{}

The dialog is similar to the one used by most of the T/GUI programs so I'll
focus on special details and particularities.
@paragraph{}

All the files and directories are shown together, the directories have a
slash at the end. The current directory and selected file information is
shown at the bottom of the dialog.
@paragraph{}

To select a different disk, at least in DOS, you can simply type the drive
letter followed by a colon in the text input area and press @key{Enter}. You
can specify a mask in the text area too. Even though under DOS a single asterisk
matches any filename, the *.* mask won't match with a filename that lacks
extension. You can use some asterisks and question marks in the mask, they
work like in most of the shells (DOS command.com included). Additionally the
mask can contain brackets, if your shell doesn't use it and you never used
it here is an example: @code{*.[ch]*} will match with test.c, test.h,
test.cc, test.cpp, @il{etc.@:} the brackets indicates the possible characters
that will match, in this case the first character after the point should be c
or h.@*
Pressing the down arrow while you are in the text input area you'll get a
list of the paths in which you selected files in the past. That's very useful
when you load files from two or more very different directories.
@paragraph{}

The @code{Home} changes the directory to the one from where you started the
editor, that's very useful when you navigate a lot and you want to quickly
return to the directory from where you started.
@paragraph{}

The @code{Options} button brings a dialog to configure the sorting options
and which files to exclude. These options are described in the following
subsections.
@p{}

The editor remembers the last place where you selected a file the last time
you used it. This information is stored in the desktop file. This information
is unique for the following selections: open a file to edit, save a file,
open a help file, save a block of text, open/save a project, open an MP3 file
and save an MP3 file. In this way you can be opening files from a directory
and saving newly created files to another at the same time without
indicating the directory each time you open/save a file.
@paragraph{}

@subsection Sorting of the files and directories in the dialog
@cindex backups, listing at the end

By default the sorting criteria is the following:
@paragraph{}

@itemize @bullet
   @item Names sorting is case insensitive.
   @item Directories are listed after files.
   @item The parent directory (@code{..}) is the last entry.
   @item Files starting with a dot are alphabetically listed.
@end itemize

But this can be customized with the @il{File open dialog} menu option or the
@code{Options} button of the dialog. It brings a dialog with the following
options:
@paragraph{}

@itemize @bullet
 @item Sort type: controls how the names are sorted.
 @itemize @bullet
  @item Alphabetical: both, directories and file names, are mixed.
  @item Directories first: the directories are listed first.
  @item Files first: file names are listed first.
@end itemize
 @item Case style: controls if the dialog differentiates between capital and
lower case ones.
 @itemize @bullet
  @item Capital letters goes first: the names are sorted according to the
ASCII table
  @item Case insensitive: the names are sorted lexicographically.
@end itemize
 @item Parent directory: this option controls the location of the parent
directory link (@code{..}). It doesn't affect the @il{Alphabetical} sorting.
 @itemize @bullet
  @item First in the list: the parent is the first entry in the list.
  @item At the end of the list: the parent is the last entry in the list.
@end itemize
 @item Files starting with a dot: it controls how names starting with a dot
are handled.
 @itemize @bullet
  @item Normally sorted: they will be sorted alphabetically. As the
@code{ASCII} code of a dot is less than the code of any letter they will be
first in the list. That's quite annoying when you use UNIX style backups and
they are also hidden files.
  @item After the rest: they will be put at the end of the list.
@end itemize
@end itemize

The other options you'll find in this configuration dialog are described in
another subsection. @x{Files and directories excluded in the dialog}.
@p{}

Something very important that you must know is how the @key{Shift} key is
interpreted.
@paragraph{}

When the sorting is @il{Alphabetical} and the list is case
sensitive (@il{Capital letters are first}) the shift key affects the case of
the typed letters so you must be careful; check the state of @key{Caps Lock}
now and then as well.
@paragraph{}

When the sorting isn't @il{Alphabetical} the @key{Shift} has a special
meaning. If you press shift while typing the first letter of the name then
the search will be done in the list of directories instead of the list of
file names. Once you are in one of the lists the rest of the search is done
in this list. If the list is case sensitive it creates an interesting
conflict because you could need to press shift for some file name and then
the search will be done in the directories list. Don't forget this.
@paragraph{}

@subsection Files and directories excluded in the dialog
@cindex backups, not listing

By default all names found are listed but this can be customized with the
@il{File open dialog} menu option or the @code{Options} button of the
dialog. The related options are:
@paragraph{}

@itemize @bullet
@item Exclude files: controls which names are excluded.
 @itemize @bullet
  @item Ending with tilde: names ending with a tilde are excluded. They
usually belong to UNIX-style backups. The editor generates these files when you
configure it to generate UNIX style backups.
  @item Ending with .bkp: names with the bkp extension are excluded. By
default the editor generates backup files with this extension.
  @item Starting with dot: names starting with a dot are excluded. In UNIX
they are hidden files. The editor can be configured to create backup files as
hidden files.
@end itemize
@end itemize

Personally I only exclude files with the bkp extension and sort files
starting with a dot so they appear at the end of the list.
@p{}

@section Message Window
@cindex message window
@cindex windows, message

This window is used to show important information that you may want to have
at hand. Some examples are: the results of a printing operation, the errors
collected from an external program, the hits of the powered grep, the tip of
the day, the output of an external program, etc.
@paragraph{}

The message window doesn't have a number but can be accessed from the list of
windows (default @kbd{Alt+0}).
@paragraph{}

If the messages are errors or hits from grep you can use @kbd{Alt+F7} and
@kbd{Alt+F8} to quickly jump to the next/previous line. You can also just
select any of the error/hits. The errors are parsed by the editor according
to the user selection. Many formats are supported by the editor and the
mechanism is configurable. See the next section for more information.
@paragraph{}

When the last or first error in the list is reached the editor indicates it.
This behavior can be configured. @x{Editor General}.
@p{}

You can also delete entries in the message window pressing @key{Delete}. To
add more flexibility the content of the message window can be stored in a
file or copied to the clipboard, to do this just use the menu.
@paragraph{}

For more information about the behavior of the message window when you run
external programs @x{Run program (which one)}.
@p{}

@section Error messages from an external application
@cindex parse, errors
@cindex errors from external program

Originally the editor only supported the GNU style. After many users
asked for support of other error formats Grzegorz Adam Hankiewicz suggested
doing it in a configurable way. So starting with v0.4.41 the editor can be
configured to parse the errors from an external application.
@paragraph{}

The configuration is stored in a file called @file{errors.cel}. The syntax is
very similar to the one used in the @file{syntaxhl.shl} file. All definitions
start with a @code{Name} declaration that indicates the name of the parsing
options and ends with an @code{End} marker.
@paragraph{}

The @code{Pattern} entry tells the editor how to parse a line containing an
error from the external program. The pattern is actually a Perl regular
expression. I used it because they are much more easy to learn than POSIX
regular expressions and they are a lot more logical to me.
@paragraph{}

The @code{File}, @code{Line}, @code{Severity} and @code{Description} entries
indicate - with subexpressions - the file name, line number, degree
of severity and description of the error. Note that actually only the first
two are used. If you don't know what a subexpression is here is a hint: look
at the parentheses.
@paragraph{}

The @code{EnterDirPat} is another Perl regex to indicate how make informs
about a directory change. @code{EnterDirDir} is the related subexpression.
That's needed for GNU make, I guess other make tools have a similar
mechanism. @code{LeaveDir} is the pattern generated by make to indicate a
change to the parent directory.
@paragraph{}

@section Mouse under Linux

When you are running in a console the mouse is captured by the editor and you
can't use it to copy/paste between consoles. If you want to do it you must
hold down the right @key{Alt} key and use the mouse as usually. Note this can
be altered if you changed the alt keys configuration.
@x{Alt key configuration}. Additionally note that when you paste the keys
are interpreted as @key{Alt} plus the key you pressed so the carriage returns
aren't interpreted very well.
@paragraph{}

If you are using an X terminal the mouse isn't interactive because X
terminals only report when the button is pressed and released but not when
it's moved. You can do all the normal operations but you won't get the usual
feedback.
@paragraph{}

@section Passing extra command line options

You can pass extra command line options defining an environment variable.
It's called @var{SET_CMDLINE}. The editor will parse this variable and add it to
the options passed in the command line. These options will be interpreted
before the options passed in the command line.
@paragraph{}

Any space (including tabs) are interpreted as separators. If you need to pass
a file name containing spaces you must enclose the name with double quotes.
If you need to pass a name containing a double quote you must escape it using
a back slash. Here are some examples:
@paragraph{}

@table2{You type,The editor interpretes}
@titemR{ops 1,two options "ops" and "1"}
@titemR{"ops 1",one option "ops 1"}
@titemR{ops\"1,one option containing a double quote inside}
@endtable-{}

This mechanism can be used to set default options and avoid typing them all
the time. Another use is when you need to pass options to the editor and you
are using Eterm; which can't pass command line options, so you
must use this mechanism.

@section UNIX: How to run setedit remotely without root installation

This text was contributed by Grzegorz Adam Hankiewicz:
@p{}

I'm a lucky guy and I've been hired by eFaber (http://www.efaber.net)
to do some open source hacking. The first day I started I was given
a computer and received strong orders: @il{Install Suse Linux 8.1 and
customize your environment}. Obviously I chose to install setedit,
and it worked great. However, from time to time I have to go to
another workstation or login remotely. We export @file{/home} through
NFS, so apparently we have the same configuration everywhere. But
setedit doesn't work that way.
@p{}

First of all, setedit depends on the TVision library, and only my PC
has it installed. setedit also needs a global directory where shared
files reside, usually @file{/usr/share/setedit}, or something else
pointed by @code{SET_FILES}.  One solution would be to install setedit
everywhere, but this is not scalable, and it's error prone. If I
wanted to upgrade setedit or TVision I would spend much time copying
and installing on every machine. Besides, even if my coworkers let me
use root, or told me the password, I would never be given access
to the main server, and it's the only one with email I/O. What's
the solution?
@p{}

The solution is to put the files needed by setedit on the exported
directory, in other words, @code{$HOME}. After you compile setedit, put
the binary in @file{~/bin}. Find where your TVision is (librhtv*) and copy
the library to @file{~/lib}. If you run @code{ldd} on @file{~/bin/setedit} you will see
that the librhtv dependency is resolved to your local file system. If
you logged now to another computer, the library wouldn't be found.
@p{}

To avoid this, add something similar to this to your .bashrc:
@p{}

@example
   export PATH=$PATH:~/bin
   export LD_LIBRARY_PATH=~/lib
@end example

After you log in again, try to use ldd on the binary, and now you
should see the linker resolve it to your @file{~/lib} everywhere.
First step complete.  The second step is to move the shared files.
I created the directory in @file{~/bin/setedit_shared_files}, and
made @file{/usr/share/setedit} on my local machine a symlink to it,
so newer installs of setedit overwrite the correct shared files.
Now make @code{SET_FILES} point to it:
@p{}

@example
   export SET_FILES=~/bin/setedit_shared_files
@end example

Nice. Now, if you run setedit it will be able to load,
but you will still find two annoying facts: setedit always
looks for the @file{setedit.info} file (which is usually found in
@file{/usr/info/setedit.info.gz}), and the language translations won't
be found because GNU's gettext doesn't know anything about our
exportation trick.
@p{}

To solve the info file warning, copy setedit.info.gz to
@file{~/bin/setedit_shared_files} and add that directory to the appropriate
environment variable:
@p{}

@example
   export INFOPATH=$INFOPATH:$SET_FILES
@end example

Finally, to correct the gettext problem, first make @code{SET_LOCELEDIR}
point to @code{SET_FILES}:
@p{}

@example
   export SET_LOCALEDIR=$SET_FILES
@end example

And now, in the @code{SET_FILES} directory create the @file{xxxx/LC_MESSAGES/}
directory structure, where `xxxx' is a two letter code representing a language.
I would then create @file{~/bin/setedit_shared_files/es/LC_MESSAGES}, and put
inside the file @file{setedit.mo} I found typing @code{locate setedit.mo} on
my workstation.  After copying the file there, GNU's gettext will
find the translation file always, from any directory, and you will
be able to hack from every computer as if you were at home.
@p{}

Again, what you have to add to your @file{.bashrc} file is:
@p{}

@example
   export PATH=$PATH:~/bin
   export LD_LIBRARY_PATH=~/lib
   export SET_FILES=~/bin/setedit_shared_files
   export INFOPATH=$INFOPATH:$SET_FILES
   export SET_LOCALEDIR=$SET_FILES
@end example

Happy hacking!

@chapter Index

@conindex{cindex.idx,cindex.tdx}

@chapter Index of key commands

@keyindex{kindex.idx,kindex.tdx}

@EOFTOC

@bye

