This is editor.inf, produced by makeinfo version 4.13 from editor.nut.

START-INFO-DIR-ENTRY
* SET's Editor: (setedit). A friendly text editor.
END-INFO-DIR-ENTRY

This is the documentation for SET's Editor.

Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
2006, 2007 Salvador Eduardo Tropea

This documentation may be freely distributed, provided this copyright
notice is left intact on all copies.


File: editor.inf,  Node: Top,  Prev: (dir),  Up: (dir)

 EDITOR
*******

This is the documentation for SET's Editor.

Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
2006, 2007 Salvador Eduardo Tropea

This documentation may be freely distributed, provided this copyright
notice is left intact on all copies.

The following master menu lists the major topics in this documentation,
including all the indices.

Pressing F1 when selecting any item of the menu you'll get help about it.

* Menu:

* Introduction::
* Documentation guide::
* Available commands and keys assignments::
* Keyboard configuration::
* Pull-down menues::
* Menues configuration::
* Editing Modes::
* Syntax Highlighting File::
* Pseudo Macros::
* sLisp macros::
* Calculator::
* How to contact me::
* TAGS files::
* Debugging::
* Miscellaneous::
* Index::
* Index of key commands::


File: editor.inf,  Node: Introduction,  Next: Documentation guide,  Prev: Top,  Up: Top

1 Introduction
**************

   This document describes the use of the SET's editor; this editor was
designed for programmers and to be used alone or inside of the RHIDE.

   This documentation may be freely distributed with the editor or the
RHIDE package or any part thereof, provided this copyright notice is left
intact on all copies.

   Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

  People who helped me develop the editor (alphabetically sorted):

   * ANDRIS PAVENIS <pavenis@lanet.lv>
     (with a lot of patches and reports)

   * BERND BECKER <munin@munin.inka.de>
     (with a lot of corrections to this text)

   * BURTON RADONS <loth@pacificcoast.net>
     (with the new calculator, bug reports and ideas)

   * FRANK DONAHOE <fdonahoe@wilkes1.wilkes.edu>
     (with a lot of corrections to this text)

   * GRZEGORZ ADAM HANKIEWICZ <gradha@users.sourceforge.net>
     (with tests and a lot of ideas)

   * IVAN BALDO <ibaldo@adinet.com.uy>
     (Debian packages, tests and a lot of ideas)

   * MAREK HABERSACK <grendel@ananke.amu.edu.pl>
     (with tests and a lot of ideas)

   * MOLNAR LASZLO <molnarl@cdata.tvnet.hu>
     (with the old calculator, tests and a lot of ideas)

   * ROBERT H”HNE <robert.hoehne@gmx.net>
     (with some base routines, a lot of patches and reports)

  The editor is distributed under the GPL license. Please read the files
included in the source distribution for more information.

  This editor is included in the Robert H”hne's RHIDE as a replacement for
the original Turbo Vision's editor class.

* Menu:

* Copying::
* What is SETs Editor?::
* About the Author::


File: editor.inf,  Node: Copying,  Next: What is SETs Editor?,  Prev: Introduction,  Up: Introduction

1.1 Copying
===========

  The editor is distributed under the GPL license:

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

  A copy of the license should be in the package, if not please tell me.


File: editor.inf,  Node: What is SETs Editor?,  Next: About the Author,  Prev: Copying,  Up: Introduction

1.2 What is SETs Editor?
========================

  SET's editor is an editor designed to be used by programmers; the main
target of the editor is C and C++ code but Pascal and Clipper are supported
too. Currently I'm trying to make it more general so it's useful not only
for programming

  The editor was designed to be very similar to the DOS standard editors
for C, especially to Borland's IDE editor. The editor supports a lot of
WordStar style commands plus some CUA commands, so if you have used any
editor that uses these kinds of commands you'll find my editor very
familiar. On the other hand if you have never used a DOS editor,
especially if you use VI on UNIX machines you'll feel lost. In this case
you may want to configure the keyboard.

*Note How to configure the keyboard::.


File: editor.inf,  Node: About the Author,  Prev: What is SETs Editor?,  Up: Introduction

1.3 About the Author
====================

 0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
 0FЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
 0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ

The editor was created by Salvador Eduardo Tropea with some code
contributed by Robert H”hne

     E-Mail: SALVADOR EDUARDO TROPEA
     <salvador@inti.gov.ar>

     Telephone: (+5411) 4759-0013
     Postal Address:
     Salvador E. Tropea
     CurapaligЃe 2124
     (1678) Caseros - 3 de Febrero
     Prov: Buenos Aires
     Argentina

 0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
 0FЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ
 0BЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫЫ


File: editor.inf,  Node: Documentation guide,  Next: Available commands and keys assignments,  Prev: Introduction,  Up: Top

2 Documentation guide
*********************

  This document is very extensive and was created while developing the
editor starting in 1996. For this reason sometimes is complex to find what
you want or to even know that something is possible. This chapter was
created to try to alleviate this problem. If you have any suggestions
about what to include here don't hesitate and contact me.

* Menu:

* What can be configured to make easier the operation::
* What can be configured to change the look of the editor::
* What can be configured to change the syntax highlighting::
* Things to get help or find some definition::
* Running external programs (compilers/filters/others)::
* Configuration files::


File: editor.inf,  Node: What can be configured to make easier the operation,  Next: What can be configured to change the look of the editor,  Prev: Documentation guide,  Up: Documentation guide

2.1 What can be configured to make easier the operation
=======================================================

  Here is a list of what can be configured to customize the editor input.

   * The keyboard can be configured *Note Keyboard configuration::.

   * The keyboard can be also configured using sLisp command.  *Note sLisp
     macros::.

   * The menues be also configured. *Note Menues configuration::.

   * The shortcuts displayed at the bottom of the screen are called
     `status bar' and can be configured in the same way menues are
     configured.  *Note Menues configuration::.

   * The small menu that pops up when you right click on editor windows is
     also configurable using the menu configuration. *Note Menues
     configuration::.

   * You can define some abbreviations that can then expanded using
     `^Space'. They are language sensitive and they are called
     pseudo-macros or pmacros. *Note Pseudo Macros::.

   * You can ask the editor to record a group of operations and then
     reproduce them. This is what this documentation calls a macro. The
     operations to record and play macros can be found in the `Macro' menu
     (*note Macro::). You can also generate the sLisp code for a macro and
     store it in the `macros.slp' file to use it from the menues or just
     bind it to a key.

   * If you want to automate more complex operations you can use sLisp
     macros. They use a very simple language that is quite similar to Lisp
     or Scheme languages. *Note sLisp macros::. sLisp macros can be called
     using the `Macro|Choose...' or `Macro|Repeat' menu options. You can
     also add menu entries that start certain sLisp macro or bind a sLisp
     macro to a key.  Additionally you can bind a small piece of sLisp
     code to a key or menu entry.


File: editor.inf,  Node: What can be configured to change the look of the editor,  Next: What can be configured to change the syntax highlighting,  Prev: What can be configured to make easier the operation,  Up: Documentation guide

2.2 What can be configured to change the look of the editor
===========================================================

  Here are some things you can change to ajust how the editor looks.

   * The colors used for different elements of the editor can be customized
     using the `Tool&Ops | Options | Colors | Customize...' menu option.
     *Note Customize Colors::.

   * Some predefined color schemes are available in the `Tool&Ops |
     Options | Colors | Theme...' menu option. You can contribute your own
     color scheme sending me you desktop file (desktop files have .dst as
     extension). *Note Color Theme::.

   * The color palette can be customized using the `Tool&Ops | Options |
     Colors | Palette...' menu. This is available for most OSs and
     terminals, but not for all. *Note Color Palette::.

   * The character encodings used by the editor can be also configured.
     This is in the `Tool&Ops | Options | Encodings...' menu. *Note
     Encodings::.

   * Some terminals supports changing the screen or window size. This is in
     the `Tool&Ops | Options | Screen Options...' menu. *Note Screen
     Options::.

   * Some terminals supports changing the font and/or the font size. The
     editor includes various fonts suitable for it. This is in the
     `Tool&Ops | Options | Fonts...' menu. *Note Fonts::.


File: editor.inf,  Node: What can be configured to change the syntax highlighting,  Next: Things to get help or find some definition,  Prev: What can be configured to change the look of the editor,  Up: Documentation guide

2.3 What can be configured to change the syntax highlighting
============================================================

  The editor highlights different elements in the code using different
colors here are things you can do to modify it.

   * The colors used for it can be configured.  *Note What can be
     configured to change the look of the editor::.

   * The syntax highlighting can be configured and/or extended editing the
     `syntaxhl.shl' file. *Note Syntax Highlighting File::.

   * You can define some words as special words. An example of use is to
     highlight your own data types. They are called `user words' and you
     can define them for each supported syntax highlighting. *Note User
     Words::.


File: editor.inf,  Node: Things to get help or find some definition,  Next: Running external programs (compilers/filters/others),  Prev: What can be configured to change the syntax highlighting,  Up: Documentation guide

2.4 Things to get help or find some definition
==============================================

  When coding you usually need to access to help files describing the
language reference or you need to search in your files. This is a list of
the most important tools for it.

   * If the language and/or library you are using have documentation in the
     `info' format (the format used by the GNU project for on-line
     documentation) you can configure the editor to search the syntax of a
     command when pressing `^F1'. *Note Syntax help::.

   * You can browse info files using the InfView info browser. The editor
     also have a man page viewer. Both can be accessed from the `Help'
     menu.  *Note Help::.

   * The editor have a search and replace dialog that supports regular
     expressions and also supports replacement using `templates'. The
     `Search | Find' (*note Find::) and `Search | Replace' (*note
     Replace::) menu entries are used for it.

   * You can search for text using regular expressions. The `Powered Grep'
     dialog allows searching in project items and directories, also
     recursivelly.  *Note Grep::.

   * Using `tag files' the editor can search for definitions, do word
     completion and browse classes. *Note TAGS files::.

   * For some languages the editor can parse your code and extract the
     function definitions. *Note Jump to function::.


File: editor.inf,  Node: Running external programs (compilers/filters/others),  Next: Configuration files,  Prev: Things to get help or find some definition,  Up: Documentation guide

2.5 Running external programs (compilers/filters/others)
========================================================

  You can run external programs to compile, apply filters or any other
thing.  Here are some related options.

   * You run a external program using `Tool&Ops | Run program' menu option
     (*note Run program::). To configure it you can use the `Tool&Ops |
     Options | Run program (which one)' menu option (*note Run program
     (which one)::).

   * The editor collects the messages from the external program and
     displays them in the `message window'. *Note Message Window::.

   * The editor parses the messages from the external program looking for
     errors. The parser can be selected using the `Tool&Ops | Options |
     Run program (which one)' menu option. You can add your own parsers
     editing the `errors.cle' file. *Note Error messages from an external
     application::.

   * You can call external programs binding a sLisp macro to a key or menu
     entry. *Note sLisp macros::, *Note Keyboard configuration::, *Note
     Menues configuration::.

   * You can also call external filters using sLisp macros.  *Note Writing
     macros that use text filters::.


File: editor.inf,  Node: Configuration files,  Prev: Running external programs (compilers/filters/others),  Up: Documentation guide

2.6 Configuration files
=======================

  Here is a list of the most important configuration files.

   * The editor can read configuration files from various directories.
     *Note Configuration files location::.

   * `syntaxhl.shl' configures the syntax highlghting.  *Note Syntax
     Highlighting File::.

   * `pmacros.pmc' and other `.pmc' files are used to configure the
     pmacros (pseudo-macros). *Note Pseudo Macros::.

   * `errors.cle' configures the error parsers. They are used to collect
     error messages from external programs.  *Note Error messages from an
     external application::.

   * `macros.slp' defines the available sLisp macros. *Note sLisp macros::.

   * `userword.txt' defines the user reserved words for syntax
     highlighting. *Note User Words::.

   * `deflopts.txt' configures the default edition options for each syntax
     highlighting style. *Note Default global edition::.

   * `nobkp.txt' configures for which files the editor won't create
     back-ups. *Note Do not create backups for::.

   * `tcedit.dst' and other `.dst' files. They are desktop files and
     contains information about opened windows and configuration options.
     They can be local (one per directory) or global (one for all the
     system). Projects also have its own desktop file. The format is
     binary.

   * `.epr' files. They are project files. The format is binary.

   * `keybind.dat' contains keyboard binding information. The format is
     binary.

   * `setenvir.dat' contains some global settings in binary form.


File: editor.inf,  Node: Available commands and keys assignments,  Next: Keyboard configuration,  Prev: Documentation guide,  Up: Top

3 Available commands and keys assignments
*****************************************

  In this section I will explain the features of the editor and the default
configuration for the keyboard. If you want to change an assignment of a
key consult "configure the keyboard".  *Note How to configure the
keyboard::.

  Read the conventions topic first to understand my way of indicating
keystrokes.

  In the description of each command I'll include the internal name used by
the editor because this name is needed to configure the keyboard.

* Menu:

* Conventions::
* Cursor movement::
* Insert and Delete::
* Blocks::
* Miscellaneous keyboard commands::


File: editor.inf,  Node: Conventions,  Next: Cursor movement,  Prev: Available commands and keys assignments,  Up: Available commands and keys assignments

3.1 Conventions
===============

  I'll use some conventions when talking about the keystrokes needed to
trigger some command. So here is what I use:

  The key named <Ctrl> or Control is represented as `^'; this key doesn't
have any effect used alone inside of the editor so the `^' symbol will be
used only in conjunction with the name of a key indicating that you must
press the two keys at the same time. For example, `^A' is <Ctrl> and <A>
at the same time.  When I say "at the same time" that means: press
`<Ctrl>', hold it, and press the other key; that's the reason to put <A>
after <Ctrl>.

  To indicate a sequence of keystrokes I'll use a dash to separate the
keys. For example, `^K-B' is <Ctrl> and <K> at the same time, and then
press <B>, of course release `^K' first.

  To indicate keys pressed at the same time other than `^x' I'll use a
plus.  For example, `Shift+^Insert' is the three keys at the same time!

  I don't think that you are stupid; the editor is written for programmers,
but I wanted to make that clear to avoid problems ;-).


File: editor.inf,  Node: Cursor movement,  Next: Insert and Delete,  Prev: Conventions,  Up: Available commands and keys assignments

3.2 Cursor movement
===================

   * Character left
     - Command: cmcCharLeft
        - Key: Left arrow
        - Alternate: ^S

   * Character right
     - Command: cmcCharRight
        - Key: Right arrow
        - Alternate: ^D

   * Word left
     - Command: cmcWordLeft
        - Key: ^Left arrow
        - Alternate: ^A

   * Word right
     - Command: cmcWordRight
        - Key: ^Right arrow
        - Alternate: ^F

   * End of the word
     - Command: cmcGoEndOfWord
        - Key:
        - Alternate:

   * Line up
     - Command: cmcLineUp
        - Key: Up arrow
        - Alternate: ^E

   * Line down
     - Command: cmcLineDown
        - Key: Down arrow
        - Alternate: ^X

   * Scroll the screen one line up
     - Command: cmcScrollUp
        - Key: ^W
        - Alternate:

   * Scroll the screen one line down
     - Command: cmcScrollDown
        - Key: ^Z
        - Alternate:

   * Page up
     - Command: cmcPageUp
        - Key: PgUp
        - Alternate: ^R

   * Page down
     - Command: cmcPageDown
        - Key: PgDn
        - Alternate: ^C

   * Beginning of line
     - Command: cmcLineStart
        - Key: Home
        - Alternate: ^Q-S

   * End of line
     - Command: cmcLineEnd
        - Key: End
        - Alternate: ^Q-D

   * Top of window
     - Command: cmcFirstLineInScreen
        - Key: ^Q-E
        - Alternate: ^Home

   * Bottom of window
     - Command: cmcLastLineInScreen
        - Key: ^Q-X
        - Alternate: ^End

   * Top of file
     - Command: cmcTextStart
        - Key: ^Q-R
        - Alternate: ^PgUp

   * Bottom of file
     - Command: cmcTextEnd
        - Key: ^Q-C
        - Alternate: ^PgDn



File: editor.inf,  Node: Insert and Delete,  Next: Blocks,  Prev: Cursor movement,  Up: Available commands and keys assignments

3.3 Insert and Delete
=====================

   * Delete the character under cursor
     - Command: cmcDelChar
        - Key: Del
        - Alternate: ^G

   * Delete character to left
     - Command: cmcBackSpace
        - Key: Backspace
        - Alternate: ^H

   * Delete line
     - Command: cmcDelLine
        - Key: ^Y
        - Alternate:

   * Delete to end of line
     - Command: cmcDelEnd
        - Key: ^Q-Y
        - Alternate: Shift+^Y

   * Delete to start of line
     - Command: cmcDelStart
        - Key: ^Q-H
        - Alternate:

   * Delete word at right
     - Command: cmcDelWord
        - Key: ^T
        - Alternate:

   * Delete word at left
     - Command: cmcDelPrevWord
        - Key: ^Backspace
        - Alternate:

   * Insert line
     - Command: cmcNewLine
        - Key: Enter
        - Alternate: ^N

   * Smart tab
     - Command: cmcSmartTab
        - Key: Tab
        - Alternate: ^I

   * Insert mode on/off
     - Command: cmcInsMode
        - Key: Ins
        - Alternate: ^V


  When you are in insert mode all the typed characters are inserted in the
text, but when the insert mode is off the typed characters replace the old
text. The editor starts with insert mode on. You can quickly know the mode
by the cursor shape. When the insert mode is on, the cursor is only a
line, but when it is off, the cursor is block shaped.


File: editor.inf,  Node: Blocks,  Next: Miscellaneous keyboard commands,  Prev: Insert and Delete,  Up: Available commands and keys assignments

3.4 Blocks
==========

  A block is a selected portion of the text. You can copy, delete, `etc.'
blocks of text. The associated commands are:

   * Move to beginning of block
     - Command: cmcGoBeginBlock
        - Key: ^Q-B
        - Alternate:

   * Move to end of block
     - Command: cmcGoEndBlock
        - Key: ^Q-K
        - Alternate:

   * Set beginning of block
     - Command: cmcStartSelect
        - Key: ^K-B
        - Alternate:

   * Set end of block
     - Command: cmcEndSelect
        - Key: ^K-K
        - Alternate:

   * Hide/Show block
     - Command: cmcHideSelect
        - Key: ^K-H
        - Alternate:

   * Mark line
     - Command: cmcMarkLine
        - Key: ^K-L
        - Alternate:

   * Mark word
     - Command: cmcMarkWord
        - Key: ^K-T
        - Alternate:

   * Delete block and copy it to the Clipboard
     - Command: cmcCut
        - Key: ^K-Y
        - Alternate: Shift+Del

   * Copy the selected block
     - Command: cmcCopyBlock
        - Key: ^K-C
        - Alternate:

   * Move block
     - Command: cmcMoveBlock
        - Key: ^K+V
        - Alternate:

   * Copy to Clipboard
     - Command: cmcCopy
        - Key: ^Ins
        - Alternate:

   * Delete block
     - Command: cmcClear
        - Key: ^Del
        - Alternate:

   * Paste from Clipboard
     - Command: cmcPaste
        - Key: Shift+Ins
        - Alternate:

   * Read block from disk
     - Command: cmcReadBlock
        - Key: ^K-R
        - Alternate: Shift+^R

   * Write block to disk
     - Command: cmcWriteBlock
        - Key: ^K-W
        - Alternate: Shift+^W

   * Replace the block by the Clipboard block
     - Command: cmcReplaceSelect
        - Key: Shift+^Ins
        - Alternate:

   * Convert to Uppercase
     - Command: cmcToUpper
        - Key: ^K-M
        - Alternate:

   * Convert to Lowercase
     - Command: cmcToLower
        - Key: ^K-O
        - Alternate:

   * Invert case
     - Command: cmcInvertCase
        - Key: none
        - Alternate:

   * Alternate case
     - Command: cmcAltCase
        - Key: none
        - Alternate:

   * Report the length of the block
     - Command: cmcSelLength
        - Key: ^Q-L
        - Alternate:


* Menu:

* Block modes::
* Selecting with the mouse or Shift::
* Indentation::
* Rectangular Blocks::


File: editor.inf,  Node: Block modes,  Next: Selecting with the mouse or Shift,  Prev: Blocks,  Up: Blocks

3.4.1 Block modes
-----------------

  There are two block modes. One is the mode that the old editor of RHIDE
used. This mode is used in CUA programs. The other is called Persistent
Blocks.

  In the normal mode each time you select a block and then insert anything
in it (with `cmcPaste' or by typing anything) the selected block is deleted
and is replaced by the new text.

  In persistent blocks the selection is not replaced and is not lost when
you move the cursor. From this comes the name "Persistent." In this mode
you can use `cmcMoveBlock' and `cmcCopyBlock' without using the Clipboard.
In addition you can apply indentations to the block (*note Indentation::),
search only inside it, `etc.' That's what makes this mode much more
powerful than the former. If you really like to replace the selected text
by the selection of the Clipboard, that's the default behaviour of the
first mode. You can use the `cmcReplaceSelect' command to achieve the same
in the Persistent Blocks mode.


File: editor.inf,  Node: Selecting with the mouse or Shift,  Next: Indentation,  Prev: Block modes,  Up: Blocks

3.4.2 Selecting with the mouse or Shift
---------------------------------------

  The described commands for selecting a block, `cmcStartSelect' and
`cmcEndSelect', are good but not so quick. There are other ways to do this.

* Menu:

* Using the mouse::
* Using the Shift key::


File: editor.inf,  Node: Using the mouse,  Next: Using the Shift key,  Prev: Selecting with the mouse or Shift,  Up: Selecting with the mouse or Shift

3.4.2.1 Using the mouse
.......................

  Using the mouse you need only point to the start place, and while
pressing the left button moving the mouse to the end point of your block.

  To select a word with the mouse just double click on it.


File: editor.inf,  Node: Using the Shift key,  Prev: Using the mouse,  Up: Selecting with the mouse or Shift

3.4.2.2 Using the Shift key
...........................

  Using the <Shift> key you only need to move the cursor to the start
point, keep `<Shift>' pressed and move the cursor to the end point with
any of the available cursor commands. *Note Cursor movement::.


File: editor.inf,  Node: Indentation,  Next: Rectangular Blocks,  Prev: Selecting with the mouse or Shift,  Up: Blocks

3.4.3 Indentation
-----------------

  You can indent or unindent a block of text using various commands, but
you must keep in mind that for now the editor is limited in the following
way: If you are using tabs to indent your text, don't mix tabs with spaces
and, if you are using spaces to indent, don't mix them with real tabs.
*Note Real Tabs::.

   * Indent block one position adding a space
     - Command: cmcIndentBlkOne
        - Key: ^K-I
        - Alternate: Shift+^I

   * Unindent block one character - not an x position
     - Command: cmcUnIndentBlkOne
        - Key: ^K-U
        - Alternate: Shift+^U

   * Indent block
     - Command: cmcIndentBlk
        - Key: ^K-Tab
        - Alternate:

   * Unindent block
     - Command: cmcUnIndentBlk
        - Key: ^K-Shift+Tab
        - Alternate:


`cmcUnIndentBlkOne' unindents deleting one char at the start of the line
so, if the line is indented with tabs, the line will retract one tab.

`cmcIndentBlk' acts according to the mode. If you are using tabs, the
editor will put one tab at the beginning of each line. If you aren't using
tabs the editor will operate the Tab command on the first line and then
will use this amount of indentation on the entire block. *Note Real Tabs::.

`cmcUnIndentBlk' acts according to the mode too. *Note Real Tabs::.  Just
like `cmcUnIndentBlkOne' it deletes one tab but if you don't use tabs the
editor uses Backspace on the first used column of the first line of the
block and unindents by the resulting amount the rest of the block.

The following commands aren't applied to the whole block, they apply only
to the line where the cursor is positioned.

   * Smart Indent block
     - Command: cmcSmartIndent
        - Key: ^Tab

   * Smart Unindent block
     - Command: cmcSmartUnIndent
        - Key: Shift+^Tab


`cmcSmartIndent' and `cmcSmartUnIndent' indents take as reference the { }
pair where the cursor is, for example:

       {
     line1
          line2
        line3
       }

After indenting line1 with `cmcSmartIndent' and line2 with
`cmcSmartUnIndent' you get:

       {
        line1
        line2
        line3
       }

The indentation is made with spaces and you must put the cursor on the
first letter of the line, the l in this example.


File: editor.inf,  Node: Rectangular Blocks,  Prev: Indentation,  Up: Blocks

3.4.4 Rectangular Blocks
------------------------

  The editor includes a mode where you can select a rectangular portion of
the text and copy, cut, clear, paste, move, `etc.' this region.  This tool
is very useful for modifications on columns.

  Attention! The selected area is based on the X,Y coordinates. For this
reason if you insert lines before the bottom of the rectangle the area
won't be moved. I don't plan to move the area by now because that takes
some CPU and I think that this selection is made just before using it. So
don't report that like a bug. That is the way it works!

   * Set beginning of block
     - Command: cmcSelRectStart
        - Key: ^K-Shift+B

   * Set end of block
     - Command: cmcSelRectEnd
        - Key: ^K-Shift+K

   * Hide/Show block
     - Command: cmcSelRectHide
        - Key: ^K-Shift+H

   * Delete block and copy it to an special Clipboard
     - Command: cmcSelRectCut
        - Key: ^K-ShiftT

   * Move block
     - Command: cmcSelRectMove
        - Key: ^K+Shift+V

   * Copy to special Clipboard
     - Command: cmcSelRectCopy
        - Key: ^K-Shift+C

   * Delete block
     - Command: cmcSelRectDel
        - Key: ^K-Shift+L

   * Paste from special Clipboard
     - Command: cmcSelRectPaste
        - Key: ^K-Shift+P

   * Copy and Paste in one operation
     - Command: cmcSelRectCopyPaste
        - Key: ^K-Shift+O

   * Replace the content using spaces
     - Command: cmcSelRectClear
        - Key: ^K-Shift+E

   * Convert to uppercase
     - Command: cmcSelRectToUpper
        - Key:

   * Convert to lowercase
     - Command: cmcSelRectToLower
        - Key:



File: editor.inf,  Node: Miscellaneous keyboard commands,  Prev: Blocks,  Up: Available commands and keys assignments

3.5 Miscellaneous keyboard commands
===================================

   * Autoindent mode on/off
     - Command: cmcIndentMode
        - Key: ^O

   * Find place marker
     - Command: cmcGotoMarkn
        - Key: ^Q n*

   * Set marker
     - Command: cmcPutMarkn
        - Key: ^K n*

   * Search for open curly bracket from where the cursor is
     - Command: cmcSearchStart
        - Key: ^[

   * Search for close curly bracket from where the cursor is
     - Command: cmcSearchEnd
        - Key: ^]

   * Search for ( from where the cursor is
     - Command: cmcSearchOpPar
        - Key: Shift+^9

   * Search for ) from where the cursor is
     - Command: cmcSearchClPar
        - Key: Shift+^0

   * Search for [ from where the cursor is
     - Command: cmcSearchOpCor
        - Key: Shift+^[

   * Search for ] from where the cursor is
     - Command: cmcSearchClCor
        - Key: Shift+^]

   * Search for the complementary pair
     - Command: cmcSearchComplement
        - Key: ^Q ESC

   * Undo
     - Command: cmcUndo
        - Key: Alt+Backspace

   * PMacro's Trigger
     - Command: cmcExpandCode
        - Key: ^Space

   * Goto Line
     - Command: cmcGotoEditorLine
        - Key: ^J

   * Set the options for the current window (Not in RHIDE)
     - Command: cmcSetLocalOptions
        - Key: Alt+L

   * Set the default options (Not in RHIDE)
     - Command: cmcSetGlobalOptions
        - Key: Alt+G

   * Convert all tabs to spaces
     - Command: cmcExpandAllTabs
        - Key: From menu

   * Compact the text using tabs
     - Command: cmcCompactBuffer
        - Key: From menu

   * Start recording a macro
     - Command: cmcRecordMacro
        - Key: Shift+F10

   * Stop recording a macro
     - Command: cmcStopMacro
        - Key: Alt+F10

   * Play a macro
     - Command: cmcPlayMacro
        - Key: ^F10



File: editor.inf,  Node: Keyboard configuration,  Next: Pull-down menues,  Prev: Available commands and keys assignments,  Up: Top

4 Keyboard configuration
************************

  The editor can be configured to trigger one or more commands pressing
one key or an arbitrary sequence of keys. Unlike old versions, now the
sequence of keys isn't limited.  Additionally you no longer need to
configure the editor for non-US keyboards.

  You can also assing sLisp defined macros to keys or even small portions
of sLisp code to keys. In addition you can change the key assignments using
sLisp macros.

  If you are looking for information about the names used for the keys in
the editor consult: *Note Key names::.

* Menu:

* How to configure the keyboard::
* Alt key configuration::
* Restoring the default keyboard assignments::
* Consulting scan codes::


File: editor.inf,  Node: How to configure the keyboard,  Next: Alt key configuration,  Prev: Keyboard configuration,  Up: Keyboard configuration

4.1 How to configure the keyboard
=================================

 These options are located under the menu option called Tool&Ops, submenu
Options, submenu Keyboard, submenu Key assignment; yes is a little deep in
the menu.

  After selecting this option you'll get a window with the keyboard
assignments. This window shows entries of the type `Key sequence ->
Command sequence'. You can delete an assignment by selecting it and
choosing the `Delete' button.

  The list is sorted by a internal criteria. The keys with <Shift> have an
`S' in front, for <Ctrl> you'll see a `C' and for <Alt> an `A'. The editor
can distinguish the left and right <Alt> keys; if you enable it the right
<Alt> will be represented by an `a'. *Note Alt key configuration::.

  To add a new assignment press the `Add' button. A window called
`Sequence of keys' will appear. This window is used to choose the sequence
of keys that will trigger an action in the editor. The sequence can be as
large as you want, so if you want to assign a sequence like this:
`^A-Shift+^Insert-Alt+Z' you can, but I doubt you really want to use such
a complex combination even if the editor is flexible enough to allow it.

  To add a new key to the sequence use the `Add' button, to delete a key
use the `Delete' button. The `Add' button always adds a key to the end of
the list; to insert a key in the sequence use the `Insert' button, it will
insert the key before the selected key. Finally you can choose if you want
to assign a sequence of commands or a sLisp macro to this key sequence.
*Note sLisp macros::.

* Menu:

* Assigning a sequence of commands::
* Assigning a sLisp macro::
* Assigning sLisp code::


File: editor.inf,  Node: Assigning a sequence of commands,  Next: Assigning a sLisp macro,  Prev: How to configure the keyboard,  Up: How to configure the keyboard

4.1.1 Assigning a sequence of commands
--------------------------------------

  A window called `Commands' will appear. The mechanism to add, insert and
delete commands is the same as used for a keyboard sequence. This time
when you add or insert a new command to the sequence a window with all the
available commands will pop-up.  The meaning of each command can be found
in the indices of this help.

  To make a selection with the commands, like when holding <Shift>, you
must use the `SelectOn' and `SelectOff' commands. For an example you can
take a look at the assignments for the `Shift+Left' or `Shift+Right' keys.


File: editor.inf,  Node: Assigning a sLisp macro,  Next: Assigning sLisp code,  Prev: Assigning a sequence of commands,  Up: How to configure the keyboard

4.1.2 Assigning a sLisp macro
-----------------------------

  A window called `Macros' will appear. This window shows all the macros
defined in the `macros.slp' file. *Note sLisp macros::.

  The main advantage of using macros instead of command sequence is that
macros can insert text in your code.


File: editor.inf,  Node: Assigning sLisp code,  Prev: Assigning a sLisp macro,  Up: How to configure the keyboard

4.1.3 Assigning sLisp code
--------------------------

  A window called `sLisp code' will appear. This window shows allows
entering a small portion of sLisp code. For long code use define a macro.
*Note sLisp macros::.

  The sLisp code must start with `(' and end with `)' or you'll get parser
errors.


File: editor.inf,  Node: Alt key configuration,  Next: Restoring the default keyboard assignments,  Prev: How to configure the keyboard,  Up: Keyboard configuration

4.2 Alt key configuration
=========================

  The editor can distinguish the left and right <Alt> keys. As old
versions didn't allowed that and as different users use different <Alt>
keys the editor doesn't make any difference between them anymore by
default.

  The `Setup Alt keys' menu option (under Tool&Ops | Options | Keyboard)
allows to enable it. Three options are offered:

   * Left Alt
     - Meaning: The menues are tiggered by the left Alt and you can use
     the right Alt for commands

   * Right Alt
     - Meaning: The reverse as for Left Alt - right Alt activates menues,
     left Alt commands

   * Both Alt
     - Meaning: Both keys can be used for menues



File: editor.inf,  Node: Restoring the default keyboard assignments,  Next: Consulting scan codes,  Prev: Alt key configuration,  Up: Keyboard configuration

4.3 Restoring the default keyboard assignments
==============================================

  If you need to restore the original keyboard assignment because you did
something very wrong you can use this option for that. The option is
located under Tool&Ops | Options | Keyboard.


File: editor.inf,  Node: Consulting scan codes,  Prev: Restoring the default keyboard assignments,  Up: Keyboard configuration

4.4 Consulting scan codes
=========================

  If you need to know the scan code of a key for your program you don't
need to use a table or another program. The editor has a tool built in
that shows scancodes for keypresses under Tool&Ops | Options | Keyboard.


File: editor.inf,  Node: Pull-down menues,  Next: Menues configuration,  Prev: Keyboard configuration,  Up: Top

5 Pull-down menues
******************

The menues are configurable; for this reason the following structure is
just one of many possible arrangements.

If you need or want to configure the shortcuts activating the menues or
menue options look at the `menubind.smn' file. The format is self
explanatory and the editor supports syntax highlighting for these files.
*Note Menues configuration::.

* Menu:

* File::
* Edit::
* Search::
* Macro::
* Rectangle::
* Windows::
* Tool&Ops::
* Project::
* Help::


File: editor.inf,  Node: File,  Next: Edit,  Prev: Pull-down menues,  Up: Pull-down menues

5.1 File
========

This menu contains the file operations (save, load, print, `etc.') and the
program exit functions.

* Menu:

* Open::
* New::
* Open Read-only copy::
* Save::
* Save as::
* Save as UNIX or DOS::
* Save as DOS or UNIX::
* Save with same time::
* Save all::
* Print::
* Print Setup::
* Shell::
* Quit::
* Exit::


File: editor.inf,  Node: Open,  Next: New,  Prev: File,  Up: File

5.1.1 Open
----------

This option brings the file open dialog (*note File Open::). From this
dialog you can select a file to load and edit.

Choose the Open button or select a file with `<Enter>' to open the file.
Use `<Esc>' to abort.

If the file is read-only a dialog will ask you if you want to make the file
writable, in this case the editor will try to change the file attributes.
Not always is it possible to change these attributes, as for example, the
CDs are read-only and obviously you can't change files on them.

Name of the command: cmeOpen.
Assigned key: `F3'


File: editor.inf,  Node: New,  Next: Open Read-only copy,  Prev: Open,  Up: File

5.1.2 New
---------

Use this option to create a new and empty editor window. The window's name
will be `Untitled'.

An alternative way to do it is just using the `Open' option and give a new
name instead of selecting an existing file. *Note Open::. The advantage of
this method is that the new window already has a meaningful name, instead
of having to save the file first.

Name of the command: cmeNew.


File: editor.inf,  Node: Open Read-only copy,  Next: Save,  Prev: New,  Up: File

5.1.3 Open Read-only copy
-------------------------

Use this option to open a copy of the file you are editing in another
window.

Be careful, the new copy is loaded from disk so it may be unsychronized.
The copy will automatically become read-only so you won't be able to
modify it and accidentally overwrite the first copy.

For more information: *Note Editor General::.

Name of the command: cmeOpenROCopy.


File: editor.inf,  Node: Save,  Next: Save as,  Prev: Open Read-only copy,  Up: File

5.1.4 Save
----------

This option saves the contents of the current window. Only the contents of
this window are saved; not anything else. Additionally it only saves if
the window was modified.

If the window is named `Untitled' this command acts like *Note Save as::.

Name of the command: cmcSave.
Assigned key: `F2'


File: editor.inf,  Node: Save as,  Next: Save as UNIX or DOS,  Prev: Save,  Up: File

5.1.5 Save as
-------------

This option allows to save the contents of the current window specifying a
new name for the file. For this purpose the file open dialog is used
(*note File Open::).

If the file already exists a dialog will pop-up asking for confirmation to
overwrite the existing file.

The title of the window is changed to reflect the new file name.

Name of the command: cmcSaveAs.


File: editor.inf,  Node: Save as UNIX or DOS,  Next: Save as DOS or UNIX,  Prev: Save as,  Up: File

5.1.6 Save as UNIX or DOS
-------------------------

This menu entry says `Save as UNIX' for DOS or Win32 systems and `Save as
DOS' for UNIX systems.

This option is very similar to the `Save as' option (*note Save as::). The
only difference is that the editor will change the end of line character.

Additionally there is an option to save UNIX files as UNIX files without
converting it to DOS style. *Note Tool&Ops|Options|Editor General: Editor
General.

Name of the command: cmcSaveAsConvertEOL.


File: editor.inf,  Node: Save as DOS or UNIX,  Next: Save with same time,  Prev: Save as UNIX or DOS,  Up: File

5.1.7 Save as DOS or UNIX
-------------------------

This menu entry says `Save as DOS' for DOS or Win32 systems and `Save as
UNIX' for UNIX systems.

This option is useful when the editor is configured to save files without
converting the end of line character and you want to force a convertion.

Name of the command: cmcSaveAsNoConvertEOL.


File: editor.inf,  Node: Save with same time,  Next: Save all,  Prev: Save as DOS or UNIX,  Up: File

5.1.8 Save with same time
-------------------------

This option is very similar to the `Save' option (*note Save::). The only
difference is that the editor won't modify the creation time. This option
is very useful to modify header files avoiding the recompilation of the
whole project. A common case is when you only add constants to a header
that is included by various files but only one will use the new constants.

Name of the command: cmcSaveSameTime.


File: editor.inf,  Node: Save all,  Next: Print,  Prev: Save with same time,  Up: File

5.1.9 Save all
--------------

All modified editing windows will be saved.

Name of the command: cmcSaveAll.


File: editor.inf,  Node: Print,  Next: Print Setup,  Prev: Save all,  Up: File

5.1.10 Print
------------

This option prints the current editor window. Don't use this option without
configuring the printer module. *Note Print Setup::.

This option was designed to print source files, to print plain text files
or avoid all the formating features. Select the portion of text to be
printed and save the block (`^K-W') to a file with the name of the device
to which your printer is connected. As an example to print to the DOS LPT 1
device just write the block to the `lpt1' file.

The editor will report the number of lines processed and printed in the
message window.

To learn more about the message window *Note Message Window::.

Name of the command: cmePrintEditor.


File: editor.inf,  Node: Print Setup,  Next: Shell,  Prev: Print,  Up: File

5.1.11 Print Setup
------------------

This option brings up a dialog to configure the printing module. After
configuring it you can print using the `Print' option. *Note Print::.  If
you want to print a plain text (without formating) consult the `Print'
option too.

The dialog asks for the following parameters:

   * Total lines per page: The total number of lines that fits on one page
     including the footer and header lines.

   * Columns w/o margin: The number of colums that fits on the page
     excluding the desired margin.

   * Left margin: The number of columns left blank at the left side of the
     page.

   * Print line numbers: Select this option to get the line numbers printed

   * Time format: The time format specified in the C style. *Note Time and
     date modifiers formats::.

   * Date format: The date format specified in the C style. *Note Time and
     date modifiers formats::.

   * Title: only used in the header.

   * Author: only used in the header.

   * Output file: Specify the printer device here. For example: the DOS
     LPT 1 is the lpt1 file.

   * Printer initialization: The sequence of character used to initialize
     the printer. Normally it includes a reset and a font selection.
     Specify the values separated by commas.

   * Before heading: Commands to send before the header.

   * After heading: Commands to send after the header.

   * Before footer: Commands to send before the footer.

   * After footer: Commands to send after the footer.

Use the `Ok' button to confirm or the `Cancel' button to reject.

The `Epson' button fills the values with the default settings for Epson
printers (ESCP2 language). The `HP' button fills the values with the
default settings for Hewlett Packard ink-jet printers.

The printer module was designed by me some years ago when I needed to
present a program at my University (Universidad Tecnologica Nacional) and
I wanted to add to the source code listing a header, footer, lines number,
page number, date/time of the printing, project and author. So that's what
the routines does. I know they are limited but they generate a very good
listing, much better than just printing the text without any formating.

Name of the command: cmeSetUpPrinter.


File: editor.inf,  Node: Shell,  Next: Quit,  Prev: Print Setup,  Up: File

5.1.12 Shell
------------

Calls the default command interpreter indicated by the `COMSPEC'
enviroment variable. I guess you know that by typing exit you'll get back
to the editor.

Name of the command: cmeDosShell.


File: editor.inf,  Node: Quit,  Next: Exit,  Prev: Shell,  Up: File

5.1.13 Quit
-----------

This option exits the editor deleting all the back-up, desktop and project
files located in the current directory. That's useful if you want to keep
the directory clean.

When you use this option a dialog will appear asking for confirmation, you
can avoid this dialog in the future by checking the "don't show again"
option.

Name of the command: cmeQuitDelete.
Assigned key: `Alt+Q'


File: editor.inf,  Node: Exit,  Prev: Quit,  Up: File

5.1.14 Exit
-----------

This option just exits the program. The editor asks for each modified
editor window if you want to save the changes. All the settings are stored
in the desktop file automatically.

Name of the command: cmeQuit.
Assigned key: `Alt+X'


File: editor.inf,  Node: Edit,  Next: Search,  Prev: File,  Up: Pull-down menues

5.2 Edit
========

This menu contains all the editing operations that have a menu shortcut.

* Menu:

* Undo::
* Redo::
* Cut::
* Copy::
* Paste::
* Show clipboard::
* Clear::
* Set Local::
* Set Global::
* Expand all tabs::
* Compact text::
* Copy to Windows Clipboard::
* Paste from Windows Clipboard::
* Copy to file Clipboard::
* Paste from file Clipboard::
* Push cursor position::
* Pop cursor position::
* Case (Menu)::
* Insert new line (do not move)::


File: editor.inf,  Node: Undo,  Next: Redo,  Prev: Edit,  Up: Edit

5.2.1 Undo
----------

This option reverts the last edit operation. Upto 32 operations can be
reverted.

Name of the command: cmcUndo.
Assigned key: `Alt+BackSpace'


File: editor.inf,  Node: Redo,  Next: Cut,  Prev: Undo,  Up: Edit

5.2.2 Redo
----------

This option takes back the last `Undo'. *Note Undo::.

Name of the command: cmcRedo.


File: editor.inf,  Node: Cut,  Next: Copy,  Prev: Redo,  Up: Edit

5.2.3 Cut
---------

The selected text is copied to the clipboard and deleted from the text.
*Note Clipboard::.

Name of the command: cmcCut.
Assigned key: `Shift+Del'


File: editor.inf,  Node: Copy,  Next: Paste,  Prev: Cut,  Up: Edit

5.2.4 Copy
----------

The selected text is copied to the clipboard. *Note Clipboard::.

Name of the command: cmcCopy.
Assigned key: `^Ins'


File: editor.inf,  Node: Paste,  Next: Show clipboard,  Prev: Copy,  Up: Edit

5.2.5 Paste
-----------

The text that's currently selected in the clipboard is inserted at the
cursor position. *Note Clipboard::.

Name of the command: cmcPaste.
Assigned key: `Shift+Ins'


File: editor.inf,  Node: Show clipboard,  Next: Clear,  Prev: Paste,  Up: Edit

5.2.6 Show clipboard
--------------------

This option shows the clipboard window. *Note Clipboard::.

Name of the command: cmeShowClip.


File: editor.inf,  Node: Clear,  Next: Set Local,  Prev: Show clipboard,  Up: Edit

5.2.7 Clear
-----------

Deletes the selected text. It isn't copied to the clipboard.

Name of the command: cmcClear.
Assigned key: `^Del'


File: editor.inf,  Node: Set Local,  Next: Set Global,  Prev: Clear,  Up: Edit

5.2.8 Set Local
---------------

This option pops up the local configuration dialog. The values in this
dialog are valid only for the current editor window.

The first group of options are related to the editing modes.  *Note
Editing Modes::.

The syntax highlight group of options allows to choose the type of
highlight.  *Note Syntax Highlighting::.

Additionally the window allows to indicate the tab size and the column
where the wrap cuts the lines.

Name of the command: cmcSetLocalOptions.
Assigned key: `Alt+L'


File: editor.inf,  Node: Set Global,  Next: Expand all tabs,  Prev: Set Local,  Up: Edit

5.2.9 Set Global
----------------

This option pops up the global configuration dialog. The values in this
dialog are used as default values. If you exit the dialog using the `Ok'
button these values aren't applied to any of the editor windows, they just
act as default values for newly opened and created files. If you exit the
dialog using the `To all' button these values are applied to all the
editor windows. To set the options for just one window *Note Set Local::.

The options are related to the editing modes. *Note Editing Modes::.

Additionally the window allows to indicate the tab size and the column
where the wrap cuts the lines.

Name of the command: cmcSetGlobalOptions.
Assigned key: `Alt+G'


File: editor.inf,  Node: Expand all tabs,  Next: Compact text,  Prev: Set Global,  Up: Edit

5.2.10 Expand all tabs
----------------------

This option converts all the tabs to spaces. *Note Real Tabs::.

The tabs are expanded to the current tab size, check this value before
using this option.

Name of the command: cmcExpandAllTabs.


File: editor.inf,  Node: Compact text,  Next: Copy to Windows Clipboard,  Prev: Expand all tabs,  Up: Edit

5.2.11 Compact text
-------------------

This option converts spaces to tabs where possible. *Note Real Tabs::.

Be careful, if the tab size is too small the editor will generate tons of
tabs, even in places where you may not want a tab.

Name of the command: cmcCompactBuffer.


File: editor.inf,  Node: Copy to Windows Clipboard,  Next: Paste from Windows Clipboard,  Prev: Compact text,  Up: Edit

5.2.12 Copy to Windows Clipboard
--------------------------------

Copies the selected text to Windows' clipboard. Of course you must be
running Windows to be able to use this ;-)). Don't expect this feature to
work always though, as Windows has bugs in the WinOldAp module; which is
used to provide this function.

There is a command called `cmcCutClipWin' you can use to cut a portion of
text copying it to Windows' clipboard.

Name of the command: cmcCopyClipWin.

Name of the command: cmcCutClipWin.


File: editor.inf,  Node: Paste from Windows Clipboard,  Next: Copy to file Clipboard,  Prev: Copy to Windows Clipboard,  Up: Edit

5.2.13 Paste from Windows Clipboard
-----------------------------------

Pastes the Windows' clipboard content at the cursor's position. Of course
you must be running Windows and have some text in the clipboard.  Don't
expect this feature to work always though, as Windows has bugs in the
WinOldAp module; which is used to provide this function.

Name of the command: cmcPasteClipWin.


File: editor.inf,  Node: Copy to file Clipboard,  Next: Paste from file Clipboard,  Prev: Paste from Windows Clipboard,  Up: Edit

5.2.14 Copy to file Clipboard
-----------------------------

Copies the selected text to a special file used as clipboard. This option
is usually available on UNIX as a replacement for the Windows clipboard
functions. The file is created in a user specific directory, for this
reason the information is only available to one user.

Name of the command: cmcCopyClipFile.


File: editor.inf,  Node: Paste from file Clipboard,  Next: Push cursor position,  Prev: Copy to file Clipboard,  Up: Edit

5.2.15 Paste from file Clipboard
--------------------------------

Pastes text from a special file used as clipboard. This option is usually
available on UNIX as a replacement for the Windows clipboard functions.
The file is created in a user specific directory, for this reason the
information is only available to one user.

Name of the command: cmcPasteClipFile.


File: editor.inf,  Node: Push cursor position,  Next: Pop cursor position,  Prev: Paste from file Clipboard,  Up: Edit

5.2.16 Push cursor position
---------------------------

It stores the cursor position (x,y) in a stack. You can restore it later
using *Note Pop cursor position::. The stack can hold up to eleven nested
positions; if you try to push a 12th value the oldest is discarded.

Name of the command: cmcPushCursorPos.


File: editor.inf,  Node: Pop cursor position,  Next: Case (Menu),  Prev: Push cursor position,  Up: Edit

5.2.17 Pop cursor position
--------------------------

It restores the cursor position (x,y) from a stack. You can store the
position using *Note Push cursor position::. The stack can hold up to
eleven nested positions; if you try to push a 12th value the oldest is
discarded.

Name of the command: cmcPopCursorPos.


File: editor.inf,  Node: Case (Menu),  Next: Insert new line (do not move),  Prev: Pop cursor position,  Up: Edit

5.2.18 Case (Menu)
------------------

This submenu contains operations to convert blocks or single characters to
uppercase or lowercase and similar operations

* Menu:

* Block to upper::
* Block to lower::
* Character toggle::
* Block invert::
* Block alternate::


File: editor.inf,  Node: Block to upper,  Next: Block to lower,  Prev: Case (Menu),  Up: Case (Menu)

5.2.18.1 Block to upper
.......................

Converts all the selected characters to uppercase.

Name of the command: cmcToUpper.


File: editor.inf,  Node: Block to lower,  Next: Character toggle,  Prev: Block to upper,  Up: Case (Menu)

5.2.18.2 Block to lower
.......................

Converts all the selected characters to lowercase.

Name of the command: cmcToLower.


File: editor.inf,  Node: Character toggle,  Next: Block invert,  Prev: Block to lower,  Up: Case (Menu)

5.2.18.3 Character toggle
.........................

Converts the character under the cursor to lowercase if it was uppercase
and `vice versa'.

Name of the command: cmcToggleCharCase.


File: editor.inf,  Node: Block invert,  Next: Block alternate,  Prev: Character toggle,  Up: Case (Menu)

5.2.18.4 Block invert
.....................

Converts all the selected uppercase characters to lowercase and vice versa.

Name of the command: cmcInvertCase.


File: editor.inf,  Node: Block alternate,  Prev: Block invert,  Up: Case (Menu)

5.2.18.5 Block alternate
........................

It will convert the first character to uppercase, the second to lowercase
and so on. If you want the reverse you can use the command to invert a
block.  *Note Block invert::.

Name of the command: cmcAltCase.


File: editor.inf,  Node: Insert new line (do not move),  Prev: Case (Menu),  Up: Edit

5.2.19 Insert new line (do not move)
------------------------------------

It inserts a new line character at cursor position but without modifying
the cursor position. Note it doesn't apply indentation or other special
things to the inserted line.

Name of the command: cmcInsertNewLine.
Assigned key: `Ctrl+N'


File: editor.inf,  Node: Search,  Next: Macro,  Prev: Edit,  Up: Pull-down menues

5.3 Search
==========

This menu contains the search and replace commands of the editor. The
search function also includes advanced tools specifically designed for
programmers, like the options to jump to a function definition or a symbol.

* Menu:

* Find::
* Replace::
* Search again::
* Name current function::
* Jump to function::
* Jump to prototype::
* Jump to symbol::
* Go to line::
* Class browser::
* Word completion::
* Jump to last cursor position::
* Jump to last undo position::


File: editor.inf,  Node: Find,  Next: Replace,  Prev: Search,  Up: Search

5.3.1 Find
----------

This command searches a string in the current editor. The dialog contains
the following fields:

   * Text to find: The text you want to find.

   * Case sensitive: Use this option if the case of the text to search is
     important.

   * Whole words only: When this option is set the editor searches for
     whole words. If not the text to search can be only part of a word.

   * Regular expressions: Use this option if the text to search is a
     regular expression. A description of the syntax used by regular
     expressions can be found in the libc. *Note Regular Expressions::.
     Three types of regular expression are supported. *Note Regular
     Expressions Options::.

   * Only inside comments: Matches will be returned only if the first
     character is inside a comment. Every type of comment supported by the
     syntax highlighting is supported. It doesn't have any sense for plain
     text.

   * Only outside comments: Matches will be returned only if the first
     character is outside a comment. If the previous option is also
     enabled this option takes precedence.

   * Scope - Global: The search will ignore the selected text.

   * Scope - Selected text: The search will be done only inside the
     selected text.

   * Origin - From cursor: The search will start from the position of the
     cursor.

   * Origin - Entire scope: The search will start from the beginning of
     the text.

   * Direction - Forward: The search is performed advancing in the text.

   * Direction - Backward: The search is performed going backwards in the
     text. This process is slower than a forward search. Additionally some
     regular expression searchs could fail when doing it, in particular
     when the expression searchs at the beggining or the end of the line.

The regular expressions search is slow and this can be noticed in large
files. Don't use it if the search can be done without it. The editor will
automatically disable the regular expressions search if the `Text to find'
contains only alphanumeric characters. This can be disabled *Note Regular
Expressions Options::.

To repeat the search use the `Search again' command. *Note Search again::.

Name of the command: cmcFind.
Assigned key: `^Q-F'

* Menu:

* Regular Expressions Options::


File: editor.inf,  Node: Regular Expressions Options,  Prev: Find,  Up: Find

5.3.1.1 Regular Expressions Options
...................................

This dialog is accessed from the `RegEx Ops' button in the Find or Replace
dialogs. Here you can indicate some important options about the regular
expressions:

RegEx style:

   * Basic POSIX: old style POSIX regular expressions.

   * Extended POSIX: new style POSIX regular expressions.

   * Perl Compatible: Perl like regex, using the PCRE library.

Replace text:

   * Normal text: the match is replaced by the text in the replace text
     area.

   * Dollar tags: the text to replace is parsed searching for `$n' tags.
     These markers are replaced by the correspondent subexpression. If you
     know Perl that's just like using the $0, $1, `etc.' after a search.
     If you never used Perl and don't know what a subexpression is, just
     play a little and you'll get the idea; use $n where n is the desired
     subexpression.

Optimize:

   * Try to use normal search: if the editor detects that the search string
     contains plain text will use a simple search even when regular
     expressions are enabled. That's about ten times faster.

   * Ever use RegEx: the editor doesn't try to be smart and always uses
     what you selected.

For more information about regular expressions *Note Regular Expressions::.


File: editor.inf,  Node: Replace,  Next: Search again,  Prev: Find,  Up: Search

5.3.2 Replace
-------------

This command searches portions of text and replaces it with another text.
The options for the search are the same as in the `Find' command.  *Note
Find::. The additional replace options are:

   * New text: The text used to replace the matching text.

   * Prompt on replace: When this option is enabled the editor asks for
     confirmation before doing the replace.

   * Replace all: Use it to replace all the possible ocurrences.

To repeat the search use the `Search again' command. *Note Search again::.

Name of the command: cmcReplace.
Assigned key: `^Q-A'


File: editor.inf,  Node: Search again,  Next: Name current function,  Prev: Replace,  Up: Search

5.3.3 Search again
------------------

This option repeats the last search.

Name of the command: cmcSearchAgain.
Assigned key: `^L'


File: editor.inf,  Node: Name current function,  Next: Jump to function,  Prev: Search again,  Up: Search

5.3.4 Name current function
---------------------------

It shows the name of the function at the position of the cursor in the
status line of the window. It has the same limitations of the `Jump to
function' option. *Note Jump to function::.

Name of the command: cmcWhichFunctionIs.
Assigned key: `'


File: editor.inf,  Node: Jump to function,  Next: Jump to prototype,  Prev: Name current function,  Up: Search

5.3.5 Jump to function
----------------------

his option opens a dialog with the list of functions in your source file
you can choose to jump to. The functions are searched in the source file
so you don't need to compile it. As the parser uses heuristics it may
fail. For an option that uses a more reliable but also slower and
complicated search see the `Jump to symbol' option.  *Note Jump to
symbol::.

The `Browse' button sends the list of functions to the message window so
you can browse the list and visit each function. *Note Message Window::.

Currently only a few languages are supported, they are:

   * C/C++

   * Clipper 5.x

   * Perl

   * Syntax Highlight Files

   * Texinfo sources (chapters, sections, `etc.')

   * Assembler files (labels)

   * PHP

   * Python

   * VHDL

   * PMacros file

In C sources fails are common if your code has an unbalanced number of
curly brackets. Here is a piece of code that made the heuristic get lost:

     #ifndef MSI_USE_GETDELIM
        if (readPipe(textMsgPipe, id, buf, maxLen))
        {
           *buflen = strlen(buf);
     #else
        if ((bytes = readPipe(textMsgPipe, id, buf)) > 0)
        {
           *buflen = bytes - 2;
     #endif
         ....
        }

Here the editor saw two open curly brackets but only one close bracket.
To avoid this you should add:

         ....
     #ifndef MSI_USE_GETDELIM
        }
     #else
        }
     #endif

Currently the parser tries to be smart and only check half of the sequence,
just like if all `#if' conditions were true. It means the parser won't get
lost with this specific problem, but very complex situations may break it
nonetheless.

Name of the command: cmcJumpToFunction.
Assigned key: `Alt+F2'


File: editor.inf,  Node: Jump to prototype,  Next: Jump to symbol,  Prev: Jump to function,  Up: Search

5.3.6 Jump to prototype
-----------------------

This option pops up a dialog with the list of C function prototypes in your
source file. You can then choose one to jump to. The prototypes are
searched in the source file so you don't need to compile it. As the parser
uses an heuristic approach it may fail, especially if your code has an odd
number of curly brackets.

Name of the command: cmcJumpToPrototype.


File: editor.inf,  Node: Jump to symbol,  Next: Go to line,  Prev: Jump to prototype,  Up: Search

5.3.7 Jump to symbol
--------------------

This option uses `TAGS' files to search for symbols. In order to make it
work you should read about `TAGS' files first. The editor will try to help
you to generate the `TAGS' file if you don't have one.  *Note TAGS files::.

The word to the left of the cursor will be used to start a search in the
list of available symbols. You can make incremental searches in the list
and pressing <Enter> the editor will jump to the symbol.

More about tags? *Note TAGS files::.

Name of the command: cmeSearchTag.
Assigned key: `Ctrl+F2'


File: editor.inf,  Node: Go to line,  Next: Class browser,  Prev: Jump to symbol,  Up: Search

5.3.8 Go to line
----------------

Allows you to indicate to which line you want to jump to.

Name of the command: cmcGotoEditorLine.
Assigned key: `^J'


File: editor.inf,  Node: Class browser,  Next: Word completion,  Prev: Go to line,  Up: Search

5.3.9 Class browser
-------------------

This option uses `TAGS' files to search for symbols. In order to make it
work you should read about `TAGS' files first. The editor will try to help
you to generate the `TAGS' file if you don't have one.  *Note TAGS
files::.^

First the editor will create an index of available classes from the `TAGS'
files and then will do a search using the word to the left of the cursor.
If an exact match was found the editor will go directly to browse this
class, otherwise you'll get a list of available classes to choose one.
You can make incremental searches in this list typing the first letters of
the class name.

The main browser dialog contains three buttons offering different
information about the selected class. They are:

   * This class: shows a list of the members for this class. You can select
     any of them to jump to the member code or go back to the main dialog.

   * This and parents: shows a list of the members for this class and all
     the parent classes. The members for this class are first, then come
     the members of the parents, then the members of the grandparents and
     so on.  The information is more compact and you'll only see the name
     of the class where the member was found and the level (one for the
     parent, two for grandparents, `etc.').

   * Sorted: This option is the same as the previous but the list is
     alphabetically sorted.

In addition to these buttons you'll see a list of parent and child classes.
Selecting a class from those lists and pressing the corresponding button
you can browse the selected class.

More about tags? *Note TAGS files::.

Name of the command: cmeClassBrowser.


File: editor.inf,  Node: Word completion,  Next: Jump to last cursor position,  Prev: Class browser,  Up: Search

5.3.10 Word completion
----------------------

This option uses `TAGS' files to search for symbols. In order to make it
work you should read about `TAGS' files first. The editor will try to help
you to generate the `TAGS' file if you don't have one.  *Note TAGS files::.

The word to the left of the cursor is used to perform a search in the list
of available symbols. If a partial match is found a list of available
symbols will pop-up. To select the symbol you want you can use the arrow
cursors or continue typing until you reach the desired symbol. When you
type <Enter>, <Space> or any symbol the select word will be inserted
completing the word. Pressing <Esc> or <Tab> will abort the process.

More about tags? *Note TAGS files::.

Name of the command: cmeWordCompletion.
Assigned key: `Alt+Right'


File: editor.inf,  Node: Jump to last cursor position,  Next: Jump to last undo position,  Prev: Word completion,  Up: Search

5.3.11 Jump to last cursor position
-----------------------------------

This command moves the cursor to the position it was before the last
movement. You can use it to go back after a search.

Name of the command: cmcJumpLastCursorPos.
Assigned key: `Ctrl+Q-P'


File: editor.inf,  Node: Jump to last undo position,  Prev: Jump to last cursor position,  Up: Search

5.3.12 Jump to last undo position
---------------------------------

This command moves the cursor to the position it was before the last
movement sequence. This is equivalent to undo the last group of movements.

Name of the command: cmcLastPosCur.


File: editor.inf,  Node: Macro,  Next: Rectangle,  Prev: Search,  Up: Pull-down menues

5.4 Macro
=========

This submenu has the options to record and replay macros.

* Menu:

* Record (Macro)::
* Stop (Macro)::
* Play (Macro)::
* Choose (Macro)::
* Repeat (Macro)::
* Generate Code::
* Run selected code::
* Enter code to run::
* Pseudo Macro (menu)::


File: editor.inf,  Node: Record (Macro),  Next: Stop (Macro),  Prev: Macro,  Up: Macro

5.4.1 Record (Macro)
--------------------

Starts recording all the operations you do in the current editor window.

Name of the command: cmcRecordMacro.
Assigned key: `Shift+F10'


File: editor.inf,  Node: Stop (Macro),  Next: Play (Macro),  Prev: Record (Macro),  Up: Macro

5.4.2 Stop (Macro)
------------------

Stops the macro recording.

Name of the command: cmcStopMacro.
Assigned key: `Alt+F10'


File: editor.inf,  Node: Play (Macro),  Next: Choose (Macro),  Prev: Stop (Macro),  Up: Macro

5.4.3 Play (Macro)
------------------

Replays the saved macro. A macro saved in one window can be used in
another.

Name of the command: cmcPlayMacro.
Assigned key: `^F10'


File: editor.inf,  Node: Choose (Macro),  Next: Repeat (Macro),  Prev: Play (Macro),  Up: Macro

5.4.4 Choose (Macro)
--------------------

This option lists all the available `sLisp macros' so you can choose one
to execute.

To learn more about these macros: *Note sLisp macros::.

Name of the command: cmcChooseMacro.


File: editor.inf,  Node: Repeat (Macro),  Next: Generate Code,  Prev: Choose (Macro),  Up: Macro

5.4.5 Repeat (Macro)
--------------------

It re-runs the last selected macro. *Note Choose (Macro)::. That's useful
if the macro isn't assigned to a key and you need to use it several times.

To learn more about these macros: *Note sLisp macros::.

Name of the command: cmcRepeatMacro.
Assigned key: `Shift+F3'


File: editor.inf,  Node: Generate Code,  Next: Run selected code,  Prev: Repeat (Macro),  Up: Macro

5.4.6 Generate Code
-------------------

This option translates the recorded macro into an `sLisp macro'. The
generated code is inserted at the cursor's position.

To learn how to record a macro: *Note Record (Macro)::.

To learn more about these macros: *Note sLisp macros::.

Name of the command: cmcGenCodeForMacro.


File: editor.inf,  Node: Run selected code,  Next: Enter code to run,  Prev: Generate Code,  Up: Macro

5.4.7 Run selected code
-----------------------

It interpretes the selected text as an sLisp macro.

Name of the command: cmcRunSel_sLisp.


File: editor.inf,  Node: Enter code to run,  Next: Pseudo Macro (menu),  Prev: Run selected code,  Up: Macro

5.4.8 Enter code to run
-----------------------

It asks for a text and interpretes it as an sLisp macro. The maximum
length is one kilobyte.

Name of the command: cmcRunEnter_sLisp.


File: editor.inf,  Node: Pseudo Macro (menu),  Prev: Enter code to run,  Up: Macro

5.4.9 Pseudo Macro (menu)
-------------------------

It shows a list of all the pseudo macros available for the current syntax
highlighting mode. The purpose of this option is just to show you what's
available; of course you can choose any from the list but that's much
slower than using them directly.

The letters enclosed in brackets are the triggers for the pseudo macro. To
learn more about pseudo macros: *Note Pseudo Macros::.

Name of the command: cmcChoosePMacrosList.


File: editor.inf,  Node: Rectangle,  Next: Windows,  Prev: Macro,  Up: Pull-down menues

5.5 Rectangle
=============

This menu contains the rectangular block operations. As they are a bit
hard to code and these functions are normally ignored by the users, I put
them in a very visible menu.

* Menu:

* Start (Rectangle)::
* End (Rectangle)::
* Hide (Rectangle)::
* Copy (Rectangle)::
* Copy to clipboard (Rectangle)::
* Paste (Rectangle)::
* Paste from clipboard (Rectangle)::
* Cut (Rectangle)::
* Delete (Rectangle)::
* Move (Rectangle)::
* Copy and Paste (Rectangle)::
* Clear (Rectangle)::
* To upper (Rectangle)::
* To lower (Rectangle)::


File: editor.inf,  Node: Start (Rectangle),  Next: End (Rectangle),  Prev: Rectangle,  Up: Rectangle

5.5.1 Start (Rectangle)
-----------------------

Selects the top-left corner of the rectangular area.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectStart.
Assigned key: `^K-Shift+B'


File: editor.inf,  Node: End (Rectangle),  Next: Hide (Rectangle),  Prev: Start (Rectangle),  Up: Rectangle

5.5.2 End (Rectangle)
---------------------

Selects the bottom-right corner of the rectangular area.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectEnd.
Assigned key: `^K-Shift+K'


File: editor.inf,  Node: Hide (Rectangle),  Next: Copy (Rectangle),  Prev: End (Rectangle),  Up: Rectangle

5.5.3 Hide (Rectangle)
----------------------

Hides the rectangular selection.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectHide.
Assigned key: `^K-Shift+H'


File: editor.inf,  Node: Copy (Rectangle),  Next: Copy to clipboard (Rectangle),  Prev: Hide (Rectangle),  Up: Rectangle

5.5.4 Copy (Rectangle)
----------------------

Copies the rectangular selection into the clipboard. This clipboard isn't
the same clipboard used by the normal selections and is overwritten each
time you copy to it.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectCopy.
Assigned key: `^K-Shift+C'


File: editor.inf,  Node: Copy to clipboard (Rectangle),  Next: Paste (Rectangle),  Prev: Copy (Rectangle),  Up: Rectangle

5.5.5 Copy to clipboard (Rectangle)
-----------------------------------

Copies the rectangular selection into the regular clipboard.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectCopyClip.
Assigned key: `^K-Ctrl+Insert'


File: editor.inf,  Node: Paste (Rectangle),  Next: Paste from clipboard (Rectangle),  Prev: Copy to clipboard (Rectangle),  Up: Rectangle

5.5.6 Paste (Rectangle)
-----------------------

Inserts the contents of the rectangular clipboard at the cursor position.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectPaste.
Assigned key: `^K-Shift+P'


File: editor.inf,  Node: Paste from clipboard (Rectangle),  Next: Cut (Rectangle),  Prev: Paste (Rectangle),  Up: Rectangle

5.5.7 Paste from clipboard (Rectangle)
--------------------------------------

Inserts the contents of the regular clipboard at the cursor position. If
the current content isn't a rectangle spaces are added to make it
rectangular.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectPasteClip.
Assigned key: `^K-Shift+Insert'


File: editor.inf,  Node: Cut (Rectangle),  Next: Delete (Rectangle),  Prev: Paste from clipboard (Rectangle),  Up: Rectangle

5.5.8 Cut (Rectangle)
---------------------

Copies the rectangular selection into the clipboard and then deletes the
selected text.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectCut.
Assigned key: `^K-Shift+T'


File: editor.inf,  Node: Delete (Rectangle),  Next: Move (Rectangle),  Prev: Cut (Rectangle),  Up: Rectangle

5.5.9 Delete (Rectangle)
------------------------

Deletes the selected text.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectDel.
Assigned key: `^K-Shift+L'


File: editor.inf,  Node: Move (Rectangle),  Next: Copy and Paste (Rectangle),  Prev: Delete (Rectangle),  Up: Rectangle

5.5.10 Move (Rectangle)
-----------------------

Moves the selected text to the cursor's position.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectMove.
Assigned key: `^K-Shift+M'


File: editor.inf,  Node: Copy and Paste (Rectangle),  Next: Clear (Rectangle),  Prev: Move (Rectangle),  Up: Rectangle

5.5.11 Copy and Paste (Rectangle)
---------------------------------

Copies the selected text to the special clipboard and then pastes it at the
cursor location. This is a combination of the copy and paste operations.
*Note Copy (Rectangle)::. *Note Paste (Rectangle)::.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectCopyPaste.
Assigned key: `^K-Shift+O'


File: editor.inf,  Node: Clear (Rectangle),  Next: To upper (Rectangle),  Prev: Copy and Paste (Rectangle),  Up: Rectangle

5.5.12 Clear (Rectangle)
------------------------

Replaces the selected area by spaces.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectClear.
Assigned key: `^K-Shift+E'


File: editor.inf,  Node: To upper (Rectangle),  Next: To lower (Rectangle),  Prev: Clear (Rectangle),  Up: Rectangle

5.5.13 To upper (Rectangle)
---------------------------

Converts all the characters inside the rectangle to uppercase. This
operation basically does a cut of the block, then processes all the
characters and finally makes a paste of the modified block. As a side
effect of this operation tabs inside or crossing the rectangle boundaries
are converted to spaces.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectToUpper.


File: editor.inf,  Node: To lower (Rectangle),  Prev: To upper (Rectangle),  Up: Rectangle

5.5.14 To lower (Rectangle)
---------------------------

Converts all the characters inside the rectangle to lowercase. This
operation basically does a cut of the block, then processes all the
characters and finally makes a paste of the modified block. As a side
effect of this operation tabs inside or crossing the rectangle boundaries
are converted to spaces.

To learn more about rectangular blocks: *Note Rectangular Blocks::.

Name of the command: cmcSelRectToLower.


File: editor.inf,  Node: Windows,  Next: Tool&Ops,  Prev: Rectangle,  Up: Pull-down menues

5.6 Windows
===========

This menu contains the options to handle the windows in the editor.

* Menu:

* Size/move::
* Zoom::
* Tile::
* Cascade::
* Next (Window)::
* Previous (Window)::
* Close::
* List::
* User Screen::


File: editor.inf,  Node: Size/move,  Next: Zoom,  Prev: Windows,  Up: Windows

5.6.1 Size/move
---------------

You can resize the windows by dragging the bottom right corner of the
window.  You can move the windows by dragging the title line of the window.

Additionally this command allows the same operations to be done without the
mouse. Once you entered in this mode the border of the window changes it's
color and you can move the window using the arrow keys. To resize the
window use the arrow keys holding the <Shift>. Furthermore <Home>, <End>,
<PgUp> and <PgDown> can be used to move the window to one end of the
desktop. When you're done you can end this mode by pressing <ESC> or
<ENTER>.

Name of the command: cmeResize.
Assigned key: `^F5'


File: editor.inf,  Node: Zoom,  Next: Tile,  Prev: Size/move,  Up: Windows

5.6.2 Zoom
----------

Changes the size of the window to be as large as the whole desktop. The
second time you use this command the window is resized to it's previous
size.  It's the equivalent of the maximize and restore options of other
editors.

Name of the command: cmeZoom.
Assigned key: `F5'


File: editor.inf,  Node: Tile,  Next: Cascade,  Prev: Zoom,  Up: Windows

5.6.3 Tile
----------

Arranges all the windows in a way that you can see all at the same time.

Name of the command: cmeTile.


File: editor.inf,  Node: Cascade,  Next: Next (Window),  Prev: Tile,  Up: Windows

5.6.4 Cascade
-------------

Arranges all the windows in such a way that they overlap.

Name of the command: cmeCascade.


File: editor.inf,  Node: Next (Window),  Next: Previous (Window),  Prev: Cascade,  Up: Windows

5.6.5 Next (Window)
-------------------

Selects the next window. The windows are linked in a circular list, this
command selects the next window in the list. To change the order of the
windows you can directly select a window with the mouse or <ALT> plus a
number. That window will become the current one, and the other will be the
`previous' window.

Use it to select the most recently used windows.

Name of the command: cmeNext.
Assigned key: `F6'


File: editor.inf,  Node: Previous (Window),  Next: Close,  Prev: Next (Window),  Up: Windows

5.6.6 Previous (Window)
-----------------------

Selects the previous window. The windows are linked in a circular list,
this command selects the previous window in the list. To change the order
of the windows you can directly select a window with the mouse or <ALT>
plus a number. That window will become the current one, and the other will
be the `previous' window.

Use it to select the most recently used windows.

Name of the command: cmePrev.
Assigned key: `Shift+F6'


File: editor.inf,  Node: Close,  Next: List,  Prev: Previous (Window),  Up: Windows

5.6.7 Close
-----------

Closes the current window. If the content wasn't saved the editor will ask
if you want to.

Name of the command: cmeClose.
Assigned key: `Alt+F3'


File: editor.inf,  Node: List,  Next: User Screen,  Prev: Close,  Up: Windows

5.6.8 List
----------

Pops up the List of Windows dialog. This dialog contains the list of all
the editor windows, the special windows and the closed windows.

The editor windows are numbered starting from two and the list is sorted by
number. If a window isn't saved an asterisk is placed between the number
and the name.

The special windows are: the message window (the number of lines is
indicated), the project window, the clipboard window (the bytes used by it
is indicated) and the InfView windows.

The closed windows list is sorted alphabetically and holds the last closed
windows. The editor stores important information about these windows so if
you close and re-open one of them the size of the window and other values
are restored.

You can jump to any of the windows by selecting it with the mouse, with
the arrow keys and <ENTER>, double clicking, or by using the `Go' button.

A press of <Delete> or using the `Delete' button will delete the closed
windows or close any open editor window.

Using the `ReEnumerate' button you can force to compute the window numbers
so all become continuous.

Name of the command: cmeListWin.
Assigned key: `Alt+0'


File: editor.inf,  Node: User Screen,  Prev: List,  Up: Windows

5.6.9 User Screen
-----------------

Shows the DOS screen. Press any key to go back to the editor.

Name of the command: cmeUserScreen.
Assigned key: `Alt+F5'


File: editor.inf,  Node: Tool&Ops,  Next: Project,  Prev: Windows,  Up: Pull-down menues

5.7 Tool&Ops
============

This menu contains all the configuration submenues and some useful tools.

* Menu:

* Options::
* Calculator (command/menu)::
* SDG::
* Run program::
* Grep::
* HTML Accents::
* Export as HTML::
* Insert key name::
* Remap code page::
* Profile Editor::
* Redraw screen::
* Paste Emacs mode::
* Block quoted printable decode::
* Un/Indent block::
* Delete memorized backups::


File: editor.inf,  Node: Options,  Next: Calculator (command/menu),  Prev: Tool&Ops,  Up: Tool&Ops

5.7.1 Options
-------------

This submenu contains the configuration submenues. You can find the local
and global edition options in the Edit menu. *Note Edit::.

Some of the deeper submenues are explained here because the documentation
tools limit how deep subsections can be nested.

* Menu:

* Customize Colors::
* Color Palette::
* Color Theme::
* Editor General::
* Check for modified files::
* Screen Saver::
* SDG Options::
* Run program (which one)::
* Keyboard::
* Key assignment::
* Setup Alt keys::
* Key pad behavior::
* Back to defaults::
* Consult scan codes::
* Screen Options::
* Encodings::
* Fonts::
* User Words::
* Default global edition::
* File open dialog::
* Do not create backups for::
* Search files under cursor in::
* List of tag files::
* Tag files options::
* Regenerate central file::
* Calendar options::
* Advice dialogs::


File: editor.inf,  Node: Customize Colors,  Next: Color Palette,  Prev: Options,  Up: Options

5.7.1.1 Customize Colors
........................

This command allows to customize the colors used by the editor. Almost all
the colors are configurable.

The first list, called `Group', is the list of things used by the editor.
Each entry in the group list has one or more colors in the `Item' list.
First select the group you want to customize and then press <Tab> to move
the cursor to the items list. To customize a color just select it in the
list of items; the dialog will show a text example in the bottom right
corner and the `Foreground' and `Background' colors will be indicated.
Using the mouse or moving with <Tab> and using the arrow keys you can
select any of the available colors; the sample text area will show the
resulting combination.

Exiting the dialog with <ENTER> or with the `Ok' button the new colors
will be applied. The colors are stored in the desktop file. If you are
using one centralized desktop file these colors will be used each time you
run the editor, if not the colors will be used only when you run the
editor in that very same directory.

To learn more about the scope of the desktop files and how to indicate
default values: *Note Desktop Files::.

If you want to use other colors not listed in this dialog you must
customize the palette. *Note Color Palette::.

Name of the command: cmeSetColors.


File: editor.inf,  Node: Color Palette,  Next: Color Theme,  Prev: Customize Colors,  Up: Options

5.7.1.2 Color Palette
.....................

This option allows to configure the palette of colors used by the editor. I
think you know about palettes but I wrote a little explanation, just in
case. *Note Text mode attributes::.

The `Color' radio buttons are used to select the index you want to
customize. The `Red', `Green' and `Blue' scroll bars can be used to
customize the color. To modify one of the components use the mouse or use
the <R>, <G> and <B> to increase the values and <Shift>+<R>, <Shift>+<G>
and <Shift>+<B> to decrease the values.

Exiting the dialog with <ESC> restores the values you had before selecting
this option. Choosing the `Default' button the colors are set to the
default values of VGA cards.

These settings are stored in the desktop file. *Note Desktop Files::.

Name of the command: cmeEditPalette.


File: editor.inf,  Node: Color Theme,  Next: Editor General,  Prev: Color Palette,  Up: Options

5.7.1.3 Color Theme
...................

With this option you can choose from a list of predefined groups of colors.

Currently only a couple of color themes are available, users are
encouraged to contribute their own themes.

Name of the command: cmeColorTheme.


File: editor.inf,  Node: Editor General,  Next: Check for modified files,  Prev: Color Theme,  Up: Options

5.7.1.4 Editor General
......................

This will open the general configuration dialog containing several options.

The `Save options' groups control various settings about which and how
files are created by the editor.

   * Make backups: When enabled the editor keeps a backup of your files
     using the `.bkp' extension. It saved me many times.

   * UNIX style backups: When enabled the backups are created appending a
     tilde symbol to the file extension. This is recommended only for
     systems that support long file names, not pure DOS.

   * Hidden backups: The backups are created as hidden files, it can be
     used to keep backups, but at the same time make them less annoying.

   * Remember bkps to delete: When you exit with `Quit' the editor deletes
     backup files. To do it the editor deletes files ending with `bkp',
     but if you use UNIX style backups or just edit files in a directory
     other than the current it's hard to know where these files are
     located. For this reason the editor keeps a list of created backup
     files.  If you exit normally this list is lost, so the next time you
     use the editor and exit with `Quit' only the backups created during
     this session will be deleted. This behavior can be modified choosing
     this option, when enabled the editor will store the list in the
     desktop file and retrieves it the next time you start the editor. By
     default this option is disabled because users that don't know about
     this mechanism and use a centralized desktop file could end up with a
     very long list of backup files, wasting memory and disk space.

   * Don't create desktop files: When enabled the editor creates only one
     desktop file and not one per directory. *Note Desktop Files::.

   * Save desktop files hidden: Just what the name says. That's useful if
     you want to create desktop files in each directory but don't want to
     see them in directory listings.

   * Tile windows vertically first: It affects the `Windows|Tile' option.
     Normally this option starts splitting the screen by dividing the
     height of windows. When this option is selected the width is divided
     first.

   * Save UNIX files as UNIX: When enabled the editor saves to disk UNIX
     files in UNIX format. That means that the conversion is done only
     internally and the format of the file on disk isn't altered when you
     save.

   * Do not remember cursor position: If you enable it the editor won't
     remember the last cursor position of each editor window.

   * Do not warn about read-only files: It disables the dialog that warns
     about opening read-only files. Disabling it you won't be asked about
     reverting the read-only attribute until you try to save the file.

   * Open read-only files as R.O. buffers: When enabled the editor won't
     allow you to edit files with the read-only attribute. Note: it
     doesn't disable the warning, use the above mentioned option for this.

   * Autosave project: When enabled the project is saved after any
     modification. It happends during the idle time.

In the open, save, `etc.' dialogs you can sort backup files in a special
way so they don't interfere with the rest of the files.  *Note File open
dialog::.
You can also configure the editor to avoid creating backup files for some
particular filenames or directories. *Note Do not create backups for::.

The `Clock' group allows to turn on/off the clock and to choose 24 hs or
AM/PM style. The clock is displayed in the top right corner of the screen.

The `Max. editor copies' controls how many copies of the same file can be
opened at the same time. By default the value is one, so when you try to
open a file twice the editor will just show you the first copy. Specifying
a value different than one will allow you to open more copies of the same
file. Only the first copy can be modified and the rest are read-only
snap-shots of the file. Note it only affects the number of read-only
copies automatically created by the editor, you can open as many as you
want using the `File | Open Read-only copy' menu option. For more
information: *Note Open Read-only copy::.

The `Max. closed to remember' value specifies how many closed files are
remembered in the list of windows. This value can't be less than three and
can't be greater than two hundred. If you reduce this value and there are
already more files remembered the editor won't reduce the number
immediately, instead you must choose which files to remove by hand.

The `+ Desktop' button opens a second dialog containing options about what
is stored in the desktop files. Each section selects if the option will be
remembered always (ever), only when no files are specified in the command
line or never.

   * Remember editor windows: it affects the opened files.

   * Remember other windows: it affects other windows, like the help
     windows.

   * Remember closed windows: it affects the list of closed files.

The second dialog contains a button to return to the first dialog.

The `+ Others' button opens a third dialog containing options to configure
the behavior of the message window when the last or first error in the
list is reached.

   * Just stop: nothing particular is done, the editor just stops.

   * Indicate with a message: a message indicating you reached the first
     or last pops up.

   * Wrap (circular list): the list becomes a circular list. So when you
     reach the last message the editor jumps to the first and `vice versa'.

   * Make a beep: a sound is generated.

Additionally you can choose if you want project and message windows to be
vertically or horizontally oriented in this dialog.

   * Use the vertical direction: message and project windows are vertically
     oriented. By default they are positioned at the left side. When this
     option is selected the project window has only one column.

   * Use the right side: use the right side of the screen instead of the
     left side. That's used only when the direction is vertical.

One important detail is that this options affects the size of newly opened
files. If you already opened windows in this project the editor will have
them memorized. So you should set up this options before creating a
project.

To control the size of the windows when you open a new file you have two
options.

   * Use reserved width or 7 (hz dir): In this case the editor will make
     windows smaller than the desktop by substracting the value entered in
     reserved width, for vertical direction projects, or a fixed ammount
     of seven for horizontal direction projects.

   * Avoid message and project windows: When selected the editor will try
     to avoid using the desktop surface used by the message and project
     windows. The size computed is the size of these windows without
     zooming. If the resulting size is too small the window will overlap.

This dialog also has a button to go back to the main dialog.

These settings are stored in the desktop file. *Note Desktop Files::.

Name of the command: cmeEdGralOptions.


File: editor.inf,  Node: Check for modified files,  Next: Screen Saver,  Prev: Editor General,  Up: Options

5.7.1.5 Check for modified files
................................

When you edit a file the editor uses a copy of this file stored on memory.
The copy on disk can be changed by another user or by a program. If it
happends you can be working on a different file and you'll destroy those
changes when saving. For this reason the editor must check if the
modification time of the file changed. The editor does this check when:

  1. You run an external program. This program could generate some output
     file and it could be one of the opened files.

  2. You select an editor window. This is done in the `idle loop', so this
     check could be delayed a fraction of a second.

  3. Periodically for the focused file.

The configuration dialog can be used to disable or fine tune these checks.
The `Seconds between checks' option refers to the periodical checks.  The
other options are:

   * Don't check after executing an external program. It disables the
     checks done after running an external program.

   * Don't check while idle. It disables the the checks done periodically
     and also the checks done when you select a an editor window. That's
     because both are done when the editor have some free time.

When the editor detects a file on disk is newer than the file on memory a
dialog asking if you want to load the new file pops up. This question will
be done only once and no matters what you answer the editor will asume the
problem is solved. This is to avoid an endless storm of questions.

If you choose to load the file from disk the editor will check if the
memory copy is also modified. In this case a collision between your
changes and the external changes can lose data. For this reason the editor
offers four options:

  1. Load file from disk (discard changes): This is the default action, use
     it if you want to get a fresh copy discarding any changes done in
     memory.

  2. Abort operation: The editor does nothing and you must solve the
     problem manually.

  3. Load and show differences: This is like the first option, but the
     editor will invoke `diff' and load it's output. You can analize the
     differences between your changes and the external changes to solve the
     problem.

  4. Don't load and show differences: This is like the second option, but
     the editor invokes `diff' like in the third.

The last two options are offered only if GNU diff is installed in your
system. You can get GNU diff from the GNU site (http://www.gnu.org/).

Note that when the editor offers a diff output this is loaded from a
temporal file that is discarded as soon as loaded. For this reason the
editor marks this window as read only. If you want to use this file to as
input for `patch' just use the `Save As' option.

Name of the command: cmeSetModiCkOps.


File: editor.inf,  Node: Screen Saver,  Next: SDG Options,  Prev: Check for modified files,  Up: Options

5.7.1.6 Screen Saver
....................

This dialog customizes the screen saver. Note the question mark at the end
of the term "screen saver" I did it because the plasma screen saver isn't
too good to be used as a real saver for your screen.  You can enable or
disable, choose the time the editor will wait before starting the screen
saver and the screen saver style. The Test button can be used to see how
the screen saver looks like.

If you leave the mouse pointer in the upper right corner of the screen for
a few seconds the screen saver is activated. This time is three seconds by
default and can be configured entering the amount of seconds in the second
box labeled `Time'.

Two types of screen savers are supported: internal and external. Internal
screen savers are hardcoded in the editor. External screen savers are
external programs started by the editor. If you select an external screen
saver from the list the Info and Help buttons are enabled. Pressing these
buttons you can get more information about the screen saver. You can pass
additional parameters to the external screen saver filling the `External
Saver' box.

If you want to write your own screen saver please download the sources of
the editor and read the explanations found in the `scrnsave' directory. An
external screen saver is basically a simple program that supports some
special command line options and returns some specified return values.

Name of the command: cmeScreenSaverOpts.


File: editor.inf,  Node: SDG Options,  Next: Run program (which one),  Prev: Screen Saver,  Up: Options

5.7.1.7 SDG Options
...................

These options customize the SDG module (SET's Documentation Generator).
see *note SDG Documentation: (SDG)Top.

   * Format file: Indicates the name of the format file used to generate
     the documentation.

   * Intermediate file: The name of the temporal file used in the process.

   * Base output: The base name of the output file. Doesn't include the
     extension.

   * Directory of formats: The place where the editor will search for the
     format file.

   * Keep intermediate: When enabled the temporal file isn't deleted, so
     you can see possible errors in it.

The SDG module uses the files listed in the project to collect the
documentation from the comments. *Note Project::.

These settings are stored in the desktop file. *Note Desktop Files::.

Name of the command: cmeSDGDialog.


File: editor.inf,  Node: Run program (which one),  Next: Keyboard,  Prev: SDG Options,  Up: Options

5.7.1.8 Run program (which one)
...............................

The editor can run an external program and collect the errors reported by
it if you press the shortcut (`^F9'). A good example is the make program.
Here you can select the name of the program. If you need to run more than
one command separate it with `;'.

The editor will redirect the stderr (standard error output) and stdout
(standard output) of the program and then will analize it looking for
errors.  The dialog includes a list of parsing algorithms to analize the
errors from the external program. To learn how to configure the editor for
other formats or just fine tune any of them *Note Error messages from an
external application::.

The other options found in this dialog are a little bit complex. Here I'll
try to explain each of these options but I recommend to just try them to
see how they work.

Option `Use OS screen to run the program': The editor will try to restore
the contents of the screen. So it will look like as it was before running
the editor. Meaning the program will be executed and the editor will redraw
all the contents of the desktop and windows afterwards. This mechanism is
useful when the program you want to run is interactive or doesn't use the
standard output. Is important to understand that on some platforms and
terminals the editor can't restore the contents of the screen and will just
clean it to the grey over black color. It's also important to understand
that when this option is enabled the program can't be executed in
multitasking mode; it means the option `Don't try to run in background'
will be implicitly selected.

Option `Don't try to run in background': On some platforms (currently only
Linux) the editor can execute the external program as a child process. It
means the program will execute in parallel with the editor (in background).
When the editor does this you'll see the message window indicate the
program is running but won't say when you are back in the editor. Instead
the output of the external program will start to fill the message window.
You can select any other window and continue working while the external
program runs.  When the external program ends the editor will also collect
the rest of the messages and errors in the background. While the editor is
running the external program and/or parsing the remaining messages the
status bar will show an option `Ctrl+C Stop'; clicking on it or pressing
the indicated key the editor will stop the background process and will
also stop collecting messages. The purpose of this option: When this
option is enabled the editor won't try to run the external program in
parallel even if the platform supports it. That's faster, but if the
external program is slow you'll be forced to wait until it finishes and you
won't be able to stop the program from the editor.

Option `Always parse in background': If enabled the editor will collect the
messages and errors in the background even if the platform doesn't support
the execution of the external program in the background. On platforms that
don't support the execution of the external program as a thread the editor
will block until the external program ends and then will parse the
messages and errors in the background. This is useful when the amount of
messages and errors is big and the parsing will take a long time. In this
way you can continue working while the editor does this job. You must
understand that's even slower but you can at least use the time for
reading or editing text.

Option `Jump to the first error': If enabled the editor jumps to the file
and line of the first error reported by the external program.

Option `Don't redirect stdout': Complements the `Use OS screen to run the
program' option. When enabled the editor collects errors only from the
standard error and not from the standard output. This is useful for
interactive applications that sends its output to the standard output.

The `Message window scroll' group of options are mutually exclusive and
give some control over the behavior of the message window. When you start
executing the external program the message window will automatically get
the focus. As messages and errors are added to this window the window
scrolls and shows the last message. When the external program finishes and
the editor parses all the messages and errors the message window will get
the focus again. Finally, if the editor found errors, the message window
will scroll to the first line. This is the default behavior and you'll be
able to see each of this steps only if the editor is running the external
program in the background and/or parsing the messages and errors in the
background. This behavior corresponds to the `Ever' (always) option. If
you select the `Never' option the editor won't scroll the message window.
In this case you can browse the messages even while the editor is
collecting them. Finally you can choose `Only if not focused'. In this
case you'll be able to browse the messages when the message window is
selected, but if you select an other window the editor will start to
scroll the message window. The fastest option is `Never' but then you
won't see if the external program finished executing, unless you have the
message window selected all the time.

The `Lines per pass' option is associated with the speed of parsing. This
option takes effect only when the messages and errors are parsed in the
background. What this option indicates is how many lines of messages and
errors will be parsed before releasing the CPU. A bigger value will make
the parsing faster but will make the editor slower and you'll start having
problems to select windows and write text. You must experiment with this
parameter. On my machine a value of 20 is acceptable.

All of these settings are stored in the desktop file. *Note Desktop
Files::.

For more information about the behavior of the message window *Note
Message Window::.

Name of the command: cmeConfRunCommand.


File: editor.inf,  Node: Keyboard,  Next: Key assignment,  Prev: Run program (which one),  Up: Options

5.7.1.9 Keyboard
................

This is a submenu but due to limitations in the documentation tools I was
forced to put it with the rest of the options listed in the `Options'
submenu.

It contains all the options to customize the keyboard.


File: editor.inf,  Node: Key assignment,  Next: Setup Alt keys,  Prev: Keyboard,  Up: Options

5.7.1.10 Key assignment
.......................

With this command you can fully customize the keys used by the editor
windows.  It doesn't include the menues, for that you must edit the
`menubind.smn' file.

To learn how to use this command consult: *Note How to configure the
keyboard::.

Name of the command: cmeEditKeyBind.


File: editor.inf,  Node: Setup Alt keys,  Next: Key pad behavior,  Prev: Key assignment,  Up: Options

5.7.1.11 Setup Alt keys
.......................

It allows you to select how the editor interpretes the left and right alt
keys. For more information: *Note Alt key configuration::.

Name of the command: cmeSetUpAltKeys.


File: editor.inf,  Node: Key pad behavior,  Next: Back to defaults,  Prev: Setup Alt keys,  Up: Options

5.7.1.12 Key pad behavior
.........................

[DOS]

Here you can choose how the keypad is interpreted by the editor. Two
options are provided. One is the BIOS default, in this mode the <NumLock>
changes between arrows and numbers. In the other mode the behavior is
similar, but holding shift and pressing a number will behave like an arrow
key shifted, that's very common in DOS applications so that's the default.

Name of the command: cmeKeyPadBehavior.


File: editor.inf,  Node: Back to defaults,  Next: Consult scan codes,  Prev: Key pad behavior,  Up: Options

5.7.1.13 Back to defaults
.........................

This option restores the default key assignments of the editor. Use it if
you messed up the keyboard configuration and you want to get back the
original values.

Name of the command: cmeKbBackDefault.


File: editor.inf,  Node: Consult scan codes,  Next: Screen Options,  Prev: Back to defaults,  Up: Options

5.7.1.14 Consult scan codes
...........................

Used to consult the keyboard scan codes: *Note Consulting scan codes::.
This dialog must be closed using the mouse to press the `OK' button
because it displays the scan codes for the keys, even for <ESC> and
<ENTER>.

Name of the command: cmeSeeScanCodes.


File: editor.inf,  Node: Screen Options,  Next: Encodings,  Prev: Consult scan codes,  Up: Options

5.7.1.15 Screen Options
.......................

This command opens the screen options configuration dialog. Here you can
customize the video mode or window size. This dialog is available only when
you are running in a terminal that can control the screen size. If you are
looking for the screen saver: *Note Screen Saver::.

Not all hardware drivers support it and not all the options are usable for
all the drivers. With some you can't control the screen size, like in
Linux, in other cases you have total control, like when you run the editor
in X11, and in others you have limited control, like in DOS.

The first group of options defines how the editor will try to set the video
mode. The available options are:

   * Don't force: The editor won't try to change the screen size.

   * Same as last run: The editor will remember the last size used and
     will try to restore the closest possible size.

   * External program: It currently makes only sense in DOS. It can be
     used when you have an external program that can set the video mode
     for you.  In this case you must also indicate the command line for it
     in the External program box.

   * Closest to specified size: The editor will try to select a screen
     size that's as close to the values indicated in Width, Height, Chars
     width and Chars height boxes as possible. Note that some drivers
     support only a small set of fixed values and others have silly
     limitations imposed by the operating system.

   * Specified mode number: This is mainly for DOS. Use it if you know
     about a video mode supported by your video card that isn't known by
     the editor. In this case you must indicate the video mode number in
     the Mode number box.

Even when the video mode mechanism is for DOS you can use one of the video
modes known by the editor even when running on X11 or other terminals
where the screen size can be changed at will. The following is a list of
known video modes:

   * 0x0003
     - Width x Height: 80 x 25
        - Char Cell: 9 x 16

   * 0x0103
     - Width x Height: 80 x 28
        - Char Cell: 9 x 14

   * 0x0703
     - Width x Height: 80 x 30
        - Char Cell: 9 x 16

   * 0x0803
     - Width x Height: 80 x 34
        - Char Cell: 9 x 14

   * 0x0203
     - Width x Height: 80 x 35
        - Char Cell: 9 x 10

   * 0x0303
     - Width x Height: 80 x 40
        - Char Cell: 9 x 10

   * 0x0403
     - Width x Height: 80 x 43
        - Char Cell: 9 x  8

   * 0x0503
     - Width x Height: 80 x 50
        - Char Cell: 9 x  8

   * 0x0108
     - Width x Height: 80 x 60
        - Char Cell: 9 x  8

   * 0x0D03
     - Width x Height: 82 x 25
        - Char Cell: 8 x 16

   * 0x0903
     - Width x Height: 90 x 30
        - Char Cell: 9 x 16

   * 0x0A03
     - Width x Height: 90 x 34
        - Char Cell: 9 x 14

   * 0x0B03
     - Width x Height: 94 x 30
        - Char Cell: 9 x 16

   * 0x0C03
     - Width x Height: 94 x 34
        - Char Cell: 9 x 14

   * 0x0109
     - Width x Height: 132 x 25
        - Char Cell: 9 x 14

   * 0x010A
     - Width x Height: 132 x 43
        - Char Cell: 9 x 11

   * 0x010B
     - Width x Height: 132 x 50
        - Char Cell: 9 x 10

   * 0x010C
     - Width x Height: 132 x 60
        - Char Cell: 9 x  8


Name of the command: cmeSetScreenOps.


File: editor.inf,  Node: Encodings,  Next: Fonts,  Prev: Screen Options,  Up: Options

5.7.1.16 Encodings
..................

This dialog is used to select the encodings used by the editor. This is a
complex topic and you'll have to play a little bit with these options
before you can get all the funtionality. Usually you won't need to use it
unless you deal with more than one encoding.

Currently the editor can only use files where one letter corresponds to
just one character. It limits the editor to 256 different symbols. This is
the common case for most operating systems and environments. Which symbols
are represented by these 256 values is called an encoding.

The encodings are also known as code pages. An example of a code page is
the DOS code page 437 used by PC VGA boards or the ISO 8859-1 encoding used
by most POSIX systems as a default encoding. Currently more than 47
encodings are supported. These encodings cover the latin, cyrillic and
greek alphabets.  If your alphabet or favorite encoding isn't supported
please consider contributing.

In most cases the editor will detect the encoding currently used by the
operating system without problems. A special case is the GNU/Linux OS
where the concept of code page doesn't really exist and you can find all
kinds of errors in the fonts and unicode maps.

This dialog can have two, three or four encodings to select, they are:

   * Application: which encoding the application uses, ie. used in your
     documents.

   * Input: how the data from the keyboard is encoded. It is usually the
     same encoding used by the screen. If the application and input code
     pages don't match the editor will translate the data from the
     keyboard to the application encoding.

   * Screen: the encoding if the screen. Not all hardware drivers support
     it because some of them work with a fixed code page and this value is
     known.  Here you indicate how the font used by your hardware or OS is
     encoded. If this value doesn't match the application code page the
     editor will translate the data before sending it to the screen.

   * Second font: how the secondary font is encoded. This is available
     only when the driver supports more than one font at the same time.

If any of these settings doesn't have the Force encoding option selected
then the editor will use what was detected.

If you force the screen encoding the selected value must match the OS
encoding. The exception is when you select a font in the Fonts dialog. In
this case the editor will recode the selected font to match the encoding.
Don't forget this interaction with the Fonts dialog. *Note Fonts::.

Note that you can easily edit documents encoded in a code page different
than the one used by the OS without doing any specific recoding. Example:
if you are using X11 and the ISO 8859-1 encoding but you want to edit a DOS
file encoded using the 850 code page you just need to select the
application encoding as PC 850 and force it. Your keyboard will generate
ISO 8859-1 values, they will be translated into 850 encoding and put in
your document.  At the same time the text encoded using 850 code page will
be translated to ISO 8859-1 before displaying it.

Name of the command: cmeEncodings.


File: editor.inf,  Node: Fonts,  Next: User Words,  Prev: Encodings,  Up: Options

5.7.1.17 Fonts
..............

This dialog is used to select the fonts used by the editor. Not all
hardware drivers support custom fonts and some only support only one font.
The editor can handle up to two fonts at the same time. However, the use
of two fonts is complex.

Only the fonts marked with Load font are used, don't forget to enable it
before leaving this dialog.

The size of the fonts must be the same, that's why even on systems that
supports two fonts only one size can be selected.

The offered fonts are the ones provided by the editor and not the OS. This
is because some systems doesn't provide fonts and the systems that provide
fonts usually provides only a few fixed width fonts. The font format used
is documented in the Turbo Vision library.

The fonts marked with `limited' don't cover all the encodings supported by
the editor. *Note Encodings::.

When you load a font the encoding for this font will be the value indicated
by the screen encoding option selected in the Encodings dialog. If you
change this encoding the editor will automatically change the encoding of
the font.

Name of the command: cmeFonts.


File: editor.inf,  Node: User Words,  Next: Default global edition,  Prev: Fonts,  Up: Options

5.7.1.18 User Words
...................

This option is used to define reserved words defined by the user. A very
common use is to define `typedef's you normally use in your programs.  The
user words are language dependant. They are highlighted with a special
color different than the color used for reserved words.

The first dialog is used to select the language, the names are the ones
defined in the syntax highlighting file (*note Syntax Highlighting::).
Selecting one of the names and pressing <ENTER> pops up the second dialog.

The next dialog is used to add or remove words to the list. Pressing
<ENTER> you confirm the changes and they are saved to disk. If you exit
with <ESC> the old list is preserved.

The user words are stored in a file called `userword.txt', in the same
directory all other configuration files are stored. Such a file isn't
included in the distribution because those words must be defined by the
user. You can edit the file by hand if you want, the format is very
simple. The start of a list is marked with `.' followed by the name of the
language. The items of the list are marked with `+'. Any line starting
with a different character will be ignored during the parsing.

Note: The menu option is "Tool&Ops|Options|User Words".

Name of the command: cmeEditUserWords.


File: editor.inf,  Node: Default global edition,  Next: File open dialog,  Prev: User Words,  Up: Options

5.7.1.19 Default global edition
...............................

To understand how this menu option works you must know some details about
the global options of the editor. *Note Set Global::.

The global options are good, but sometimes you want to make some small
differences depending on the kind of file you are editing. For example: I
want the `Intelligent indent' mode enabled for C, but not for most of the
files, I also want to wrap lines for Texinfo files and files without syntax
highlighting. That's impossible to achieve just using the global options,
that's when this option comes into play.

The mechanism is like this: each time you open a new file the editor will
copy the default global options to it and select the syntax highlighting
according to various things, mainly the extension. Once the editor selects
the syntax highlighting the next step is to transfer some options that
apply only to the selected syntax highlighting. By default the list of
options to apply is empty but you can add some using this menu option.

The list of options indicates which settings will be enabled, or disabled,
in addition to the global options. That's something very important to keep
in mind, the list does not replace the global options, it modifies them. So
the list will say things like "also enable the intelligent indent",
"disable the wrap lines", `etc.'

The first dialog shows the list of syntax highlighting defined in the
`syntaxhl.shl' and has three buttons. The `Edit' button is the default
button, so pressing <ENTER> you'll edit the settings for the selected
syntax highlighting. The `No SHL' button is used to edit the options that
will be applied for files with no syntax highlighting associated to.

Once you selected a syntax highlighting a dialog with the list of the
settings for it will appear. The first time it will be empty because those
are defined by the user, and therefore no defaults are provided. In this
list the settings that will be enabled in addition to the global options
are marked with a `+' before the name of the option. The options that will
be disabled are marked with a `-'. The options are the same described in
the editing modes section. *Note Editing Modes::.

The dialog contains an `Add' and a `Delete' button like other dialogs. You
can also use the <Insert> and <Delete> keys. When adding a new setting to
the list a dialog containing the list of available settings is displayed.
Note that this list contains all the settings that are available, once you
add one of them to the previous dialog it is removed from this list.

After selecting one setting to add a new dialog will be displayed. This
dialog will ask information related to this setting. Most settings are
flags that can be `added' or `removed' from the global options, but some of
them are just values that will overwrite the global options. Examples of
the last type are the tab size and the wrap column; in this case the
dialog will ask for the value.

The values are stored in a very simple format in the `deflopts.txt' file.
You can edit this file by hand, but in this case you'll need to know the
names of the settings. The format is very simple, a line starting with `.'
starts a section, the full stop is followed by the name of the
highlighting affected. Flags that will be added (enabled or ored) are
marked with a `+' as in the dialog, flags that will be substracted
(disabled or anded) are marked with a `-' again like in the dialog, in
fact the dialog shows the same string as those in the file. If the setting
is numeric it will ever start with `+' and after the name a `=' and the
asigned value will follow. Just play a little bit and see the resulting
file.

Name of the command: cmeEditDeflOpts.


File: editor.inf,  Node: File open dialog,  Next: Do not create backups for,  Prev: Default global edition,  Up: Options

5.7.1.20 File open dialog
.........................

This command is used to configure some details of the file open dialog.
*Note File Open::.

Name of the command: cmeFileOpenOptions.


File: editor.inf,  Node: Do not create backups for,  Next: Search files under cursor in,  Prev: File open dialog,  Up: Options

5.7.1.21 Do not create backups for
..................................

Sometimes you don't want to create backups for some particular files. In my
case I use a tool called `cvs'. It generates some temporal files and calls
the editor so I can write some information. Those files are short and
temporal, creating backups for them doesn't make any sense.

This command shows a configuration dialog where you can enter a list of
regular expressions. If any of these regular expressions match with the
file name of the file you are about to save then the editor won't create a
backup file for it. The regular expressions are Perl style because I think
they are much more intuitive than POSIX regex.

The list shown in this dialog is stored in a file called `nobkp.txt'.  The
exact place of the file depends on your system like other files created by
the editor.

Note that files listed here aren't remembered in the list of closed
editors.  That's because the editor assumes those files are temporal and
you won't need to use them again.

Name of the command: cmeEditNoBkp.


File: editor.inf,  Node: Search files under cursor in,  Next: List of tag files,  Prev: Do not create backups for,  Up: Options

5.7.1.22 Search files under cursor in
.....................................

When you press `Ctrl+Enter' the editor tries to load the file that's in
the text at the cursor position. If the cursor is in an include line the
editor will extract the name of the header. In any other case the editor
will try to find where the name starts and ends.

If the file isn't located in the current directory the editor will try to
find the file in the list of directories indicated by this option.

You can use environment variables for this list. Here is an example that
shows how to use the content of the `ALLEGRO' environment variable:

     $(ALLEGRO)/include

If the editor failed to find the file and a project is loaded a search in
the project is performed. If this also fails the editor looks for the file
in the same directory of the file you are editing.

This list is stored in the desktop file.

The editor supports some special syntax for the file name to indicate
images and pdf files. This is only useful when running on X Windows. If
the file name starts with `image:' the editor will invoke `gqview' to
display the indicated image. If the name starts with `pdf:NN:', where `NN'
is a page number, the editor will invoke `xpdf' to display the provided
page of a pdf file. These are experimental fatures that can't be
configured, if you are interested on them please contact me.

Name of the command: cmeIncludeList.


File: editor.inf,  Node: List of tag files,  Next: Tag files options,  Prev: Search files under cursor in,  Up: Options

5.7.1.23 List of tag files
..........................

This dialog controls which tag files are loaded to search for symbols. To
learn more about tags please read the corresponding chapter. *Note TAGS
files::.

When you add a file the editor tries to load it and shows how many symbols
it contains.

After selecting a new tag file a dialog will ask if you want to add it
using a relative path. This is a very important question. If you are using
one centralized desktop file and you have just a few projects you can add a
list of tag files in this desktop file, but the list must contain absolute
entries. If you are entering a list of tag files for a project or a local
desktop file I recommend using relative paths, but it depends on your
needs.

Name of the command: cmeTagFiles.


File: editor.inf,  Node: Tag files options,  Next: Regenerate central file,  Prev: List of tag files,  Up: Options

5.7.1.24 Tag files options
..........................

To maintain the tag files you should use a makefile. This makefile will
update the tag files when any of your sources changes.

To make things easier the editor provides an option to automatically keep
the tag files updated. This option can be enabled from this dialog and only
works if you are using a project.

When this option is enabled and you perform a search that involves tags the
editor will automatically check if any of the files included in your
project is newer than the tag files. If newer files were found the editor
will invoke ctags to update the tags. If you delete the tag files the
editor will create a new one.

This option works with a tags file called `tags' located in the same
directory as the project. This file will be listed in the list of tag files
to search but marked with `automatic'. You won't be able to remove this
entry from the list manually.

When new items are added to the project they are marked in a way that their
symbols will be added to the tags file, but when you remove items symbols
from this file aren't removed. If this is annoying just remove the `tags'
file and let the editor create a new one.

Name of the command: cmeTagsOps.


File: editor.inf,  Node: Regenerate central file,  Next: Calendar options,  Prev: Tag files options,  Up: Options

5.7.1.25 Regenerate central file
................................

The central file is maintained using the incremental features of ctags.
Some times ctags fails to remove obsolete entries in the tags file. This
bug can become really annoying. In this case you can use this command to
regenerate the file from scratch.

Name of the command: cmeTagsAutoRegen.


File: editor.inf,  Node: Calendar options,  Next: Advice dialogs,  Prev: Regenerate central file,  Up: Options

5.7.1.26 Calendar options
.........................

The editor can mark holidays in the calendar using a different color. As
holidays depends on the country this feature needs to know:

  1. What's your country

  2. About the holidays celebrated in your country.

The first is achieved using the contents of the LANG environment variable
and a file called `holidays.conf'. This dialog can be used to force the
country when the LANG isn't enough or you don't want to set this variable.

The second is achieved using plug-ins. Currently the editor supports it
only for systems that implements the `dlopen' family of functions. If you
can't find a plug-in for your country and you know how to write small C
programs consider wrtiting a plug-in for your country. The information
about how to do it is contained in the sources distribution. Look for a
directory called `holidays', it contains a `README' file. If you need
assistance contact the author. Please consider contributing the plug-in so
other people from your country can share the benefits.

Name of the command: cmeHolidaysConf.


File: editor.inf,  Node: Advice dialogs,  Prev: Calendar options,  Up: Options

5.7.1.27 Advice dialogs
.......................

In some situations the editor offers some advice to guide new users. These
are called `advice dialogs'. They can be disabled using a check box in the
dialog.

This option is used to enable or disable any of the advice dialogs. Texts
marked with an `X' indicates the corresponding dialog is enabled. Use the
<space> key to change the desired dialog.

Name of the command: cmeAdviceDiagConf.


File: editor.inf,  Node: Calculator (command/menu),  Next: SDG,  Prev: Options,  Up: Tool&Ops

5.7.2 Calculator (command/menu)
-------------------------------

This command shows the calculator: *Note Calculator::.

Name of the command: cmeCalculator.
Assigned key: `Alt+F4'


File: editor.inf,  Node: SDG,  Next: Run program,  Prev: Calculator (command/menu),  Up: Tool&Ops

5.7.3 SDG
---------

Runs the documentation module: see *note SDG Documentation: (SDG)Top.

To configure the SDG module: *Note SDG Options::.

Name of the command: cmeSDG.
Assigned key: `F9'


File: editor.inf,  Node: Run program,  Next: Grep,  Prev: SDG,  Up: Tool&Ops

5.7.4 Run program
-----------------

Runs the desired program. To customize which program to run: *Note Run
program (which one)::.

Name of the command: cmeRunCommand.
Assigned key: `Ctrl+F9'


File: editor.inf,  Node: Grep,  Next: HTML Accents,  Prev: Run program,  Up: Tool&Ops

5.7.5 Grep
----------

This command pops up the `Powered Grep' dialog. Grep is a very powerful
tool to search text in files. To be able to use it you must have the grep
tool installed and in the path. It isn't shipped with the editor.

   * Pattern Box: The text you want to search for. You can use regular
     expressions here. *Note Regular Expressions::.

   * Files to search: The mask used to select the files grep will search
     through. Wildcards and some limited basic regular expressions are
     supported here.

   * Directories to search: The list of directories where the search will
     be performed.

The `Source of pattern' options are used to define the text that will be
searched for:

   * Pattern box is the pattern: grep will search the text indicated in the
     pattern box.

   * Pattern box is a file name: to search words contained in a text file.

   * Use clipboard selection: use the clipboard selection instead of the
     pattern box text. *Note Clipboard::.

The `Type of pattern' option selects how the pattern is interpreted. The
options are directly related to the grep switches `-G', `-E' and `-F'. You
can select basic regular expressions, extended regular expressions or just
a list of matching values separated by carriage returns.  *Note Regular
Expressions::.

The `Place to search' group is used to select which files are examined in
the search:

   * Use files to search: The files to search content is the mask.

   * Search in opened windows: The search is performed in all the opened
     text files.

   * Search in project: The search is performed in all the project files.
     *Note Project::.

   * Recurse in subdirs: When enabled the editor will run grep not only in
     the indicated directories but in any subdirectory contained therein
     as well. That's the main reason because I call it Powered Grep.

The `Options' group contains various options that are self-explanatory.
They include: case sensitive search, whole word and whole line matching and
inverse matching. The last reports the lines that don't match, so be
careful.

After the search the matched lines are displayed in the message window and
by pressing `Alt+F7' and `Alt+F8' you can examine them.

To learn more about the message window *Note Message Window::.

Name of the command: cmeGrepDialog.


File: editor.inf,  Node: HTML Accents,  Next: Export as HTML,  Prev: Grep,  Up: Tool&Ops

5.7.6 HTML Accents
------------------

The following options are useful for people using ISO Latin 1 accents in
your HTML code. Even when the current code page is different than ISO
Latin 1.

* Menu:

* Convert accents to tags::
* Convert tags to accents::


File: editor.inf,  Node: Convert accents to tags,  Next: Convert tags to accents,  Prev: HTML Accents,  Up: HTML Accents

5.7.6.1 Convert accents to tags
...............................

It converts all the accents in the text to ISO-Latin-1 HTML tags. That's
useful when editing html files because you can type accents naturally and
can simply use this option to generate the right tags. It works for any
code page selected.

Name of the command: cmeHTMLAccents.


File: editor.inf,  Node: Convert tags to accents,  Prev: Convert accents to tags,  Up: HTML Accents

5.7.6.2 Convert tags to accents
...............................

It converts all the ISO-Latin-1 HTML tags into accents. That's useful when
reading html files because you can convert the tags to symbols. It works
for any code page selected.

Name of the command: cmeHTMLTag2Accent.


File: editor.inf,  Node: Export as HTML,  Next: Insert key name,  Prev: HTML Accents,  Up: Tool&Ops

5.7.7 Export as HTML
--------------------

This option is used to export the current text file as HTML. The default
options generates a very good WYSIWYG result. This option works for any
syntax highlighting mode and for any color configuration you want.

Under DOS you can customize the editor's palette, this feature will export
the customized colors too.

Note that due to limitations in the HTML language the editor can change the
background color on a word-by-word basis only.

The available options are:

   * File name as title: uses the full path and name of the file as the
     title for the generated HTML.

   * Same background color as the editor: defines the background of the
     HTML file to be equal to the background of the editor's window.

   * Monospaced font: sets the font for the HTML to `Courier New'.

   * Bold attribute: sets the font for the HTML to `bold'.

You can also choose between colorized or simple output. Using colors the
size of the file is increased a lot but the result is very nice.

Name of the command: cmeExportAsHTML.


File: editor.inf,  Node: Insert key name,  Next: Remap code page,  Prev: Export as HTML,  Up: Tool&Ops

5.7.8 Insert key name
---------------------

This command brings up a dialog asking you to press a key. When you press
a key the dialog is closed and the name of the key is inserted at the
cursor position. You can use it to configure the menues (`menubind.smn').
*Note How to configure the keyboard::.

Name of the command: cmcInsertKeyName.


File: editor.inf,  Node: Remap code page,  Next: Profile Editor,  Prev: Insert key name,  Up: Tool&Ops

5.7.9 Remap code page
---------------------

With this command you can change the code page encoding of the current
document. This operation will translate all the characters from the current
encoding to a new one. Characters that don't have an equivalent in the new
code page are converted to spaces.

The dialog asks for the original code page ('from' list) and the new code
page ('to' list). Additionally you can allow the editor to also translate
the first 32 values. Translating the first 32 values can be dangerous; for
this reason the editor won't translate carriage return, line feed and tabs
even if you choose to remap the first values.

This operation affects the buffer globally so you can't use undo. Therefore
you should keep a copy of the file and don't save it if the results aren't
what you expected.

This option is very useful to exchange texts between different operating
systems.

Name of the command: cmeRemapCodePage.


File: editor.inf,  Node: Profile Editor,  Next: Redraw screen,  Prev: Remap code page,  Up: Tool&Ops

5.7.10 Profile Editor
---------------------

This option is used to measure the speed of the editor. Use large files
and to make results comparable always use the same one.

Name of the command: cmcProfileEditor.


File: editor.inf,  Node: Redraw screen,  Next: Paste Emacs mode,  Prev: Profile Editor,  Up: Tool&Ops

5.7.11 Redraw screen
--------------------

This command forces a redraw of the screen. It might be needed if some
application running in the background messed up your console.

Name of the command: cmeReDraw.


File: editor.inf,  Node: Paste Emacs mode,  Next: Block quoted printable decode,  Prev: Redraw screen,  Up: Tool&Ops

5.7.12 Paste Emacs mode
-----------------------

Pastes a comment at the start of the file indicating the Emacs mode and the
tab size used for this file. That's very useful if the file doesn't have
an extension or the extension is ambiguous. It is also a good idea to do
it if you'll send the file to another person and want to indicate which
tab size you used.

The editor understands this comment and sets the syntax highlighting and
tab size to the value indicated.

Name of the command: cmcPasteEmacsMode.


File: editor.inf,  Node: Block quoted printable decode,  Next: Un/Indent block,  Prev: Paste Emacs mode,  Up: Tool&Ops

5.7.13 Block quoted printable decode
------------------------------------

This option decodes the selected text assuming it is encoded with the
quoted printable MIME spec. That's useful if you have an e-mail with
non-ASCII characters and it was encoded with this method. That's very
useful for spanish accents.

Name of the command: cmcQuotedPrintDecode.


File: editor.inf,  Node: Un/Indent block,  Next: Delete memorized backups,  Prev: Block quoted printable decode,  Up: Tool&Ops

5.7.14 Un/Indent block
----------------------

This submenu contains the block indentation operations.

* Menu:

* Indent one space::
* Unindent one character::
* Indent one tab or gap::
* Unindent one tab or gap::
* Comment indent::
* Comment unindent::
* Arbitrary indent::


File: editor.inf,  Node: Indent one space,  Next: Unindent one character,  Prev: Un/Indent block,  Up: Un/Indent block

5.7.14.1 Indent one space
.........................

Indents a block one space. For more information *Note Indentation::.

Name of the command: cmcIndentBlkOne.


File: editor.inf,  Node: Unindent one character,  Next: Indent one tab or gap,  Prev: Indent one space,  Up: Un/Indent block

5.7.14.2 Unindent one character
...............................

Unindents a block one character. For more information *Note Indentation::.

Name of the command: cmcUnIndentBlkOne.


File: editor.inf,  Node: Indent one tab or gap,  Next: Unindent one tab or gap,  Prev: Unindent one character,  Up: Un/Indent block

5.7.14.3 Indent one tab or gap
..............................

Indents a block as if you used the <Tab> key in each line.  For more
information *Note Indentation::.

Name of the command: cmcIndentBlk.


File: editor.inf,  Node: Unindent one tab or gap,  Next: Comment indent,  Prev: Indent one tab or gap,  Up: Un/Indent block

5.7.14.4 Unindent one tab or gap
................................

Unindents a block as if you used the <Backspace> key in all of the lines.
For more information *Note Indentation::.

Name of the command: cmcUnIndentBlk.


File: editor.inf,  Node: Comment indent,  Next: Comment unindent,  Prev: Unindent one tab or gap,  Up: Un/Indent block

5.7.14.5 Comment indent
.......................

This command inserts a comment at the start of each line of the selected
block. The comment used is the one defined in the syntax highlighting file
as `EOLComment1'; if none is defined or the file doesn't have any syntax
highlighting this command does nothing. *Note EOLComment1::.

If no text is selected this command first selects the current line and then
applies the indentation.

Name of the command: cmcCommentIndent.


File: editor.inf,  Node: Comment unindent,  Next: Arbitrary indent,  Prev: Comment indent,  Up: Un/Indent block

5.7.14.6 Comment unindent
.........................

This command removes as many chars from each selected line as the length of
a comment sequence. The comment used is the one defined in the syntax
highlighting file as `EOLComment1'; if none is defined or the file doesn't
have any syntax highlighting this command does nothing.  *Note
EOLComment1::.

This command doesn't check if each line you selected starts with the
defined comment, so be careful.

If no text is selected this command first selects the current line and then
applies the indentation.

Name of the command: cmcCommentUnIndent.


File: editor.inf,  Node: Arbitrary indent,  Prev: Comment unindent,  Up: Un/Indent block

5.7.14.7 Arbitrary indent
.........................

This command pops up a dialog asking for a text to be used as indentation.
The text will be inserted at the start of each line of the selected block.

Name of the command: cmcArbitraryIndent.


File: editor.inf,  Node: Delete memorized backups,  Prev: Un/Indent block,  Up: Tool&Ops

5.7.15 Delete memorized backups
-------------------------------

Deletes all the memorized backups. This includes all the backups created
while the current project/desktop file was opened. If you want to also
delete backup files created during previous sessions you must enable a
special option that makes the editor keep a list across sessions.  *Note
Editor General::.

Name of the command: cmeDeleteBkps.


File: editor.inf,  Node: Project,  Next: Help,  Prev: Tool&Ops,  Up: Pull-down menues

5.8 Project
===========

The project files are used to indicate groups of files. Each project has
its own desktop file so you can have different settings for different
groups of files. *Note Desktop Files::.

There are several reasons to use projects:

   * If you want to work on a group of files and you will be editing these
     files for a long time use a project. Then you will be able to select
     which file to edit from the project window, as this window is sorted
     alphabetically it's easy to make incremental searches (typing the
     first letters) to find the file. Additionally the editor saves the
     window position and other stuff for all the files listed in the
     project, even if they aren't listed in the closed windows list. I use
     it for my web site files; they are more than 44 and the list of
     windows (`Alt+0') doesn't help.

   * If you are using the SDG module to collect the comments of the files
     you need to use a project to specify them.

   * You can use a project to list a set of files to search with grep.
     Each time you want to search in these files you just open this
     project and perform the search.

By default the project window is located at the bottom of the desktop, but
you can change this. *Note Editor General::.

This window shows only the names of the files and the relative path only
when names are repeated. You can change it to display the relative path
for all files pressing `Alt+V' when the project window is selected.

* Menu:

* Open (Project)::
* Close (Project)::
* Save (Project)::
* Save desktop here::
* Export project::
* Import project items::


File: editor.inf,  Node: Open (Project),  Next: Close (Project),  Prev: Project,  Up: Project

5.8.1 Open (Project)
--------------------

Opens a project file. To create a new file just enter a new name in the
dialog.

Name of the command: cmeOpenPrj.


File: editor.inf,  Node: Close (Project),  Next: Save (Project),  Prev: Open (Project),  Up: Project

5.8.2 Close (Project)
---------------------

Close the project file.

Name of the command: cmeClosePrj.


File: editor.inf,  Node: Save (Project),  Next: Save desktop here,  Prev: Close (Project),  Up: Project

5.8.3 Save (Project)
--------------------

Saves the current project. It's a good idea to save the project after
adding or removing a lot of files.

Name of the command: cmeSavePrj.


File: editor.inf,  Node: Save desktop here,  Next: Export project,  Prev: Save (Project),  Up: Project

5.8.4 Save desktop here
-----------------------

Saves a desktop file in the working directory. A desktop file is created
even if the editor is configured to use only one central desktop file.
This is useful to locally store settings without creating a project.

Name of the command: cmeSaveDesktop.


File: editor.inf,  Node: Export project,  Next: Import project items,  Prev: Save desktop here,  Up: Project

5.8.5 Export project
--------------------

Creates a text file containing the names of the project items. The file
contains one file per line.

Name of the command: cmeExportPrj.


File: editor.inf,  Node: Import project items,  Prev: Export project,  Up: Project

5.8.6 Import project items
--------------------------

Imports the names given in the file as project items. The file with the
file names to import must contain one file per line. Relative paths are
recommended. The editor will check if the file exists and if that's a
regular file, if not the item will be rejected.

At the end of the import process the editor informs how many items were
added, how many were already in the project and how many file names didn't
correspond to existing files.

Name of the command: cmeImportPrj.


File: editor.inf,  Node: Help,  Prev: Project,  Up: Pull-down menues

5.9 Help
========

* Menu:

* InfView::
* Another InfView::
* Tip of the day::
* Syntax help::


File: editor.inf,  Node: InfView,  Next: Another InfView,  Prev: Help,  Up: Help

5.9.1 InfView
-------------

Well, I think you figured it out, that's the help.

Name of the command: cmeInfView.
Assigned key: `F1'


File: editor.inf,  Node: Another InfView,  Next: Tip of the day,  Prev: InfView,  Up: Help

5.9.2 Another InfView
---------------------

It opens another InfView window. The editor always opens one window that's
used by the help system. When you close this window the editor just hides
it and when you press <F1> the window is un-hided and the help is
displayed.  That allows the existence of the `Previous help' command. But
some times you could want to brise one or more help files without losing
the help window, in this case you need more than one InfView opened.

Name of the command: cmeAnotherInfView.


File: editor.inf,  Node: Tip of the day,  Next: Syntax help,  Prev: Another InfView,  Up: Help

5.9.3 Tip of the day
--------------------

Once a day the editor shows a usage tip when you start it. Each tip talks
about one interesting feature that most of the people overlook. Reading
them you'll discover a lot of interesting things about the editor.

Each tip has one or more buttons at the right, which represent a link to a
help topic related to this tip. If you want to learn more about the tip's
topic you can browse the help using the buttons.

There are three options at the bottom of the window, they are self
explanatory. The first disables the annoying tips ;-), the second shows the
tips in a dialog box once a day and the third shows the same text in the
message window (once a day of course). The third option is less annoying
than the second but you lose the link buttons.

The text displayed by the tips can be found in the `editor.tip' file. You
can edit it to show anything but be careful because the parser isn't very
tolerant to typos.

To learn more about the message window *Note Message Window::.

Name of the command: cmeTipOfTheDay.


File: editor.inf,  Node: Syntax help,  Prev: Tip of the day,  Up: Help

5.9.4 Syntax help
-----------------

When programming in a language like C you probably can't remember the exact
name of all the library functions; the djgpp libc help contains around 650
nodes and the Allegro help around 400. Placing the cursor over the name of
a library function and pressing <^F1> you'll get help about this function.
If the name isn't exactly typed you'll get a list of the closest matches.
The following topics explain how to configure it.

* Menu:

* Options (Syntax help)::
* Files to search (Syntax help)::
* Search (Syntax help)::


File: editor.inf,  Node: Options (Syntax help),  Next: Files to search (Syntax help),  Prev: Syntax help,  Up: Syntax help

5.9.4.1 Options (Syntax help)
.............................

This dialog box allows the configuration of the syntax help.  *Note Syntax
help::.

The search method used can be:

   * Exact: Only exact matches are reported.

   * Substring: Partial matches are reported.

   * Fuzzy: It uses a special algorithm that reports words similar to the
     one you are searching.

The available options are:

   * Case sensitive: The search interpretes lower case characters as
     different than uppercase characters.

   * Sort by score: The matches are sorted by score when reported. When
     disabled the sorting criteria is alphabetical. A greater score means
     the match is more similar to the word you are searching. A score of
     1000 means exact match.

   * Fuzzy value: That's used only when the selected mode is the fuzzy
     mode.  It indicates the minimal score a word must have to be
     displayed as a possible match. Experiment with different values and
     see the scores reported.

Name of the command: cmeSyntaxHelpOps.


File: editor.inf,  Node: Files to search (Syntax help),  Next: Search (Syntax help),  Prev: Options (Syntax help),  Up: Syntax help

5.9.4.2 Files to search (Syntax help)
.....................................

Here you can indicate in which info files the editor will search the name
of the function; the default is OS dependent. *Note Syntax help::.

You can specify an info node or just the name of the file. In the first
case the editor will read all the cross references found in this node, in
the second the editor will use all the nodes of the file. Normally the
node that contains all the relevant references is called Index, but there
are exceptions; one interesting case is libc.

In the dialog the editor shows which nodes are searched in. If the name
has a question mark to the left it means the editor didn't read the file
yet, pressing <^F1> over any word the editor will search it and hence will
read the help files. If the name has an asterisk it means some error was
encoutered when trying to read this file. Finally if no mark is indicated
it means the editor successfully read the file, additionally the number of
nodes found is indicated to the right. You can add or remove nodes from the
list.

Name of the command: cmeSyntaxHelpFiles.


File: editor.inf,  Node: Search (Syntax help),  Prev: Files to search (Syntax help),  Up: Syntax help

5.9.4.3 Search (Syntax help)
............................

It makes the syntax search and report the matches found. If only one match
was found the editor jumps to this node. *Note Syntax help::.

Name of the command: cmeSyntaxHelp.
Assigned key: `^F1'


File: editor.inf,  Node: Menues configuration,  Next: Editing Modes,  Prev: Pull-down menues,  Up: Top

6 Menues configuration
**********************

  If you need or want to configure the shortcuts activating the menues or
menue options look at the `menubind.smn' file. The format is self
explanatory and the editor supports syntax highlighting for these files.

  This file also configures the `status bar', that's the line at the bottom
of the screen. This line is context sensitive and also contains shortcuts.
Some of the shortcuts can be invisible.

  Finally you can also configure the menu displayed when you click over an
editor window using the right mouse button.

  The menues and status bar can be used to complement the keyboard
assignments. You can assing editor commands, sLisp macros or small
portions of sLisp code to them.

  This chapter is a small reference about the commands you can use in the
`menubind.smn' file.

* Menu:

* SubMenu and EndSubMenu::
* Key names::
* MenuItem entries::
* Commands in menu items::
* MenuItemC entries::
* MenuSeparator::
* The special submenu used for the right click::
* Status bar ranges::
* Visible status bar entries::
* Invisible status bar entries::
* Conditional menu entries::
* Comments in menu files::


File: editor.inf,  Node: SubMenu and EndSubMenu,  Next: Key names,  Prev: Menues configuration,  Up: Menues configuration

6.1 SubMenu and EndSubMenu
==========================

  The `SubMenu' command starts a menu definition. It can be nested. When
used at top level defines a new entry in the menu bar. When used inside
another `SubMenu' section defines a child menu.

  The `EndSubMenu' marks the end of a menu section.

  The syntax for `SubMenu' is:

       SubMenu: "Visible name", key
       ...
       EndSubMenu

 The visible name is what you'll see in the menu bar or the entry in the
parent menu. Usually you assign a key to submenues so they can be easily
selected. That's what you put in the `key' field. To highlight the key you
can use the `~' character. This character indicates the beggining and the
end of a highlighted text. The following example shows a submenu called
File that's triggered when `Alt+F' is pressed and that marks the `F' with
a different color:

       SubMenu: "~F~ile", kbAlF


File: editor.inf,  Node: Key names,  Next: MenuItem entries,  Prev: SubMenu and EndSubMenu,  Up: Menues configuration

6.2 Key names
=============

  When defining a menu entry you must indicate the name of the key or key
combination. The editor have a command specially designed to help you with
it, look in the `Tool&Ops' menu (*note Insert key name::). Here is a small
explanation about how those names are created.

  In menues all key combinations start with the `kb' preffix. Then follows
the key modifiers. They can be:

   * Sh
     - key: Shift

   * Ct
     - key: Control

   * al
     - key: Right Alt

   * Al
     - key: Left Alt


  Avoid using the right alt definitions unless you know very well the side
effects. You can specify more than one modifier but they must be in the
order shown in the table. Suppose you want to indicate a complex key
combination where shift, control and the left alt key must be pressed
together the result is `kbShCtAl'. Note that is not valid if you change
the order. As an example `kbShAlCt' is invalid.

  After the modifier comes the key name. The key name is usually the
character you obtain by pressing the key or the name of the character you
obtain. For the alphabet characters is quite simple, `kbA' is just the key
that generates the `a'. The same is for numbers. Function keys are also
easy, they are named F and the number of the function key.

  Things becomes more complex and even confusing for other characters. At
first you must know the name I gave to each symbol and then you must
understand a small complexity created by the fact that some shifted keys
generates non-related symbols. Here is an example: `kbSh1' is valid but
you won't get this combination because when you press <1> plus shift what
you obtain is `!'. The editor will interpret it as `kbAdmid'.

  Here is a list of the names, but the best is to use the `Insert key name'
option: OpenBrace, BackSlash, CloseBrace, Pause, Esc, BackSpace, Tab,
Enter, Colon, Quote, Grave, Comma, Stop, Slash, Asterisk, Space, Minus,
Plus, PrnScr, Equal, Home, Up, PgUp, Left, Right, End, Down, PgDn, Insert,
Delete, Caret, Admid, DobleQuote, Numeral, Dolar, Percent, Amper, OpenPar,
ClosePar, DoubleDot, LessThan, GreaterThan, Question, A_Roba, Or,
UnderLine, OpenCurly, CloseCurly, Tilde, Macro, WinLeft, WinRight and
WinSel.

  When you have to indicate that no key the `kbUnknown' name can be used.


File: editor.inf,  Node: MenuItem entries,  Next: Commands in menu items,  Prev: Key names,  Up: Menues configuration

6.3 MenuItem entries
====================

  To add a menu entry you can use the `MenuItem' command. The syntax is:

     MenuItem: "Name", Command[, Key [, Context [,"KeyName"]]]

  The name is the visible entry in the menu. The command is the command
assigned to this menu entry. If this menu entry have a shortcut it must be
indicated in the key field. The context field is used to indicate a help
context. The keyname field is just an string that is displayed at the right
of the name of the menu entry to show the shortcut. This syntax is not very
common because you usually don't want to specify a particular help context.


File: editor.inf,  Node: Commands in menu items,  Next: MenuItemC entries,  Prev: MenuItem entries,  Up: Menues configuration

6.4 Commands in menu items
==========================

  You can use any of the editor commands in the commands field. They are
listed in the commands index (*note Index of key commands::). Additionally
you can specify the name of a sLisp macro or a small piece of sLisp code.

  To indicate the name of a sLisp macro just use the following syntax:
`cm(NAME)'. To enter a small portion of sLisp code use it: `cm((CODE))'.
Here is an example that just prints a message in the message window:
`cm((ShowInMessageWindow 'Hi! ;-)'))'.


File: editor.inf,  Node: MenuItemC entries,  Next: MenuSeparator,  Prev: Commands in menu items,  Up: Menues configuration

6.5 MenuItemC entries
=====================

  This is the most common way to add a menu entry. The syntax is:

     MenuItemC: "Name", Command[, Key [,"KeyName"]]

  The only difference with `MenuItem' (*note MenuItem entries::) is that
you don't have to specify a help context. Help contexts are numbers that
associates a context in the editor with some text in the on-line help.
Usually the number is the same used for the command. The `MenuItemC'
assumes the help context is the same as the command number.


File: editor.inf,  Node: MenuSeparator,  Next: The special submenu used for the right click,  Prev: MenuItemC entries,  Up: Menues configuration

6.6 MenuSeparator
=================

  It adds a division line to the menu. Use it to visually group related
menu entries.


File: editor.inf,  Node: The special submenu used for the right click,  Next: Status bar ranges,  Prev: MenuSeparator,  Up: Menues configuration

6.7 The special submenu used for the right click
================================================

  To define the menu associated with the right mouse button you must
define a top-level submenu called `Editor Right Click'. This submenu will
pop up when you right click over an edition window and is just like any
other submenu.


File: editor.inf,  Node: Status bar ranges,  Next: Visible status bar entries,  Prev: The special submenu used for the right click,  Up: Menues configuration

6.8 Status bar ranges
=====================

  The content of the status bar is context sensitive. For this reason the
content of the status bar is defined for a help context or for a range of
help context values. The ranges can overlap and the first match is used.
For this reason the order is important.

  Ranges are started using the `StatusRange' command and closed using the
`EndStatusRange' command. The syntax for the first is:

       StatusRange: first_context, number_of_contexts


File: editor.inf,  Node: Visible status bar entries,  Next: Invisible status bar entries,  Prev: Status bar ranges,  Up: Menues configuration

6.9 Visible status bar entries
==============================

  The syntax for visible entries is:

       StatusEntry: Label, Command, Key

  The label is the visible text and the rest of the values are just like
the ones used by the `MenuItem' entries. *Note MenuItem entries::.


File: editor.inf,  Node: Invisible status bar entries,  Next: Conditional menu entries,  Prev: Visible status bar entries,  Up: Menues configuration

6.10 Invisible status bar entries
=================================

  The syntax is almost the same used by the visible ones, the most
important difference is that they doesn't need a label. *Note Visible
status bar entries::.

       StatusHiddenEntry: Command, Key


File: editor.inf,  Node: Conditional menu entries,  Next: Comments in menu files,  Prev: Invisible status bar entries,  Up: Menues configuration

6.11 Conditional menu entries
=============================

  The `menubind.smn' files support some conditional statements. They are
quite similar to the preprocessor conditionals used in C language and can
be used to exclude or include some menu entries according to the operating
system and other configuration details.

  The most important structure is:

       $if CONDITION
       ...
       $else
       ...
       $endif

  The `else' section is optional. In this case if the `CONDITION' is true
the entries in the first section are used, otherwise the entries in the
`else' section are used.

  Contitions can use and, or and not boolean operations. The `and' and
`or' operators are used for the first two and the `!' operator for not.
Currently you can use parentheses in conditionals but this is not fully
tested.

  The available variables to evaluate are:

   * Alpha
     - Meaning: The binary was compiled for Alpha (DEC) CPUs

   * BCPP
     - Meaning: The binary was compiled using Borland C++

   * BZIP2
     - Meaning: Support for bzip2 compressed files included

   * CALCULATOR
     - Meaning: Built-in calculator is available

   * CALENDAR
     - Meaning: Built-in calendar is available

   * Cygwin
     - Meaning: The binary was compiled using Cygwin

   * djgpp
     - Meaning: The binary was compiled using djgpp

   * DOS
     - Meaning: The binary was compiled for DOS

   * DrvDOS
     - Meaning: The editor using the DOS TV driver

   * DrvQNX
     - Meaning: The editor using the QNX RtP TV driver

   * DrvQNX4
     - Meaning: The editor using the QNX 4 TV driver

   * DrvUNIX
     - Meaning: The editor using the generic UNIX TV driver

   * DrvWin32
     - Meaning: The editor using the Win32 TV driver

   * DrvWinGr
     - Meaning: The editor using the WinGr TV driver

   * DrvWinNT
     - Meaning: The editor using the WinNT TV driver

   * DrvX11
     - Meaning: The editor using the X11 TV driver

   * DrvXTerm
     - Meaning: The editor using the XTerm TV driver

   * FreeBSD
     - Meaning: The binary was compiled for FreeBSD

   * GCC
     - Meaning: The binary was compiled using gcc

   * HPPA
     - Meaning: The binary was compiled for HP-PA Risc CPUs

   * Itanium
     - Meaning: The binary was compiled for IA64 CPUs

   * Linux
     - Meaning: The binary was compiled for Linux

   * MinGW
     - Meaning: The binary was compiled using MinGW

   * MIPS
     - Meaning: The binary was compiled for MIPS CPUs

   * MIXER
     - Meaning: Support for the audio mixer included

   * MP3
     - Meaning: Support to play MP3 included

   * MSC
     - Meaning: The binary was compiled using Microsoft C

   * PCRE
     - Meaning: Support for Perl RegEx included

   * PPC
     - Meaning: The binary was compiled for Power PC CPUs

   * QNXRtP
     - Meaning: The binary was compiled for QNX

   * Solaris
     - Meaning: The binary was compiled for Solaris

   * SPARC
     - Meaning: The binary was compiled for 32 bits SPARC CPUs

   * SPARC64
     - Meaning: The binary was compiled for 64 bits SPARC CPUs

   * UNIX
     - Meaning: The binary was compiled for a UNIX style OS (Linux
     included)

   * Unknown
     - Meaning: The binary was compiled for an unknown CPUs

   * Win32
     - Meaning: The binary was compiled for Windows

   * x86
     - Meaning: The binary was compiled for IA32 CPUs


  In addition to the above mentioned methode you can also define small
macros using the `$define' directive. You can also undefine them using
`$undef' directive. These directives doesn't support multiline
definitions, or worst, they do but this won't work as you should spect.


File: editor.inf,  Node: Comments in menu files,  Prev: Conditional menu entries,  Up: Menues configuration

6.12 Comments in menu files
===========================

  You can add comments to menu files, they must start with the `#'
character and it must be in the first column. Lines starting with `#' are
ignored when parsing menu files.


File: editor.inf,  Node: Editing Modes,  Next: Syntax Highlighting File,  Prev: Menues configuration,  Up: Top

7 Editing Modes
***************

  The editor has various settings that control the function and aspect of
the editor.

  The settings are:

* Menu:

* Overwrite::
* Autoindent::
* Real Tabs::
* Persistent Blocks::
* Intelligent indent::
* Column cursor::
* Row cursor::
* Match pair highlight::
* Match pair on the fly::
* Do not wait to search the pair::
* Transparent Blocks::
* Optimal Fill::
* Wrap Words::
* Do not move the cursor on Paste::
* Scroll Lock centers::
* See Tabs::
* Do not move inside tabs::
* Tab smart indents::
* Use indent size::
* Keep trailing whitespace::
* Backspace unindents::
* Column Markers::
* Syntax Highlighting::


File: editor.inf,  Node: Overwrite,  Next: Autoindent,  Prev: Editing Modes,  Up: Editing Modes

7.1 Overwrite
=============

  This setting controls if the typed characters are inserted in the buffer
or replace the original ones. For a detailed explanation *Note Insert and
Delete::.


File: editor.inf,  Node: Autoindent,  Next: Real Tabs,  Prev: Overwrite,  Up: Editing Modes

7.2 Autoindent
==============

  This setting controls what happens when you press <ENTER>. If this
setting is off the cursor goes to the column 1 of a new line. If the mode
is on the editor will try to mimic the indentation of the code by
inserting spaces or tabs. *Note Optimal Fill::.


File: editor.inf,  Node: Real Tabs,  Next: Persistent Blocks,  Prev: Autoindent,  Up: Editing Modes

7.3 Real Tabs
=============

  This setting controls what happens when you press `<TAB>'. If this
setting is on the editor will insert an ASCII 9 at this position.

  An ASCII 9 is a TAB, that means that the width of this char is enough to
move the cursor to the next tabulator column. In the editor the tabulator
columns are equidistant and the positions are controled by the Tab Size
value.

  If this setting is off the editor won't put any ASCII 9 in your text.
The behavior is configured by the `Tab smart indents' option. Read the
section about it for more information. *Note Tab smart indents::.

  You can also indent using spaces when this option is disabled. For more
information consult the `Use indent size' option.  *Note Use indent size::.

  In the past (versions older than 0.4.44) another thing controlled by this
setting was the behaviour of the <Backspace> key, but now that's
controlled by the `Backspace unindents' option. *Note Backspace
unindents::.

  The editor is much more coherent when you choose to use TABs or not use
TABs. If you mix the two modes you'll get some unexpected results,
especially in the indentation of the blocks.

  If you never use tabs, it's better you work with this setting off.  Then
you'll get much from the editor.

  Now you can say: `But I really need tabs because I'm editing a make
file!' or `because I will send the file using an ultra slow link' `and I
want the compression granted by the tabs.' In these cases you can first
expand all tabs, then work without real tabs and at the finish of your
work compact all possible spaces and generate a file with tabs. *Note
Miscellaneous::.

  Most tabs users also like to enable the `Optimal Fill' option. *Note
Optimal Fill::.
I also suggest using the following options to complement the indentation
when using tabs: `Autoindent' ON, `Intelligent indent' OFF, `Optimal Fill'
ON, `Do not move inside tabs' ON, `Tab smart indents' OFF, `Use indent
size' OFF and `Backspace unindents' OFF.


File: editor.inf,  Node: Persistent Blocks,  Next: Intelligent indent,  Prev: Real Tabs,  Up: Editing Modes

7.4 Persistent Blocks
=====================

  This setting controls the behaviour of the selected area.

  The "Block modes" chapter for a detailed explanation. *Note Block
modes::.


File: editor.inf,  Node: Intelligent indent,  Next: Column cursor,  Prev: Persistent Blocks,  Up: Editing Modes

7.5 Intelligent indent
======================

  This mode was designed to be used jointly with the Pseudo Macros (*note
Pseudo Macros::) and the Real Tabs mode off to achieve an easy way to
indent the code that does a better job than the Autoindent mode.

  In this mode the spaces inserted after pressing <ENTER> depend on the
first word in the last line. For example, if you have:

     if (a==b)_

  With the cursor in the '_' position and press <ENTER> you'll get:

     if (a==b)
       _

  Now you can do either of two things, 1) press space and write the code
that will be executed by the if, or 2) if this a multiline code press {
and <ENTER>.  In the last case you'll get:

     if (a==b)
       {
        _

  Now type your first line of code. Press <ENTER>. Write your next line.
Press <ENTER> again and then <Backspace>:

     if (a==b)
       {
        1st line;
        2nd line;
       _

  Now type } and press <ENTER> one more time:

     if (a==b)
       {
        1st line;
        2nd line;
       }
     _

  As you can see the code is perfectly aligned without a significant work
on your part.

  I tried to make this mode as smart as possible, but it still needs more
work. If you have suggestions contact me.

  Another important thing is that this indentation has a personal style,
my style ;-), so it may be you don't like it. If that's the case you can
do the following things:

   * Configure it using the `syntaxhl.shl' file. Note that the
     configuration is very limited. *Note Syntax Highlighting File::.

   * Use another way of indentation offered by the editor. For example,
     turn on the Real Tabs mode and indent with tabs.

   * Customize the `cpmacros.pmc' file (*note Pseudo Macros::), actually
     this file is coherent with this mode.

* Menu:

* Can you explain more about the behavior of this mode?::
* Do you have more examples?::


File: editor.inf,  Node: Can you explain more about the behavior of this mode?,  Next: Do you have more examples?,  Prev: Intelligent indent,  Up: Intelligent indent

7.5.1 Can you explain more about the behavior of this mode?
-----------------------------------------------------------

  I'll try to describe the behaviour of the mode:

  Each time you press <ENTER> the editor inserts a `\r\n' string in your
text, after that the editor searches one line located above the new line
that has at least one character on it. This line is taken as reference. The
editor analyzes this line searching for:

   * The first non-blank character on this line.

   * The first word on this line.

   * The first parenthesis.

   * The balance of parentheses on the line.

   * The last non-blank and non-comment character in the line.

  Now, if the line contains { at the beginning the editor goes to the first
column after the {.

  If the line contains } at the start the editor will go to the same column
of the } and then will perform a <Backspace>. If the Real Tabs mode is
off, that's an unindent. *Note Real Tabs::.

  If the line starts with a C++ comment the effect is the same as in
Autoindent. *Note Autoindent::.

  If the line starts with a C comment the editor will try to skip the
comment and analyze the rest of the line, but if the comment doesn't end
on this line the editor will go to the column where the `/' is.

  If the line starts with `/' the editor goes to this column.

  If the line has more `(' than `)' the editor will go to the column of the
first non-blank after the first `('.

  If the line has more `)' than `(' the editor will search the line where
the number of parentheses is balanced, then will analyze this line. If the
whole line still generates an unbalanced situation the editor will go to
the first used column in the line that was found the first time. But if
this line will leave all brackets balanced the editor will take the first
word on the line and will use it as reference.

  At last, and according to the word found, the editor will use this word
as reference. The editor recognises the following keywords:

   * `do'
     - Action: +2 but not if ... ;

   * `if'
     - Action: +2 but not if ... ;

   * `for'
     - Action: +3 but not if ... ;

   * `else'
     - Action: +2

   * `case'
     - Action: +5

   * `while'
     - Action: +2 but not if ... ;

   * `switch'
     - Action: +2

   * `break'
     - Action: unindent

   * `return'
     - Action: unindent

   * `default'
     - Action: +5


  The numbers represent how many spaces are added with reference to the
first letter of the word.  'not if ... ;' means that, if the line ends with
a semicolon, the editor will do the same as for Autoindent. *Note
Autoindent::. The unindent is performed with <Backspace>.

  Seasick? *Note Do you have more examples?::.

  Note: Some of these features were added in v0.2.14 of the editor based
on a suggestion of stud73@nortel.ca <Bradford L. Spencer> about the
behaviour of the mode on a line like this `printf("Num: %d",' with the
rest of the parameters on the next line.


File: editor.inf,  Node: Do you have more examples?,  Prev: Can you explain more about the behavior of this mode?,  Up: Intelligent indent

7.5.2 Do you have more examples?
--------------------------------

  Well here are some other examples. I used a strange convention, like
this: if I say type `a[ENTER]{', type the letter `a', then press `<ENTER>'
and finally press the `{' key.

Example 1: (similar to one explained before but is to show the convention)

     Type:
     if (a==1)[ENTER]{[ENTER]a=2;[ENTER]b=3;[ENTER][BACKSPACE]}[ENTER]

     You'll get:

     if (a==1)
       {
        a=2;
        b=3;
       }
     [<--- cursor here]

Example 2: A switch/case example

     Type:
     switch(a)[ENTER]{[ENTER]case 1:[ENTER]a=2;[ENTER]b=3;[ENTER]break;
     [ENTER]case 2:[ENTER]b=5;[ENTER]break;[ENTER][BACKSPACE]}[ENTER]

     You'll get:

     switch(a)
       {
        case 1:
             a=2;
             b=3;
             break;
        case 2:
             b=5;
             break;
       }
     [<--- cursor here]

Example 3: A call to a function that takes a lot of parameters

     Type:
     printf([SPACE]"Num: %d",[ENTER]a[SPACE]);[ENTER]

     You'll get:

     printf( "Num: %d",
             a );
     [<--- cursor here]

Example 4: A lot of parentheses

     Type:
     if[SPACE]([SPACE](a==1)[SPACE]||[ENTER](b==2)[SPACE]||[ENTER]
     c[SPACE])[ENTER]

     You'll get:

     if ( (a==1) ||
          (b==2) ||
          c )
       [<--- cursor here]

Example 5: Comment trying to interfere part 1

     Type:
     /*-a-*/for[SPACE](x=1;x;--x)[ENTER]

     You'll get:

     /*-a-*/for (x=1;x;--x)
               [<--- cursor here]

Example 6: Comment trying to interfere part 2

     Type:
     for[SPACE](x=1;x;--x);[SPACE]//-b[ENTER]

     You'll get:

     for (x=1;x;--x); //-b
     [<--- cursor here]

 Note: Of course you can fool the editor but as you can see it is
relatively smart ;-).


File: editor.inf,  Node: Column cursor,  Next: Row cursor,  Prev: Intelligent indent,  Up: Editing Modes

7.6 Column cursor
=================

  This setting enables a strange feature of the editor. When on the column
where the cursor is is highlighted. This feature is very good to check if
parts of your code are aligned correctly.

  If you like this mode but think it's very uncomfortable to use all the
time contact me and if I get enough feedback I'll create a hotkey for it
to be turned on/off quickly.


File: editor.inf,  Node: Row cursor,  Next: Match pair highlight,  Prev: Column cursor,  Up: Editing Modes

7.7 Row cursor
==============

  This setting is similar to the column cursor but acts on the row where
the cursor is. If you enable the two modes you'll get a cross on the
screen showing where the cursor is.


File: editor.inf,  Node: Match pair highlight,  Next: Match pair on the fly,  Prev: Row cursor,  Up: Editing Modes

7.8 Match pair highlight
========================

  This mode acts showing the pairs of (/), [/] and {/} on the fly. Each
time you type one of these symbols the editor will search the matching
pair, if the editor finds it and the match is on the screen both will be
highlighted, if the match is outside the screen the editor will inform the
position on the status line, and if there is no match the editor will
inform the situation in the status line too.

  That's very useful when you are typing complex parenthetical expressions
or a very nested code. You can use it together with the `cmcSearchStart',
`cmcSearchEnd', `cmcSearchOpPar', `cmcSearchClPar', `cmcSearchOpCor' and
`cmcSearchClCor' commands. *Note Miscellaneous::.

  If you want to get highlight not only after typing but also when moving
the cursors you'll need to enable the `Match pair on the fly' option.
*Note Match pair on the fly::.


File: editor.inf,  Node: Match pair on the fly,  Next: Do not wait to search the pair,  Prev: Match pair highlight,  Up: Editing Modes

7.9 Match pair on the fly
=========================

  This mode is very similar to the `Match pair highlight' mode. If you
don't know how it works please read the `Match pair highlight' section
first. *Note Match pair highlight::.

  The main difference is that this mode highlights the pair when the cursor
is over the character to search.

  The highlight is done half a second after you stop typing to avoid
interfering with your typing. But if you have a fast machine, not just a
386, you can configure the editor to do the search without waiting.  *Note
Do not wait to search the pair::.


File: editor.inf,  Node: Do not wait to search the pair,  Next: Transparent Blocks,  Prev: Match pair on the fly,  Up: Editing Modes

7.10 Do not wait to search the pair
===================================

  This option works only when `Match pair on the fly' is enabled. When
enabled the editor doesn't wait to do the search of the complementary pair.
I think this could impact the performance of scrolling on very slow
machines and that's why it's optional. *Note Match pair on the fly::.


File: editor.inf,  Node: Transparent Blocks,  Next: Optimal Fill,  Prev: Do not wait to search the pair,  Up: Editing Modes

7.11 Transparent Blocks
=======================

  When this mode is on you can see the syntax highlighting of selected
blocks. Normally the selection affects the background and foreground
colors, but when using transparent blocks only the background is affected.


File: editor.inf,  Node: Optimal Fill,  Next: Wrap Words,  Prev: Transparent Blocks,  Up: Editing Modes

7.12 Optimal Fill
=================

  This mode was added for the people that use ASCII 9 tabulators in their
code (*note Real Tabs::). Normally the editor uses spaces to indent the
code or, in general, to fill any gap in the text. When you enable this
mode the editor will use as many tabs as possible to fill these gaps.
That's what the tab users normally expect.


File: editor.inf,  Node: Wrap Words,  Next: Do not move the cursor on Paste,  Prev: Optimal Fill,  Up: Editing Modes

7.13 Wrap Words
===============

  Even when the editor is mainly intended for programmers it became
apparent that some other user groups want to use it too.

  The word wrap added to the editor is a very simple one, it just inserts
a new line if you type a word beyond the wrap column, that's all. You
won't get automatic reformat functions like in text editors intended for
love letters (like the one from the Bill Gates company).

  The wrap column box is used to enter the column that triggers the wrap.


File: editor.inf,  Node: Do not move the cursor on Paste,  Next: Scroll Lock centers,  Prev: Wrap Words,  Up: Editing Modes

7.14 Do not move the cursor on Paste
====================================

  That's a global setting. When it's on the cursor isn't moved after
pasting. Normally the cursor is moved to the end of the pasted block, but
sometimes it's better if the cursor isn't moved.


File: editor.inf,  Node: Scroll Lock centers,  Next: See Tabs,  Prev: Do not move the cursor on Paste,  Up: Editing Modes

7.15 Scroll Lock centers
========================

  When this mode is on the Scroll Lock key has a special meaning. If the
Scroll Lock LED of your keyboard is on then the editor centers the current
line in the window. The effect is very strange but the advantage is that
you don't need to follow the movement of the line with your eyes because
it's always in the same place.


File: editor.inf,  Node: See Tabs,  Next: Do not move inside tabs,  Prev: Scroll Lock centers,  Up: Editing Modes

7.16 See Tabs
=============

  In this mode the tabs are highlighted, two colors are used for this
purpose, one for even and the other for odd numbered tabs. In this way you
can clearly see where a tab is located and the size of the tab. The colors
can be customized from the Colors menu option. *Note Customize Colors::.

  This mode was introduced in v0.4.23 and is globally enabled by default.


File: editor.inf,  Node: Do not move inside tabs,  Next: Tab smart indents,  Prev: See Tabs,  Up: Editing Modes

7.17 Do not move inside tabs
============================

  In this mode the cursor can't be placed inside a tab character. This
definition is fuzzy and confusing so here I'll try to explain it better.
One tab character can be expanded to one or more characters when displayed
on the screen. Normally you can place the cursor in any of the spaces that
belong to a tab character. I think this behavior is the best because you
are free to move the cursor to any place you want, but tab users get
confused when they type and discover they had the cursor in the middle of
a tab. It produces a cursor jump. To avoid this kind of surprise a lot of
editors don't allow to position the cursor in these spaces, only in the
first space.

  This mode was introduced in v0.4.23 and is globally enabled by default.


File: editor.inf,  Node: Tab smart indents,  Next: Use indent size,  Prev: Do not move inside tabs,  Up: Editing Modes

7.18 Tab smart indents
======================

  When `Use real tabs' option is disabled the editor will insert enough
spaces to move the cursor to the next tab-stop or indent position. But if
this option is enabled the editor will insert enough spaces to move the
cursor to the beggining of the next word in the previous line.  Confused?
Sorry for my English, an example will clarify that:

This is a line above the line you are

That's the line where the cursor is, at column one.

  After pressing TAB you'll get:

This is a line above the line you are

     That's the line where the cursor is, at column one.

  Now you'll ask, Why this? Is that useful? The answer is that's very
useful to keep your code indented. Experiment using that under a line with
if, for, `etc.'

  Another option is to indent like the Tab key but using a size different
than the tab size. This can be done disabling this option and enabling
`Use indent size'. *Note Use indent size::.


File: editor.inf,  Node: Use indent size,  Next: Keep trailing whitespace,  Prev: Tab smart indents,  Up: Editing Modes

7.19 Use indent size
====================

  When the `Real Tabs' and `Tab smart indents' options are disabled you can
indent with the tab key but using spaces. Sometimes people want to use tabs
of eight spaces because this is the most common value for consoles and
printers but, at the same time, they want to indent by a different amount
of spaces pressing tab. In this situation you must enable this option and
configure the indentation amount in the `Indent size' box.


File: editor.inf,  Node: Keep trailing whitespace,  Next: Backspace unindents,  Prev: Use indent size,  Up: Editing Modes

7.20 Keep trailing whitespace
=============================

  Normally the editor purges any space after the last visible character in
a line. That's very useful to save disk space and to avoid problems with
end of line continuation sequences, like in C language. But sometimes you
may want to avoid it for some reason. Enabling this option the editor won't
try to remove extra spaces at the end of lines.


File: editor.inf,  Node: Backspace unindents,  Next: Column Markers,  Prev: Keep trailing whitespace,  Up: Editing Modes

7.21 Backspace unindents
========================

  When this option is enabled the <Backspace> deletes as many spaces as
necessary to move the cursor to the first used column of the previous line.
Basically it keeps the indentation. However, this is true only when all the
characters located to the left of the cursor are spaces or tabs.

  In versions older than 0.4.44 this option was implicitly enabled when the
`Real Tabs' option was disabled. When loading old desktop files the editor
enables/disables this option based in the `Real Tabs' option.


File: editor.inf,  Node: Column Markers,  Next: Syntax Highlighting,  Prev: Backspace unindents,  Up: Editing Modes

7.22 Column Markers
===================

  Column markers highlight a column of text. This option is useful for
programming languages where the column is important or when you just need
to have some column positions as references.

  You can set various column markers at the same time, just enable this
option and enter a list of columns in the associated text box. The columns
should be separated by spaces and sorted incrementally. The editor will
format the list in this way.


File: editor.inf,  Node: Syntax Highlighting,  Prev: Column Markers,  Up: Editing Modes

7.23 Syntax Highlighting
========================

  The editor can highlight the syntax of your code. The available modes
are:

   * No highlighting, all the code is with the same color.

   * C/C++ Highlighting.

   * Pascal Highlighting.

   * Clipper Highlighting.

   * User defined. Including already defined for:
        * 4DOS batch files

        * 80x86 assembler (AT&T syntax)

        * 80x86 assembler (Intel syntax)

        * 8x51 assembler

        * Ada

        * BASIC

        * C/C++

        * Cascading Style Sheets version 2

        * Clipper 5.x

        * Command Line Errors File

        * Environment files

        * Flat assembler

        * Fortran

        * HTML

        * Internationalization files (.po)

        * Java

        * Java Script

        * Lua

        * Makefiles

        * Menu files

        * Modula 2

        * Netwide Assembler (NASM)

        * Objetive C

        * Pascal

        * PDP11 assembler

        * Perl

        * PHP

        * PIC assembler (Microchip)

        * PLM/51

        * PMacros files

        * PostScript

        * POV-ray

        * Python

        * Ruby

        * SDG format files

        * sLisp macros

        * SQL

        * The syntax highlight file itself

        * TCL/Tk

        * TeX

        * Texinfo

        * Turbo Vision configuration files

        * UNIX shell scripts

        * VHDL

        * XML

        * WML

  The kind of highlighting is chosen automatically using the extension of
the file. Additionally the editor supports Emacs-like mode selection. Emacs
searches the name of the editing mode in the first kilobyte and last three
kilobytes of text. The editing mode is delimited by `-*-' and the editor
will use it instead of the file extension to select the highlighting mode.
That's very useful for files without extensions like the new C++ headers.
To add even more flexibility I'm supporting another technique used by some
C++ headers from Silicon Graphics and Hewlett Packard, in these headers the
mode is located in the last lines using some special keywords.

  The editor also supports the convention used for UNIX script files. If a
file starts with `#!' this line indicates the program that must be
executed to interpret the script. The editor reads this line and extracts
the name of this program and searches it in the `ShellScript' definition.

  The C/C++ highlighting was designed for the GNU C compiler.

  The Pascal highlighting was designed for the GNU Pascal compiler.

  The Clipper highlighting was designed for the CA-Clipper 5 compiler.

  The highlighting can be customized, *Note Syntax Highlighting File::.


File: editor.inf,  Node: Syntax Highlighting File,  Next: Pseudo Macros,  Prev: Editing Modes,  Up: Top

8 Syntax Highlighting File
**************************

  The highlighting can be customized editing the `syntaxhl.shl' file. You
can add syntax highlighting to almost any kind of files, a good example is
the fact that the files used to configure the editor have their own syntax
highlighting.  *Note Configuration files location::.

  The file declares the settings for each kind of files. Each declaration
ends with an `End' marker. The `#' acts as a start of comment if it
appears in the first column.

  Important things you have to know to add a new syntax highlighting:

   * In previous versions when adding a new highlight mode it ought to have
     been added at the end of the file, now this isn't mandatory.

   * The editor remembers various settings of loaded files even after
     closing the file. This includes the syntax highlighting, so if you add
     a new one or added a new extension to the list and you open a file
     that you already opened the editor will remember the last settings
     and doesn't use the new setting. In this case you must force it by
     hand.

   * If you feel that this new highlight mode can be used by other users
     send it to me and I'll include it in the next release. Many of the
     currently included syntax highlightings were contributed by users.

  If you want to add some keywords to a language for personal use don't do
it in the `Keywords' section because you will need to edit this file each
time you install a new release of the editor. The editor provides another
file for it and also a nice user interface to add and delete words defined
by the user. *Note User Words::.

  This file also configures the pseudo macros used for each language and
the behavior of the "Intelligent Indent" mode. *Note Pseudo Macros::.
*Note Intelligent indent::. *Note PMacros::. *Note NLIndent::.

  The next sections covers the supported settings.

* Menu:

* AllowedInsideNames::
* CanStartAName::
* Case::
* CloseComment1::
* EmacsModes::
* EOLCInFirstCol::
* EOLCInFirstCol1::
* EOLCInFirstCol2::
* EOLCInFirstUse1::
* EOLCInFirstUse2::
* EOLComment1::
* Escape::
* EscapeAnywhere::
* Files::
* FullNameMatch::
* HexMarker::
* Keywords::
* Name::
* NameMatch::
* NLIndent::
* NoCheckNumbers::
* OpenComment1::
* PartialKeywords::
* PMacros::
* Preprocessor::
* RelaxNumberCheck::
* ShellScript::
* ShortString::
* SpecialSymbol::
* String1::
* Symbols1::
* Symbols2::
* UseInternal::
* UserKeywords::
* VHDLNumbers::
* VHDLStr1::
* VHDLStr2::


File: editor.inf,  Node: AllowedInsideNames,  Next: CanStartAName,  Prev: Syntax Highlighting File,  Up: Syntax Highlighting File

8.1 AllowedInsideNames
======================

  Some languages include symbols inside names, you can list these symbols
here.  Normally the editor allows letters, digits and underscore. These
characters are allowed inside the names and not at the start of the name.
*Note CanStartAName::.


File: editor.inf,  Node: CanStartAName,  Next: Case,  Prev: AllowedInsideNames,  Up: Syntax Highlighting File

8.2 CanStartAName
=================

  Some languages includes symbols at the start of names, you can list
these symbols here. Normally the editor allows letters and underscore.
These characters are allowed at the start of the name and not inside.
*Note AllowedInsideNames::.


File: editor.inf,  Node: Case,  Next: CloseComment1,  Prev: CanStartAName,  Up: Syntax Highlighting File

8.3 Case
========

  When this setting is 1 all the keywords become case sensitive. If the
keywords aren't case sensitive don't use it.

  This should be declared as one of the first settings because it affects
how other definitions are loaded in memory. I suggest using it before
`Name' and `Files' and after the others.


File: editor.inf,  Node: CloseComment1,  Next: EmacsModes,  Prev: Case,  Up: Syntax Highlighting File

8.4 CloseComment1
=================

  Used to indicate the end of a multiline comment. The lenght is limited
to four characters. If the file format has two different terminations use
`CloseComment2' for the second.

  For more information *Note Format of short syntax highlighting
definitions::.


File: editor.inf,  Node: EmacsModes,  Next: EOLCInFirstCol,  Prev: CloseComment1,  Up: Syntax Highlighting File

8.5 EmacsModes
==============

  It indicates which Emacs modes will use this highlighting. The modes
must be separated by commas. The modes are't case sensitive.

  As in Emacs the editor looks at the first kilobyte of text and at the
last three kilobytes for the mode delimited by `-*-'.

  The priority is as follows: `EmacsModes', `ShellScript' and finally the
extension (`Files'). *Note ShellScript::. *Note Files::.


File: editor.inf,  Node: EOLCInFirstCol,  Next: EOLCInFirstCol1,  Prev: EmacsModes,  Up: Syntax Highlighting File

8.6 EOLCInFirstCol
==================

  When this setting is on the one line comments starts only if the
sequence of characters is present in the first column.


File: editor.inf,  Node: EOLCInFirstCol1,  Next: EOLCInFirstCol2,  Prev: EOLCInFirstCol,  Up: Syntax Highlighting File

8.7 EOLCInFirstCol1
===================

  That's like EOLCInFirstCol but affects only the EOLComment1 and not both.
*Note EOLCInFirstCol::.


File: editor.inf,  Node: EOLCInFirstCol2,  Next: EOLCInFirstUse1,  Prev: EOLCInFirstCol1,  Up: Syntax Highlighting File

8.8 EOLCInFirstCol2
===================

  That's like EOLCInFirstCol but affects only the EOLComment2 and not both.
*Note EOLCInFirstCol::.


File: editor.inf,  Node: EOLCInFirstUse1,  Next: EOLCInFirstUse2,  Prev: EOLCInFirstCol2,  Up: Syntax Highlighting File

8.9 EOLCInFirstUse1
===================

  That's like EOLCInFirstCol1 but the starting sequence may be the first
non-blank character and does not need to be located in the first column.
*Note EOLCInFirstCol1::.


File: editor.inf,  Node: EOLCInFirstUse2,  Next: EOLComment1,  Prev: EOLCInFirstUse1,  Up: Syntax Highlighting File

8.10 EOLCInFirstUse2
====================

  That's like EOLCInFirstCol2 but the starting sequence may be the first
non-blank character and does not need to be located in the first column.
*Note EOLCInFirstCol2::.


File: editor.inf,  Node: EOLComment1,  Next: Escape,  Prev: EOLCInFirstUse2,  Up: Syntax Highlighting File

8.11 EOLComment1
================

  Used to indicate the start of a comment that ends at the end of the
line. The lenght is limited to four characters. If the file format has two
different terminations use `EOLComment2' for the second.

  For more information *Note Format of short syntax highlighting
definitions::.


File: editor.inf,  Node: Escape,  Next: EscapeAnywhere,  Prev: EOLComment1,  Up: Syntax Highlighting File

8.12 Escape
===========

  Indicates which character acts as escape character inside strings or to
concatenate lines.


File: editor.inf,  Node: EscapeAnywhere,  Next: Files,  Prev: Escape,  Up: Syntax Highlighting File

8.13 EscapeAnywhere
===================

  Indicates that escape characters can be found anywhere, not just inside
strings or at the end of lines like in C.


File: editor.inf,  Node: Files,  Next: FullNameMatch,  Prev: EscapeAnywhere,  Up: Syntax Highlighting File

8.14 Files
==========

  It indicates which extensions will use this highlighting mode. The
extensions must be separated by commas. The extensions are case sensitive,
be careful.

  The editor can also choose the highlighting using the Emacs mode or the
program used to execute the file if that's an UNIX script.

  The priority is as follows: `EmacsModes', `ShellScript',
`FullNameMatch', `NameMatch' and finally the extension (`Files'). *Note
ShellScript::. *Note EmacsModes::. *Note FullNameMatch::.  *Note
NameMatch::.


File: editor.inf,  Node: FullNameMatch,  Next: HexMarker,  Prev: Files,  Up: Syntax Highlighting File

8.15 FullNameMatch
==================

  It can be used to indicate a regular expression to match the full path
and name of the file. If the expression matches the editor will use this
syntax highlighting.

  The regular expression must be in Perl format. You can read about it in
any book about Perl.


File: editor.inf,  Node: HexMarker,  Next: Keywords,  Prev: FullNameMatch,  Up: Syntax Highlighting File

8.16 HexMarker
==============

  This setting indicates what prefix is used for hexadecimal numbers. No
postfix is supported yet. The lenght is limited to four characters.

  For more information *Note Format of short syntax highlighting
definitions::.


File: editor.inf,  Node: Keywords,  Next: Name,  Prev: HexMarker,  Up: Syntax Highlighting File

8.17 Keywords
=============

  It can be used as many times as needed and is used to indicate the
reserved keywords of the language. The separator is the comma.


File: editor.inf,  Node: Name,  Next: NameMatch,  Prev: Keywords,  Up: Syntax Highlighting File

8.18 Name
=========

  It sets the name of the syntax highlighting. This name is used in the
local settings dialog (cmcSetLocalOptions).


File: editor.inf,  Node: NameMatch,  Next: NLIndent,  Prev: Name,  Up: Syntax Highlighting File

8.19 NameMatch
==============

  It can be used to indicate a regular expression to match the name of the
file. If the expression matches the editor will use this syntax
highlighting mode.

  The regular expression must be in Perl format. You can read about it in
any book about Perl.


File: editor.inf,  Node: NLIndent,  Next: NoCheckNumbers,  Prev: NameMatch,  Up: Syntax Highlighting File

8.20 NLIndent
=============

  Defines a rule for the intelligent mode. The rule will apply only to
files with this highlighting. Rules are evaluated when the user inserts a
new line.

  Rules are evaluated in reverse order, last rule first. Each rule contains
two conditions followed by one action. When both conditions are true the
action is applied and no more rules are evaluated.

  All arguments are separated by commas. Each condition is composed by two
arguments. The first is the name of the condition and the second is its
parameter. Currently available conditions and actions are:

* Menu:

* AutoIndent (action)::
* FirstWord (condition)::
* MoveAfterPar (action)::
* NoLastChar (condition)::
* ParBalanceNeg (condition)::
* ParBalancePos (condition)::
* Unindent (action)::


File: editor.inf,  Node: AutoIndent (action),  Next: FirstWord (condition),  Prev: NLIndent,  Up: NLIndent

8.20.1 AutoIndent (action)
--------------------------

  That's the default action and is equivalent to the "Autoindent" mode.
*Note Autoindent::. The main difference is that here the editor tries to
skip comments found at the beggining of the previous line.

  If you provide a numeric argument this value will be used as an offset.


File: editor.inf,  Node: FirstWord (condition),  Next: MoveAfterPar (action),  Prev: AutoIndent (action),  Up: NLIndent

8.20.2 FirstWord (condition)
----------------------------

  This condition needs one parameter indicating the word or symbol we want
to check. It's true when the first word or symbol in the previous line
matches with the parameter.

  Note that the editor skips blank characters and comments to determine the
first character in the previous line. Also note the editor tries to be
smart when the previous line have closing parentheses and tries to find
the line where the parentheses started.


File: editor.inf,  Node: MoveAfterPar (action),  Next: NoLastChar (condition),  Prev: FirstWord (condition),  Up: NLIndent

8.20.3 MoveAfterPar (action)
----------------------------

  This action is usually associated with `ParBalancePos'. It moves the
cursor to the column of the first operand after the first parenthesis in
the previous line.

       if ( a && (c>0)
            _


File: editor.inf,  Node: NoLastChar (condition),  Next: ParBalanceNeg (condition),  Prev: MoveAfterPar (action),  Up: NLIndent

8.20.4 NoLastChar (condition)
-----------------------------

  This condition needs one parameter indicating the character we want to
avoid. It's true when the last symbol in the previous line doesn't match
the parameter.


File: editor.inf,  Node: ParBalanceNeg (condition),  Next: ParBalancePos (condition),  Prev: NoLastChar (condition),  Up: NLIndent

8.20.5 ParBalanceNeg (condition)
--------------------------------

  This condition is true when the previous lines contains less parentheses
opened than closed.

       a && (c>0))


File: editor.inf,  Node: ParBalancePos (condition),  Next: Unindent (action),  Prev: ParBalanceNeg (condition),  Up: NLIndent

8.20.6 ParBalancePos (condition)
--------------------------------

  This condition is true when the previous lines contains more parentheses
opened than closed.

     if (a && (c>0)


File: editor.inf,  Node: Unindent (action),  Prev: ParBalancePos (condition),  Up: NLIndent

8.20.7 Unindent (action)
------------------------

  This action reduces the indentation level. The efect is similar to what
you get using <Backspace> when the "Backspace unindents" mode is enabled.
*Note Backspace unindents::.


File: editor.inf,  Node: NoCheckNumbers,  Next: OpenComment1,  Prev: NLIndent,  Up: Syntax Highlighting File

8.21 NoCheckNumbers
===================

  When this setting is on the numbers aren't highlighted.


File: editor.inf,  Node: OpenComment1,  Next: PartialKeywords,  Prev: NoCheckNumbers,  Up: Syntax Highlighting File

8.22 OpenComment1
=================

  Used to indicate the start of a multiline comment. The lenght is limited
to four characters. If the file format has two different starts use
`OpenComment2' for the second.

  The maximum length is four characters, for more information about the
format: *Note Format of short syntax highlighting definitions::.

* Menu:

* Format of short syntax highlighting definitions::


File: editor.inf,  Node: Format of short syntax highlighting definitions,  Prev: OpenComment1,  Up: OpenComment1

8.22.1 Format of short syntax highlighting definitions
------------------------------------------------------

  All the characters after the equal sign are taken as part of the field.
Blank spaces after the equal sign are ignored, so `Field= //' is
equivalent to `Field=//'.

  As the field may start with spaces and spaces at the end of line are
invisible you can quote the text using the double quote letter. If you do
it the first character after the equal sign must be the double quote, if
you left an space like this: `Field= "' the double quote will be
interpreted as part of the field.

  When quoting text the back slash is the escape character, so this:
`Filed="\""' will be interpreted as asigning `"' to `Field'.


File: editor.inf,  Node: PartialKeywords,  Next: PMacros,  Prev: OpenComment1,  Up: Syntax Highlighting File

8.23 PartialKeywords
====================

  When this setting is enabled the list of the editor will highlight
partial matches of the keywords. For example, suppose a keyword is defined
as `key' and you type `keytable', in this case the editor will highlight
the `key' part of the word. This feature is experimental and makes the
highlighting quite slower.


File: editor.inf,  Node: PMacros,  Next: Preprocessor,  Prev: PartialKeywords,  Up: Syntax Highlighting File

8.24 PMacros
============

  Indicates the name of the pseudo macros file used for this kind of
files. Using different files for different formats you can assign common
triggers to different actions. For example, you can use i( to trigger an
if() {} else {} in C and an if then else in BASIC. *Note Pseudo Macros::.


File: editor.inf,  Node: Preprocessor,  Next: RelaxNumberCheck,  Prev: PMacros,  Up: Syntax Highlighting File

8.25 Preprocessor
=================

  Indicates which symbol starts a preprocessor line.


File: editor.inf,  Node: RelaxNumberCheck,  Next: ShellScript,  Prev: Preprocessor,  Up: Syntax Highlighting File

8.26 RelaxNumberCheck
=====================

  This is used when a number can start a name and that isn't a error.
Normally the editor takes it as a wrong number but when this option is
enabled the check for numbers is relaxed and they aren't highlighted as
wrong values.


File: editor.inf,  Node: ShellScript,  Next: ShortString,  Prev: RelaxNumberCheck,  Up: Syntax Highlighting File

8.27 ShellScript
================

  It indicates which scripts will be highlighted. You must indicate the
names of the programs associated with this script. The names are case
sensitive.

  The editor looks for the `#!' characters at the start of the file, if
found the name of the program is extracted and searched in this list.

  The priority is as follows: `EmacsModes', `ShellScript' and finally the
extension (`Files'). *Note EmacsModes::. *Note Files::.


File: editor.inf,  Node: ShortString,  Next: SpecialSymbol,  Prev: ShellScript,  Up: Syntax Highlighting File

8.28 ShortString
================

  Used to indicate the start and end of strings, used for small strings or
characters.  The string ends at the end of line if not explicitly closed.


File: editor.inf,  Node: SpecialSymbol,  Next: String1,  Prev: ShortString,  Up: Syntax Highlighting File

8.29 SpecialSymbol
==================

  That's used to mark pairs of characters that form a particular symbol
that will generate problems if the editor sees them as separated symbols.
It was created to avoid problems with `$#' in Perl and bash scripts and
with `@@' in Texinfo files. You can define more than one character here.

  The characters that can be combined with it are specified using the
`SpecialSymbolCont' definition.


File: editor.inf,  Node: String1,  Next: Symbols1,  Prev: SpecialSymbol,  Up: Syntax Highlighting File

8.30 String1
============

  Used to indicate the start and end of strings, used for long strings.
You can specify more than one character, in this case any of them can open
or close the string.

  The editor supports up to three diferent strings declared as `String1',
`String2' and `String3'.


File: editor.inf,  Node: Symbols1,  Next: Symbols2,  Prev: String1,  Up: Syntax Highlighting File

8.31 Symbols1
=============

  Used to indicate which characters are allowed to be symbols, normally
used for boolean and arithmetic symbols.


File: editor.inf,  Node: Symbols2,  Next: UseInternal,  Prev: Symbols1,  Up: Syntax Highlighting File

8.32 Symbols2
=============

  Used to indicate what characters are allowed to be symbols, normally
used for flow control and subindex symbols.


File: editor.inf,  Node: UseInternal,  Next: UserKeywords,  Prev: Symbols2,  Up: Syntax Highlighting File

8.33 UseInternal
================

  That's optional. When a highlighting mode has this setting the editor
will use the internal routines and will ignore almost all the settings.
Only the extensions (*note Files::) and pseudo macros (*note PMacros::)
settings are used.

  The value assigned can be: 1 for GNU C highlighting, 2 for standard
Pascal and 3 for Clipper.


File: editor.inf,  Node: UserKeywords,  Next: VHDLNumbers,  Prev: UseInternal,  Up: Syntax Highlighting File

8.34 UserKeywords
=================

  Used to define default user keywords. These keywords are discarded if
the user specifies its own keywords. *Note User Words::.

  The syntax is the same used for *Note Keywords::.


File: editor.inf,  Node: VHDLNumbers,  Next: VHDLStr1,  Prev: UserKeywords,  Up: Syntax Highlighting File

8.35 VHDLNumbers
================

  This option is used to enable the parser for VHDL abstract literals and
VHDL bit string literals. Abstract literals are just numbers and bit string
literals are bit vectors. The editor highlights bit string literals as
integers.  *Note VHDLStr1::.


File: editor.inf,  Node: VHDLStr1,  Next: VHDLStr2,  Prev: VHDLNumbers,  Up: Syntax Highlighting File

8.36 VHDLStr1
=============

  This option is used to enable the parser for VHDL string literals for the
`String1' delimiter. VHDL strings are a little bit different than C/C++
ones. *Note VHDLStr2::. *Note VHDLNumbers::.


File: editor.inf,  Node: VHDLStr2,  Prev: VHDLStr1,  Up: Syntax Highlighting File

8.37 VHDLStr2
=============

  This option is used to enable the parser for VHDL string literals for the
`String2' delimiter. VHDL strings are a little bit different than C/C++
ones. *Note VHDLStr1::. *Note VHDLNumbers::.


File: editor.inf,  Node: Pseudo Macros,  Next: sLisp macros,  Prev: Syntax Highlighting File,  Up: Top

9 Pseudo Macros
***************

  This feature is very useful to save some keystrokes. With this feature
you can create a lot of shortcuts to make your life easier.

* Menu:

* Please enlighten me - what is that?::
* How can I customize that?::


File: editor.inf,  Node: Please enlighten me - what is that?,  Next: How can I customize that?,  Prev: Pseudo Macros,  Up: Pseudo Macros

9.1 Please enlighten me - what is that?
=======================================

  So now, What's a Pseudo Macro? It's like a macro but it's triggered by
two things: one the text before the cursor, and two the `^Space'
combination.

  And what's the result? The result is customizable, but by default there
are some predefined behaviours. For example, in a C source window type the
following two characters: `#i' and then press `^Space' ... (to create an
empty file with .c extension go to File|Open and type a new name, foo.c
for example).

  Surprised? I bet! You got: #include <.h> and the cursor just at the right
place to write the name of the header.

Now write the famous stdio word, press `<End>', then `<Enter>' twice and
now write the following two letters: `ma' and then `^Space' ...

  I bet this time you had an inkling of what will happen so you aren't that
surprised ;-). Anyways, Surprise! Now type `pr' and the magic keys and ...
`printf("");' appears. To end the happy history now type "Hello world!"
That's all. You wrote the hello world program at a very good speed.

  Now you know what I mean when I say pseudo-macros.


File: editor.inf,  Node: How can I customize that?,  Prev: Please enlighten me - what is that?,  Up: Pseudo Macros

9.2 How can I customize that?
=============================

* Menu:

* General customization::
* Asking for user defined values::
* Executing sLisp code from a pmacro::


File: editor.inf,  Node: General customization,  Next: Asking for user defined values,  Prev: How can I customize that?,  Up: How can I customize that?

9.2.1 General customization
---------------------------

  It's very easy. Each syntax highlighting has its own pseudo macros file.
Which file belongs to which syntax highlighting is indicated in the
`syntaxhl.shl' file. *Note Syntax Highlighting File::. In the case of
C/C++ the file is called `cpmacros.pmc' and is located in the same
directory where the rest of the configuration files are installed. This
file contains the definitions for each pseudo macro that can be triggered
in C/C++ files. You can define as many pseudo macros as you want. *Note
Configuration files location::.

  Important: If you are using RHIDE consult the RHIDE documentation to know
where the `cpmacros.pmc' file is stored.

  The `cpmacros.pmc' file is a very good example and is self-explanatory
but I'll include one example here.

Trigger: "i("
Mode: 0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
Name: if plus else
 "if (@0)\n"
 "  {@1\n"
   "}\n"
 "\belse\n"
 "  {@2\n"
   "}"

  The Trigger keyword defines the two letters before the cursor that will
trigger the pseudo macro.

  The Mode keyword indicates the mode that the editor will use when
inserting the text. The modes are:

   * Overwrite                 *Note Overwrite::.

   * Autoindent                *Note Autoindent::.

   * Use Tabs                  *Note Real Tabs::.

   * Persistent blocks         *Note Block modes::.

   * Intelligent indent        *Note Intelligent indent::.

   * Vertical cursor           *Note Column cursor::.

   * Horizontal cursor

   * Match pair highlight      *Note Match pair highlight::.

   * Match pair on the fly

   * Don't wait to search for the pair

   * Transparent Blocks        *Note Transparent Blocks::.

   * Optimal Fill              *Note Optimal Fill::.

   * Wrap words                *Note Wrap Words::.

   * See tabs                  *Note See Tabs::.

   * Don't move inside tabs    *Note Do not move inside tabs::.

   * Tab smart indents         *Note Tab smart indents::.

   * Use indent size           *Note Use indent size::.

   * Keep trailing whitespace  *Note Keep trailing whitespace::.

   * Backspace unindents       *Note Backspace unindents::.

   * Column markers            *Note Column Markers::.

  Each mode can be 0 or 1. The editor will return to the original mode
after expanding the pseudo macro. In this case the macro is expanded like
this: No overwrite, autoindent, don't use tabs, the blocks are persistent
and don't be smart when indenting.

  The rest is the code to insert enclosed by ". You can use \b to indicate
backspace, \n for newline and \\ to indicate a simple \. If you want to
insert a @ you have to type it twice @@, because this character has a
special meaning (see below).

  After the insertion the cursor is positioned in the place marked with @0.
Don't forget to signal this point or the cursor will be positioned at the
beginning of the file. The places marked with @1, @2 and @3 are saved in
the markers 7, 8 and 9.

  Currently we defined pseudo macros only for x51 assembler, Clipper,
C/C++, HTML, Perl, VHDL and WML. We did it in a way that you can use the
same pseudo macro for all languages. For example: `#i' is expanded to
`#include <.h>' for C/C++ files and to `request "";' for Perl files.  If
you write similar pseudo macros for other languages please send me the file
and I'll add it to the next release.


File: editor.inf,  Node: Asking for user defined values,  Next: Executing sLisp code from a pmacro,  Prev: General customization,  Up: How can I customize that?

9.2.2 Asking for user defined values
------------------------------------

  Pseudo macros can ask the user to enter values. This can be done using
the @{Name} syntax. We will call it a variable. A macro can have as many
variables as you want. But in practice you should avoid using more than 17
variables because the dialog created to ask for them could become useless.

  When a macro containing one or more variables is expanded the editor pops
up a dialog containing the variables. After the user enters them the macro
is expanded and the variables are replaced by the user defined values.

  If you need to expand a variable more than once you can reference the
variable using `@vN' where N is the number of the variable. Variables are
numbered starting from zero. Here is an example showing a macro for the
VHDL entity construction:

     Trigger: "en"
     Mode: 0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
     Name: Entity
      "entity @{Entity} is\n"
      "   generic(@0\n"
         "       );\n"
         "\bport(@1\n"
         "     );\n"
      "\b\bend entity @v0;"

  In this example if you enter `Counter' for the `Entity' variable you'll
get:

     entity Counter is
        generic(
               );
        port(
            );
     end entity Counter;

  If you want to provide a default value use the following syntax:
@{Name;Value}.


File: editor.inf,  Node: Executing sLisp code from a pmacro,  Prev: Asking for user defined values,  Up: How can I customize that?

9.2.3 Executing sLisp code from a pmacro
----------------------------------------

  You can execute sLisp code from a pseudo macro using the following
syntax: `@{(code)}'. The code will be executed every time you expand the
macro. For more information about sLisp *Note sLisp macros::.

  You can insert text using `InsertText' sLisp command. You can even
insert the output of an external program using the `RunProgramRedir'
command. *Note InsertText::. *Note RunProgramRedir::.

  To make the macro more readable you can split the code in multiple lines.
Here is an example:

      "---- Copyright (c) @{"
     ; sLisp code to get the year using the date command. Side effect: saves the file to disk
      "(eval"
       "(setv 'year' (RunProgramRedir 'date +%Y'))"
       "(InsertText (left year (- (length year) 1)))"
      ")"
      "} @v2 <@v3>\n"


File: editor.inf,  Node: sLisp macros,  Next: Calculator,  Prev: Pseudo Macros,  Up: Top

10 sLisp macros
***************

  The editor uses a lisp like language to store macros. The macros are
stored in a file called `macros.slp'. *Note Configuration files location::.

  The macros can be assigned to keys (*note How to configure the
keyboard::), selected from the `Macro' menu or from the menu. From the
`Macro' menu you can choose a macro from the list. If you want to repeat
it you can do so with one keystroke.

  To add a new macro to the list you must edit the `macros.slp' file. You
can write the new macro by hand or you can use the `Macro' menu to record
a macro and then generate the sLisp code for this macro.

  To assign a macro to a menu entry you must edit the `menubind.smn'. The
macros are called using `cm(name)' where `name' is the name of the macro
you want to trigger.

  To assign a piece of sLisp code to a menu entry you must use
`cm((code))'. Here is an example:

      MenuItemC: "Test macro from menu", cm((ShowInMessageWindow "Hi! ;-)"))

  Don't insert spaces between the starting and ending parentheses pairs.

  You can also assing a piece of sLisp code to a key.  *Note How to
configure the keyboard::.

* Menu:

* How to write a sLisp macro::
* How strings are parsed::
* Running programs with a macro::
* General sLisp commands::
* Editor specific commands::
* Writing macros that use text filters::


File: editor.inf,  Node: How to write a sLisp macro,  Next: How strings are parsed,  Prev: sLisp macros,  Up: sLisp macros

10.1 How to write a sLisp macro
===============================

  I'll show you an example and then I'll explain each part of the example:

     (defmacro 'Testing 1 2 3 ;-)'
      (eval
       (SendCommands cmcLineEnd)
       (InsertText (+ 'Hi!' CR 'How are you?'))
       (SendCommands cmcLineUp cmcLineEnd)
      )
     )

  That defines a macro called "Testing 1 2 3 ;-)" that will be expanded to
all the code inside of the `eval' sentence. The `SendCommands' command
sends one or more commands to the editor. The `InsertText' command inserts
one string in the code.  To concatenate strings use the `+' operator.
Currently you can use the `\n' escape sequence inside a string to indicate
a carriage return, but in the example above `CR' - a constant - is used to
concatenate strings.


File: editor.inf,  Node: How strings are parsed,  Next: Running programs with a macro,  Prev: How to write a sLisp macro,  Up: sLisp macros

10.2 How strings are parsed
===========================

  sLisp strings can be delimited by single or double quotes (`'' or `"').
Currently both produce the same result but in the future it could change
to be similar to Perl.

  A few C escape sequences are supported inside strings. This means the `\
' character has a special meaning. Here are the values supported:

   * n
     - Interpreted as: an OS dependant carriage return (rn for DOS and n
     for UNIX)

   * l
     - Interpreted as: simple line feed (ASCII 10 for DOS and UNIX)

   * r
     - Interpreted as: simple carriage return (ASCII 13 for DOS and UNIX)

   * t
     - Interpreted as: tab (ASCII 9 for DOS and UNIX)


  In strings that will be inserted in the text you should use the `\\n'
escape sequence to maintain compatibility across different OSs. You can
also use the built-in constant called `CR'.


File: editor.inf,  Node: Running programs with a macro,  Next: General sLisp commands,  Prev: How strings are parsed,  Up: sLisp macros

10.3 Running programs with a macro
==================================

  There is a sLisp command called `RunProgram'. It takes a string as
parameter which can contain one or more programs separated by `;' or the
commands separator used by your command shell.

  The standard output and error are redirected and the results are sent to
the Message Window. If the program is a GNU tool and reported errors the
editor will parse these errors and will allow you to directly jump to the
file and line where the error was reported.

To learn more about the message window *Note Message Window::.


File: editor.inf,  Node: General sLisp commands,  Next: Editor specific commands,  Prev: Running programs with a macro,  Up: sLisp macros

10.4 General sLisp commands
===========================

  This section describes general sLisp commands that can be used from the
editor and the SDG configuration files.

* Menu:

* and::
* Operator = (assign)::
* Operator & (bitwise and)::
* cond::
* Operator -- (decrement)::
* Operator != (different)::
* Operator == (equal)::
* eval::
* exitloop::
* gstr::
* if::
* Operator ++ (increment)::
* left::
* length::
* loop::
* Operator ~ (negated)::
* not::
* or::
* Operator | (bitwise or)::
* Operator + (plus)::
* prex::
* repeat::
* right::
* setv::
* ShortFileName::
* sstr::
* strcasecmp::
* strcmp::
* strstr::
* strxlt::
* substr::
* Operator - (substraction)::
* tostr::


File: editor.inf,  Node: and,  Next: Operator = (assign),  Prev: General sLisp commands,  Up: General sLisp commands

10.4.1 and
----------

  (and EXP1 EXP2 ...)

  Returns the logical and of the provided expressions. The values are
evaluated from left to right. If at any point the result is zero then zero
is returned and the rest isn't evaluated.

  Each value is evaluated as one or zero.

  (and 20 "hello" 4)
  Returns 1.

  (and 20 4 2)
  Returns 1.


File: editor.inf,  Node: Operator = (assign),  Next: Operator & (bitwise and),  Prev: and,  Up: General sLisp commands

10.4.2 Operator = (assign)
--------------------------

  (= VARIABLE VALUE)

  This is a shortcut for the `setv' command. *Note setv::.


File: editor.inf,  Node: Operator & (bitwise and),  Next: cond,  Prev: Operator = (assign),  Up: General sLisp commands

10.4.3 Operator & (bitwise and)
-------------------------------

  (& EXP1 EXP2 ...)

  Returns the bitwise and of the provided expressions. The values are
evaluated from left to right. If at any point the result is zero then zero
is returned and the rest isn't evaluated.

  (& 20 4 2)
  Returns 0.

  (& 20 4)
  Returns 4.


File: editor.inf,  Node: cond,  Next: Operator -- (decrement),  Prev: Operator & (bitwise and),  Up: General sLisp commands

10.4.4 cond
-----------

  (cond CONDITION EXP [CONDITION2 EXP2 ...])

  Evaluates the conditions until one is true and returns the associated
expression. If all conditions are false it returns 0.

  (cond 0 1 2 3)
  Returns 3.

  (cond 1 "Hi!" 0 "Bye")
  Returns "Hi!".


File: editor.inf,  Node: Operator -- (decrement),  Next: Operator != (different),  Prev: cond,  Up: General sLisp commands

10.4.5 Operator - (decrement)
-----------------------------

 (- EXPRESSION)

  Returns the integer expression decremented by one. Currently only
integer values are supported.

  If the EXPRESSION is an string and it corresponds to the name of a
defined integer variable the variable is decremented and the resulting
value is returned.

  (- 8)
  Returns 7.

  (setv "a_var" 4)   (++ "a_var")
  Returns 3.


File: editor.inf,  Node: Operator != (different),  Next: Operator == (equal),  Prev: Operator -- (decrement),  Up: General sLisp commands

10.4.6 Operator != (different)
------------------------------

  (!= EXP1 EXP2)

  Returns  zero if both expressions represent the same value. Currently
both expressions must be of the same type.

  (== 1 2)
  Returns 1

  (== 2 (+ 1 1))
  Returns 0

  (== "Hello" "Hello")
  Returns 0


File: editor.inf,  Node: Operator == (equal),  Next: eval,  Prev: Operator != (different),  Up: General sLisp commands

10.4.7 Operator == (equal)
--------------------------

  (== EXP1 EXP2)

  Returns an integer different than zero if both expressions represent the
same value. Currently both expressions must be of the same type.

  (== 1 2)
  Returns 0

  (== 2 (+ 1 1))
  Returns 1

  (== "Hello" "Hello")
  Returns 1


File: editor.inf,  Node: eval,  Next: exitloop,  Prev: Operator == (equal),  Up: General sLisp commands

10.4.8 eval
-----------

  (eval EXPRESSION ...)

  This command is used to specify more than one action where just one is
expected.  Additionally you could write sLisp code in a string and then
evaluate it. The expressions are evaluated from left to right, the last
evaluated result is returned.


File: editor.inf,  Node: exitloop,  Next: gstr,  Prev: eval,  Up: General sLisp commands

10.4.9 exitloop
---------------

  (exitloop )

  Exits from a loop. *Note loop::.


File: editor.inf,  Node: gstr,  Next: if,  Prev: exitloop,  Up: General sLisp commands

10.4.10 gstr
------------

  (gstr STRING POSITION)

  Returns the POSITIONth character of the STRING. The first character is in
the 0 position.

  (gstr "hello" 4)
  Returns "o".


File: editor.inf,  Node: if,  Next: Operator ++ (increment),  Prev: gstr,  Up: General sLisp commands

10.4.11 if
----------

  (if CONDITION STATEMENT_1 [STATEMENT_2])

  It evaluates CONDITION, if the boolean value of it is true then
STATEMENT_1 is evaluated. If the value is false and you provided a second
statement then STATEMENT_2 is evaluated. If the value is false and the
second statement is missing nothing is evaluated and the resulting value
is 0.

  (if "hello" 4)
  Returns 4.

  (if "" 4 3)
  Returns 3.

  (if 0 4)
  Returns 0.


File: editor.inf,  Node: Operator ++ (increment),  Next: left,  Prev: if,  Up: General sLisp commands

10.4.12 Operator ++ (increment)
-------------------------------

 (++ EXPRESSION)

  Returns the integer expression incremented by one. Currently only
integer values are supported.

  If the EXPRESSION is an string and it corresponds to the name of a
defined integer variable the variable is incremented and the resulting
value is returned.

  (++ 8)
  Returns 9.

  (setv "a_var" 4)   (++ "a_var")
  Returns 5.


File: editor.inf,  Node: left,  Next: length,  Prev: Operator ++ (increment),  Up: General sLisp commands

10.4.13 left
------------

  (left STRING NUMBER)

  Returns the first NUMBER characters of the STRING.

  (left "hello" 4)
  Returns "hell".


File: editor.inf,  Node: length,  Next: loop,  Prev: left,  Up: General sLisp commands

10.4.14 length
--------------

  (length STRING)

  This function returns the number of characters in STRING.

  (length "hello")
  Returns 5.


File: editor.inf,  Node: loop,  Next: Operator ~ (negated),  Prev: length,  Up: General sLisp commands

10.4.15 loop
------------

  (loop EXPRESSION ...)

  Evaluates the expressions until an `exitloop' command is found.

  (= "i" 0)
  (loop
   (InsertText (tostr i))
   (if (== i 5) (exitloop))
   (++ "i")
  )
  Inserts "012345" text.


File: editor.inf,  Node: Operator ~ (negated),  Next: not,  Prev: loop,  Up: General sLisp commands

10.4.16 Operator ~ (negated)
----------------------------

  (~ VALUE)

  Returns the VALUE negated (at bit level).

  (~ "hello")
  Returns 0.

  (~ "")
  Returns 0xFFFFFFFF.

  (~ 1)
  Returns -2.


File: editor.inf,  Node: not,  Next: or,  Prev: Operator ~ (negated),  Up: General sLisp commands

10.4.17 not
-----------

  (not VALUE)

  Returns the VALUE negated.

  (not "hello")
  Returns 0.

  (not "")
  Returns 1.

  (not 1)
  Returns 0.


File: editor.inf,  Node: or,  Next: Operator | (bitwise or),  Prev: not,  Up: General sLisp commands

10.4.18 or
----------

  (or EXP1 EXP2 ...)

  Returns the logical or of the provided expressions. The values are
evaluated from left to right. If any of them is non-zero the result is
non-zero and the rest isn't evaluated.

  (or 20 4 2)
  Returns 20.


File: editor.inf,  Node: Operator | (bitwise or),  Next: Operator + (plus),  Prev: or,  Up: General sLisp commands

10.4.19 Operator | (bitwise or)
-------------------------------

  (| EXP1 EXP2 ...)

  Returns the bitwise or of the provided expressions. The values are
evaluated from left to right. If at any point all bits are one the rest of
the values isn't evaluated.

  (| 20 4 2)
  Returns 22.


File: editor.inf,  Node: Operator + (plus),  Next: prex,  Prev: Operator | (bitwise or),  Up: General sLisp commands

10.4.20 Operator + (plus)
-------------------------

  (+ VALUE1 VALUE2 ...)

  Returns the result of adding all the parameters. The type of the result
is determined by the first parameter. Currently you can't mix strings and
integers but if you bug me enough I'll add it. Adding strings means
concatenation.

  (+ "hel" "lo")
  Returns "hello".

  (+ 3 5)
  Returns 8.

  (+ "hello" 1)
  Syntax error.


File: editor.inf,  Node: prex,  Next: repeat,  Prev: Operator + (plus),  Up: General sLisp commands

10.4.21 prex
------------

  (prex TEXT REGEX)

  Performes a search using the REGEX Perl regular expression in the
specified TEXT.

  Returns the number of matchs. This value is 0 if the search failed and at
least one if succeed. To retreive the results of the matches you can use
internal variables called `_X', where X is the number of the match. The
match number 0 is the main result, the others correspond to the
subexpressions contained in REGEX. Note that variables with numbers above
the bigest subexpression number are undefined or could contain the result
of a previous search.

  A very important detail is that back slash characters are escape
characters in sLisp string. It means that `"\\d"' is equivalent to `\d'.

  The following example shows `123' in the status line of the current
edition window:

  (eval    (prex "Hi 123 bye 456 nope" "i (\\d*) b")    (ShowInStatusLine
_1)   )


File: editor.inf,  Node: repeat,  Next: right,  Prev: prex,  Up: General sLisp commands

10.4.22 repeat
--------------

  (repeat TIMES EXPRESSION ...)

  Evaluates the expressions until an `exitloop' command is found or the
TIMES number of iterations is reached.

  (= "i" 0)
  (repeat 6
   (InsertText (tostr i))
   (++ "i")
  )
  Inserts "012345" text.


File: editor.inf,  Node: right,  Next: setv,  Prev: repeat,  Up: General sLisp commands

10.4.23 right
-------------

  (right STRING NUMBER)

  Returns the last NUMBER characters of the STRING.

  (right "hello" 3)
  Returns "llo".


File: editor.inf,  Node: setv,  Next: ShortFileName,  Prev: right,  Up: General sLisp commands

10.4.24 setv
------------

  (setv VARIABLE VALUE)

  Assigns VALUE to the VARIABLE. If the VARIABLE wasn't yet defined the
variable is created. The VARIABLE parameter must be a string representing
the name of the variable, it may also be an expression. This command have a
shortcut. *Note Operator = (assign)::.

  Variable names can contain underscores, but the names starting with
underscores are reserver for internal use.

  (setv "counter" 1)
  Assigns 1 to the COUNTER variable, if COUNTER doesn't exist counter is
created.

  (setv (+ "counter" "1") 1)
  Assigns 1 to the COUNTER1 variable, if COUNTER1 doesn't exist counter1 is
created.


File: editor.inf,  Node: ShortFileName,  Next: sstr,  Prev: setv,  Up: General sLisp commands

10.4.25 ShortFileName
---------------------

  (ShortFileName FILE_NAME)

  Returns the short name for FILE_NAME. That's useful only for Windows and
if long file names are supported. It can be used to pass a file name to an
external program that doesn't support long file names.


File: editor.inf,  Node: sstr,  Next: strcasecmp,  Prev: ShortFileName,  Up: General sLisp commands

10.4.26 sstr
------------

  (sstr STRING POSITION VALUE)

  Changes the POSITIONth character of STRING to the first character of
VALUE. The first character is at 0.

  (sstr "hello" 1 "a")
  Returns "hallo".


File: editor.inf,  Node: strcasecmp,  Next: strcmp,  Prev: sstr,  Up: General sLisp commands

10.4.27 strcasecmp
------------------

  (strcasecmp S1 S2)

  This function is the same as `strcmp' but this version isn't case
sensitive. *Note strcmp::.


File: editor.inf,  Node: strcmp,  Next: strstr,  Prev: strcasecmp,  Up: General sLisp commands

10.4.28 strcmp
--------------

  (strcmp S1 S2)

  This function compares S1 and S2. The returned value is zero if the
strings are equal, a positive number if S1 comes after S2 in the ASCII
table, else a negative number.


File: editor.inf,  Node: strstr,  Next: strxlt,  Prev: strcmp,  Up: General sLisp commands

10.4.29 strstr
--------------

  (strstr STRING SEARCH [START_POS])

  Searches the string SEARCH in the string STRING starting at START_POS
position. If START_POS is not provided the search is done from the
beginning of STRING. The returned value is the offset of SEARCH in STRING
or -1 if the value wasn't found.

  (strstr "hello" "el")
  Returns 1.


File: editor.inf,  Node: strxlt,  Next: substr,  Prev: strstr,  Up: General sLisp commands

10.4.30 strxlt
--------------

  (strxlt STRING SEARCH REPLACE)

  Searches for the character listed in SEARCH in the passed STRING
replacing each ocurrence by the correponding value found in REPLACE.

  (strxlt "hello" "eo" "12")
  Returns "h1ll2".


File: editor.inf,  Node: substr,  Next: Operator - (substraction),  Prev: strxlt,  Up: General sLisp commands

10.4.31 substr
--------------

  (substr STRING POSITION [LEN])

  Returns LEN characters of STRING starting at the indicated POSITION.  If
LEN is omitted all the characters in the string starting at POSITION are
returned. The first character is at 0.

  (substr "hello" 1 3)
  Returns "ell".

  (substr "hello" 2)
  Returns "llo".


File: editor.inf,  Node: Operator - (substraction),  Next: tostr,  Prev: substr,  Up: General sLisp commands

10.4.32 Operator - (substraction)
---------------------------------

  (- VALUE1 VALUE2)

  Returns the result of substracting VALUE2 from VALUE1. Both variables
must be integer.

  (- 20 3)
  Returns 17.


File: editor.inf,  Node: tostr,  Prev: Operator - (substraction),  Up: General sLisp commands

10.4.33 tostr
-------------

  (tostr VALUE)

  Returns VALUE converted into a string.

  (tostr 2)
  Returns "2".


File: editor.inf,  Node: Editor specific commands,  Next: Writing macros that use text filters,  Prev: General sLisp commands,  Up: sLisp macros

10.5 Editor specific commands
=============================

  This section describes commands related to files being edited.

* Menu:

* AskString::
* BindKey::
* CloseWindowNumber::
* ComplChoose::
* defmacro::
* EvalString::
* FindAgain::
* FindString::
* ForceUpdate::
* GetCursorX::
* GetCursorY::
* GetCurWindowNumber::
* GetMaxWindowNumber::
* GetMaxProjectItem::
* GetProjectItem::
* GetSystemInfo::
* getenv::
* GetSelection::
* GetSyntaxAtCursor::
* GetSyntaxLang::
* GetWrapCol::
* GetWindowCols::
* GetWindowRows::
* InsertText::
* KeyBindings::
* MessageBox::
* OpenFile::
* ReplaceAgain::
* ReplaceString::
* RunProgram::
* RunProgramRedir::
* SelectionExists::
* SelectWindowNumber::
* SendCommands::
* SetCursorXY::
* ShowInMessageWindow::
* ShowInStatusLine::
* WhichEditor::
* WordUnderCursor::


File: editor.inf,  Node: AskString,  Next: BindKey,  Prev: Editor specific commands,  Up: Editor specific commands

10.5.1 AskString
----------------

  (AskString TITLE MESSAGE)

  Pops up a dialog asking for user input. The text is returned as an sLisp
string variable. If the user canceled the input, the string has zero
length.


File: editor.inf,  Node: BindKey,  Next: CloseWindowNumber,  Prev: AskString,  Up: Editor specific commands

10.5.2 BindKey
--------------

  (BindKey KEY_SEQ MACRO)
  (BindKey KEY_SEQ COMMAND ...)

  This command creates a key binding data type. It doesn't change anything
alone and must be used with the `KeyBindings' command.

  You can assign a defined sLisp macro or a piece of sLisp code using the
first syntax. When assigning a sLisp code it must begin with `(' and end
with `)'.

  You can also assign a one command or a sequence of commands using the
second syntax. The commands are specified using the same constants used for
`SendCommands'. *Note SendCommands::.

  The KEY_SEQ argument must be a string containing the key sequence used
to trigger this definition.

  The following example defines two keyboard sequences. The first is
triggered when <Ctrl> and <K> are pressed together, then released and then
<Z> is pressed (all in lower case mode). This sequence moves the cursor
one line up and then one character to the left. The second sequence
(`^K-X') triggers a small sLisp sentence that prints a message in the
message window.

     (KeyBindings
      (BindKey "CtK,Z" cmcLineUp cmcCharLeft)
      (BindKey "CtK,X" "(ShowInMessageWindow 'Hi! ;-)')")
     )

  When writing a key sequence you can use the `Insert key name' menu option
if you don't know the name of a key combination. *Note Insert key name::.

  An important detail is that this command can replace already defined keys
and can even replace a group of assignments by the new definition. You can
assign a command to `CtK' removing all the `^K' assigments during this
operation.


File: editor.inf,  Node: CloseWindowNumber,  Next: ComplChoose,  Prev: BindKey,  Up: Editor specific commands

10.5.3 CloseWindowNumber
------------------------

  (CloseWindowNumber NUMBER)

  Closes the indicated window. The number is interpreted as in
SelectWindowNumber. *Note SelectWindowNumber::.


File: editor.inf,  Node: ComplChoose,  Next: defmacro,  Prev: CloseWindowNumber,  Up: Editor specific commands

10.5.4 ComplChoose
------------------

  (ComplChoose OPTIONS DELIMITER [FLAGS])

  Brings up a floating drop-down list with the options. The OPTIONS
parameter is a delimited string, the delimiter is specified by the
DELIMITER parameter.

  The function returns the option selected by the user or an empty string
if the user aborted.

  The list is sorted alphabetically, the user can choose the item using the
cursors or doing an incremental search. Only characters allowed for
reserved words are accepted, any symbol will choose the currently selected
item, other characters will abort.

  The FLAGS parameter fine tunes the behavior of the routine. Currently
only one thing can be changed. By default the string returned contains the
character that produced the selection appended at the end of the string.
Passing 1 for FLAGS the character isn't concatenated.


File: editor.inf,  Node: defmacro,  Next: EvalString,  Prev: ComplChoose,  Up: Editor specific commands

10.5.5 defmacro
---------------

  (defmacro NAME EXPRESSION)

  Defines a new editor macro called NAME. When this macro is called the
EXPRESSION is evaluated. *Note How to write a sLisp macro::.


File: editor.inf,  Node: EvalString,  Next: FindAgain,  Prev: defmacro,  Up: Editor specific commands

10.5.6 EvalString
-----------------

  (EvalString STRING)

  Executes the sLisp code contained in the STRING variable.


File: editor.inf,  Node: FindAgain,  Next: FindString,  Prev: EvalString,  Up: Editor specific commands

10.5.7 FindAgain
----------------

  (FindAgain)

  Repeats the last search. It should be used when you didn't gave control
to the user since the last search because the user could perform a
different search changing the compiled search. Returns the text found or
an empty string if no match could be found. *Note FindString::.


File: editor.inf,  Node: FindString,  Next: ForceUpdate,  Prev: FindAgain,  Up: Editor specific commands

10.5.8 FindString
-----------------

  (FindString STRING [OPTIONS_FLAGS])

  Performs a search for the provided STRING. Returns the text found or an
empty string if no match could be found. This operation moves the cursor
position as in an interactive search. The match becomes temporally
highlighted in the text.

  Even when the OPTIONS_FLAGS argument is optional it is strongly
recommended to provide it. If nothing is provided the user options will be
used instead. The options are provided as flags combined with the `|'
operand. Some of the flags doesn't have any sense when combined with
others, you should avoid doing it. The available flags are:

Search style:

   * edfCaseSensitive: perform a case sensitive search.

   * edfWholeWordsOnly: don't match partial words.

   * edfRegularEx: the string is a regular expression. Note this flag must
     be indicated in adition to the type of regular expressions used.

Scope:

   * edfSearchInComm: search only inside comments.

   * edfSearchOutComm: search only outside comments.

   * edfOnlySelection: search only inside the selected text.

   * edfFromCursor: start searching from the cursor position. That's the
     default action.

   * edfFromBeggining: start searching from the beggining of the selected
     scope.

Regular expressions options:

   * edfBasicRegEx: use basic POSIX regular expressions. Used in
     combination with edfRegularEx.

   * edfExtendedRegEx: use extended POSIX regular expressions. Used in
     combination with edfRegularEx.

   * edfPerlRegEx: use Perl regular expressions. Used in combination with
     edfRegularEx.

   * edfOptimizeRegEx: if the string to search doesn't contain special
     characters and regular expressions are enabled perform a normal
     search. This makes the search much more faster. This is the default
     action so you don't really need to specify this flag.

   * edfNoOptimizeRegEx: it is the opposite of edfOptimizeRegEx flag. It
     disables the optimization. Use it when you are sure the string is a
     regular expression even when it doesn't look like a regular
     expression. This option was created just in case the optimization
     fails to detect a real regular expression.

Others:

   * edfShowFuncName: display the name of the function where the match was
     found in the status line.

  A very important detail about regular expressions: In sLisp the `\'
character is the escape character. It means that you have to use `\\' to
get `\'.

  The following example searchs for the `Hello' word followed by a digit
using Perl regular expressions. Then prints the result of the search in the
message window and after it repeats the search.

     (eval
      (= "str" (FindString "Hello\\d" (| edfRegularEx edfPerlRegEx)))
      (if str
         (ShowInMessageWindow (+ "Found: " str))
         (ShowInMessageWindow "Not found.")
      )
      (= "str" (FindAgain))
      (if str
         (ShowInMessageWindow (+ "Found: " str))
         (ShowInMessageWindow "Not found.")
      )
     )

  To learn more about the search options consult the find command (*note
Find::) and the regular expression options (*note Regular Expressions
Options::). You could be also interested in learning more about POSIX
regular expressions (*note Regular Expressions::), for Perl regular
expressions consult some Perl reference. This command is complemented by
`FindAgain' (*note FindAgain::), `ReplaceString' (*note ReplaceString::)
and `ReplaceAgain' (*note ReplaceAgain::) commands.


File: editor.inf,  Node: ForceUpdate,  Next: GetCursorX,  Prev: FindString,  Up: Editor specific commands

10.5.9 ForceUpdate
------------------

  (ForceUpdate)

  It forces an update at this point of the macro. That's useful if you want
to stop to ask the user something or the macro will take some time to
complete and don't want to give the impression the editor hangs.


File: editor.inf,  Node: GetCursorX,  Next: GetCursorY,  Prev: ForceUpdate,  Up: Editor specific commands

10.5.10 GetCursorX
------------------

  (GetCursorX)

  Returns the X cursor coordinate. Note the coordinates are computed from
zero.


File: editor.inf,  Node: GetCursorY,  Next: GetCurWindowNumber,  Prev: GetCursorX,  Up: Editor specific commands

10.5.11 GetCursorY
------------------

  (GetCursorY)

  Returns the Y cursor coordinate. Note the coordinates are computed from
zero.


File: editor.inf,  Node: GetCurWindowNumber,  Next: GetMaxWindowNumber,  Prev: GetCursorY,  Up: Editor specific commands

10.5.12 GetCurWindowNumber
--------------------------

  (GetCurWindowNumber)

  Returns the window number for the currently selected edition window.


File: editor.inf,  Node: GetMaxWindowNumber,  Next: GetMaxProjectItem,  Prev: GetCurWindowNumber,  Up: Editor specific commands

10.5.13 GetMaxWindowNumber
--------------------------

  (GetMaxWindowNumber)

  Returns the window number for the edition window with the biggest window
number. The lowest number is two.


File: editor.inf,  Node: GetMaxProjectItem,  Next: GetProjectItem,  Prev: GetMaxWindowNumber,  Up: Editor specific commands

10.5.14 GetMaxProjectItem
-------------------------

  (GetMaxProjectItem)

  Returns the number of items in the current project. If no project is
opened it returns zero. You can retreive the project items using
`GetProjectItem'. *Note GetProjectItem::.


File: editor.inf,  Node: GetProjectItem,  Next: GetSystemInfo,  Prev: GetMaxProjectItem,  Up: Editor specific commands

10.5.15 GetProjectItem
----------------------

  (GetProjectItem NUMBER)

  Returns the name of the nth item in the current project. If no project is
opened or the number is invalid the function returns an empty string.  You
can know how many items have the current project using
`GetMaxProjectItem'. *Note GetMaxProjectItem::.


File: editor.inf,  Node: GetSystemInfo,  Next: getenv,  Prev: GetProjectItem,  Up: Editor specific commands

10.5.16 GetSystemInfo
---------------------

  (GetSystemInfo WHICH)

  Returns information about the system and similar stuff. The WHICH
argument selects which kind of information is returned. Available values
are:

   * edfInfTVDriver: The short name of the Turbo Vision driver in use.
     Some of the possible drivers are: DOS, Linux, QNX, QNX4, UNIX, Win32,
     WinGr, WinNT, X11 and XTerm.

   * edfInfOS: The name of the operating system. Some of the possible
     names are: DOS, UNIX and Win32.

   * edfInfOSFlavor: Some of the possible flavors are: Linux, FreeBSD,
     Solaris and QNXRtP.

   * edfInfCPU: The CPU family used to compile the editor. Some of the
     possible names are: x86, Alpha, SPARC64, SPARC, PPC, HPPA, MIPS,
     Itanium and Unknown.

   * edfInfCompiler: The compiler used to compile the editor. Some of the
     possible compilers are: GCC, BCPP and MSVC.

   * edfInfCompilerFlavor: Some of the possible flavors are: djgpp, MinGW
     and Cygwin.


File: editor.inf,  Node: getenv,  Next: GetSelection,  Prev: GetSystemInfo,  Up: Editor specific commands

10.5.17 getenv
--------------

  (getenv NAME)

  This command returns the content of the environment variable called
NAME. Internal variables of the editor are also accessable. If the
variable doesn't exist an empty string is returned.


File: editor.inf,  Node: GetSelection,  Next: GetSyntaxAtCursor,  Prev: getenv,  Up: Editor specific commands

10.5.18 GetSelection
--------------------

  (GetSelection)

  This command returns the selected text in the editor as a sLisp string.
*Note How to write a sLisp macro::.


File: editor.inf,  Node: GetSyntaxAtCursor,  Next: GetSyntaxLang,  Prev: GetSelection,  Up: Editor specific commands

10.5.19 GetSyntaxAtCursor
-------------------------

  (GetSyntaxAtCursor)

  This command returns the syntax highlighting flags for the cursor
position.  That's very specific and can be used to find out if the cursor
is inside a comment, string or preprocessor code.

  To understand how it works use the following macro and trigger it in many
places to see what you get:

     (defmacro 'Test edfWE'
       (eval
        (ShowInStatusLine (+ "" (GetSyntaxAtCursor)))
       )
     )

  The following table explains the flags returned:

   * edfComInside
     - Meaning: Inside an end-of-line comment

   * edfEndCom
     - Meaning: This line ends a multiline comment

   * edfEndCom2
     - Meaning: This line ends a multiline comment type 2

   * edfExtCom
     - Meaning: This line extends a multiline comment

   * edfExtCom2
     - Meaning: This line extends a multiline comment type 2

   * edfExtOneLineCom
     - Meaning: The end-of-line comment is extended to the next line

   * edfExtPrepro
     - Meaning: The preprocessor line follows in the next

   * edfExtString
     - Meaning: Inside a string

   * edfExtString2
     - Meaning: Inside a string type 2

   * edfExtString3
     - Meaning: Inside a string type 3

   * edfInsideCom
     - Meaning: Inside a multiline comment

   * edfInsideCom2
     - Meaning: Inside a multiline comment type 2

   * edfPrepro
     - Meaning: Inside preprocessor code

   * edfStartCom
     - Meaning: This line starts a multiline comment

   * edfStartCom2
     - Meaning: This line starts a multiline comment type 2

   * edfStartInCom
     - Meaning: This line is commented out by the previous

   * edfStartInCom2
     - Meaning: This line is commented out by the previous (type 2)

   * edfStartString
     - Meaning: This line startes inside a string

   * edfStartString2
     - Meaning: This line startes inside a string type 2

   * edfStartString3
     - Meaning: This line startes inside a string type 3


  Something very important is that the editor will only analyze the line up
to the cursor's position. So if the cursor is inside a string the editor
will think this line extends a string.


File: editor.inf,  Node: GetSyntaxLang,  Next: GetWrapCol,  Prev: GetSyntaxAtCursor,  Up: Editor specific commands

10.5.20 GetSyntaxLang
---------------------

  (GetSyntaxLang)

  Returns the language used for syntax highlight in the current editor. If
none syntax highlight is in use it returns an empty string.


File: editor.inf,  Node: GetWrapCol,  Next: GetWindowCols,  Prev: GetSyntaxLang,  Up: Editor specific commands

10.5.21 GetWrapCol
------------------

  (GetWrapCol [window_number])

  Returns the wrap column setting for the specified window. If you don't
specify a window number then the current window number is used. If the
specified value is invalid this function returns 0.


File: editor.inf,  Node: GetWindowCols,  Next: GetWindowRows,  Prev: GetWrapCol,  Up: Editor specific commands

10.5.22 GetWindowCols
---------------------

  (GetWindowCols [window_number])

  Returns the number of visible columns in the specified window. If you
don't specify a window number then the current window number is used. If
the specified value is invalid this function returns 0.


File: editor.inf,  Node: GetWindowRows,  Next: InsertText,  Prev: GetWindowCols,  Up: Editor specific commands

10.5.23 GetWindowRows
---------------------

  (GetWindowRows [window_number])

  Returns the number of visible columns in the specified window. If you
don't specify a window number then the current window number is used. If
the specified value is invalid this function returns 0.


File: editor.inf,  Node: InsertText,  Next: KeyBindings,  Prev: GetWindowRows,  Up: Editor specific commands

10.5.24 InsertText
------------------

  (InsertText STRING [SELECTED [MOVE]])

  Inserts the STRING at the cursor's position. By default the cursor is
moved behind the insertion and the inserted text isn't selected. If
SELECTED is 1 the text is selected. If the MOVE parameter is 0 the cursor
isn't moved and if the parameter is 1 the action depends on the current
editor's setup.


File: editor.inf,  Node: KeyBindings,  Next: MessageBox,  Prev: InsertText,  Up: Editor specific commands

10.5.25 KeyBindings
-------------------

  (KeyBindings KEY_BINDING ...)

  Adds the KEY_BINDING to the keyboard definitions. As the operation to
insert a key in the keyboard definitions is slow this command is used to
group all the operations in just one operation. Currently the only command
that returns a key binding is `BindKey'. *Note BindKey::.

  It returns zero if the operation failed and one if the operation succeed.
If any of the specified key bindings fails the keyboard configuration isn't
altered.


File: editor.inf,  Node: MessageBox,  Next: OpenFile,  Prev: KeyBindings,  Up: Editor specific commands

10.5.26 MessageBox
------------------

  (MessageBox MESSAGE [OPTIONS])

  Pops up a small dialog showing the MESSAGE to the user. The OPTIONS can
take the following values (use 'or' to combine them):

   * edfMBCancelButton: has a `Cancel' button.

   * edfMBNoButton: has a `No' button.

   * edfMBOKButton: has an `Ok' button.

   * edfMBOKCancel: has an `Ok' and a `Cancel' button.

   * edfMBYesButton: has a `Yes' button.

   * edfMBYesNoCancel: has a `Yes', a `No' and a `Cancel' button.

   * edfMBConfirmation: use Confirmation as caption.

   * edfMBError: use Error as caption.

   * edfMBInformation: use Information as caption.

   * edfMBWarning: use Warning as caption.


File: editor.inf,  Node: OpenFile,  Next: ReplaceAgain,  Prev: MessageBox,  Up: Editor specific commands

10.5.27 OpenFile
----------------

  (OpenFile STRING [SELECT])

  Opens the file STRING in a window and makes it the current one. If the
file doesn't exist it does nothing. If the file fails to be loaded returns
0.  If the file was already opened returns 2 and if the file was opened 1.

  If the SELECT value isn't 0 the opened file is selected.


File: editor.inf,  Node: ReplaceAgain,  Next: ReplaceString,  Prev: OpenFile,  Up: Editor specific commands

10.5.28 ReplaceAgain
--------------------

  (ReplaceAgain)

  Repeats the last search and replace operation. It should be used when you
didn't gave control to the user since the last search because the user
could perform a different search changing the compiled search. Returns a
boolean value indicating the status of the last search. *Note
ReplaceString::.


File: editor.inf,  Node: ReplaceString,  Next: RunProgram,  Prev: ReplaceAgain,  Up: Editor specific commands

10.5.29 ReplaceString
---------------------

  (ReplaceString STRING REPLACEMENT [OPTIONS_FLAGS])

  Performs a search and replace operation. Returns a boolean value
indicating the status of the last search. Consult the `Find' command
(*note FindString::) and the replace options of the editor (*note
Replace::) for more information.

  In addition to the `Find' options you have the following options:

   * edfPromptOnReplace: ask confirmation to the user.

   * edfReplaceAll: repeat the search and replace operation until no match
     can be found in the current scope.

   * edfNormalText: used to indicate that the REPLACEMENT string is a
     simple text and not a replacement template. This is the default
     behavior.

   * edfTagsText: used to indicate that the REPLACEMENT string contains
     `$n' tags. For more information consult the section for the regular
     expressions dialog of the editor (*note Regular Expressions
     Options::).

  The following example searchs for the `Hello' word followed by a digit
using Perl regular expressions and replaces the text by the digit followed
by an space and the `Bye' word. Then prints the result of the operation in
the message window.

     (eval
      (if (ReplaceString "Hello(\\d)" "$1 Bye"
           (| edfRegularEx edfPerlRegEx edfTagsText))
       (ShowInMessageWindow "Replaced.")
       (ShowInMessageWindow "Not replaced.")
      )
     )


File: editor.inf,  Node: RunProgram,  Next: RunProgramRedir,  Prev: ReplaceString,  Up: Editor specific commands

10.5.30 RunProgram
------------------

  (RunProgram PROGRAM_NAME [[FLAGS] PARSER])

  Calls the desired program. You can pass more than one using the `;'
separator or any separator supported by your shell. Under DOS `;' is ok
even when command.com doesn't support it. The stderr and stdout are
redirected and captured by the message window of the editor.

  Use the operator `+' to concatenate strings and pass arguments.

  Using `edfRunUserScreen' for the FLAGS argument the editor will use the
user screen when running the external program. Using `edfRunNoRedirect'
the editor won't redirect the standard output. For interactive
applications that uses standard input and output you should both flags
combined using the or operator. *Note Operator | (bitwise or)::.

  Another option you can use is `edfRunStopDebug'. This option will stop
any active debug session. That's a very delicated option and can be used
when the macro is calling a compiler to rebuild an executable. In some OSs
you must stop the debugger in order to be able to overwrite the executable.
Additionaly gdb have some bugs that needs it as workaround.

  The PARSER parameter tells the editor which error parser will be used to
parse the output of the external program. By default the GNU one is used.

  To learn more about the message window *Note Message Window::.


File: editor.inf,  Node: RunProgramRedir,  Next: SelectionExists,  Prev: RunProgram,  Up: Editor specific commands

10.5.31 RunProgramRedir
-----------------------

  (RunProgramRedir PROGRAM_NAME [INPUT_TEXT])

  This function is similar to RunProgram, but the result isn't dumped to
the message window, instead the output of the program is returned as a
string.

  Additionally you can specify a text to send to the standard input of the
program you are calling. You can easily call external filters with it. I
provide an example of how to replace a selected text with the output of an
external filter in the `macros.slp' file. *Note Configuration files
location::.

  Be careful, that's a very powerful command, but very dangerous too.


File: editor.inf,  Node: SelectionExists,  Next: SelectWindowNumber,  Prev: RunProgramRedir,  Up: Editor specific commands

10.5.32 SelectionExists
-----------------------

  (SelectionExists)

  Returns 1 if some text is selected and the selection is visible.


File: editor.inf,  Node: SelectWindowNumber,  Next: SendCommands,  Prev: SelectionExists,  Up: Editor specific commands

10.5.33 SelectWindowNumber
--------------------------

  (SelectWindowNumber NUMBER)

  Selects the indicated window. Positive numbers are reserved for edition
windows, except window number one that's the project window. Negative
numbers are used for special windows. The function returns a boolean value
indicating if the desired window was selected.

  When you select an edition window it becomes the target of all sLisp
operations.

  The available constants for special windows are:

   * edfWinASCII

   * edfWinCalendar

   * edfWinClipboard

   * edfWinHelp

   * edfWinMP3

   * edfWinMan

   * edfWinMessage

   * edfWinPrj


File: editor.inf,  Node: SendCommands,  Next: SetCursorXY,  Prev: SelectWindowNumber,  Up: Editor specific commands

10.5.34 SendCommands
--------------------

  (SendCommands COMMAND ...)

  Sends all the listed commands to the editor. The editor commands are
sLisp constants that start with `cmc'. These commands are the same
explained in the keyboard section as `cmcXXXXX'.


File: editor.inf,  Node: SetCursorXY,  Next: ShowInMessageWindow,  Prev: SendCommands,  Up: Editor specific commands

10.5.35 SetCursorXY
-------------------

  (SetCursorXY X [Y])

  Sets the cursor coordinates. Note the coordinates starts from zero. If
the Y argument is omitted only the X coordinate is changed. This function
returns the current Y coordinate, it doesn't have to be the same value you
indicated in the Y argument because the editor limits this value to the
last line in the current buffer.


File: editor.inf,  Node: ShowInMessageWindow,  Next: ShowInStatusLine,  Prev: SetCursorXY,  Up: Editor specific commands

10.5.36 ShowInMessageWindow
---------------------------

  (ShowInMessageWindow STRING [CLEAR])

  Prints the desired string in the message window. That's a very good way
to show a result to the user.

  If the message window isn't selected or visible it gets the focus and
becomes visible. The optional parameter allows you to clean the contents of
the window. *Note Message Window::.


File: editor.inf,  Node: ShowInStatusLine,  Next: WhichEditor,  Prev: ShowInMessageWindow,  Up: Editor specific commands

10.5.37 ShowInStatusLine
------------------------

  (ShowInStatusLine STRING)

  Prints the passed string in the status line of the current editor. Tabs
are converted to one space and the message stops at the first carriage
return or line feed. That's a very good way to show a result to the user.


File: editor.inf,  Node: WhichEditor,  Next: WordUnderCursor,  Prev: ShowInStatusLine,  Up: Editor specific commands

10.5.38 WhichEditor
-------------------

  (WhichEditor [OPTION])

  This command takes one optional parameter and returns the file name of
the current file under edition.

  The optional parameter can be:

   * edfWEFull (0)
     - Meaning: Full name and path
        - Example: `c:/temp/test.txt'

   * edfWEFullNoExt (1)
     - Meaning: Same as 0 but without extension
        - Example: `c:/temp/test'

   * edfWEPath (2)
     - Meaning: Path for the file
        - Example: `c:/temp/'

   * edfWEDisk (3)
     - Meaning: Disk drive
        - Example: `c:'

   * edfWEExtension (4)
     - Meaning: File extension
        - Example: `.txt'

   * edfWENameNoExt (5)
     - Meaning: Name without extension
        - Example: `test'



File: editor.inf,  Node: WordUnderCursor,  Prev: WhichEditor,  Up: Editor specific commands

10.5.39 WordUnderCursor
-----------------------

  (WordUnderCursor [MAX_LENGTH [OPTIONS]])

  This command takes one optional parameter and returns the word that's
located under the cursor. That's very useful for things like searching
help about the function the user is typing or things like that.

  The maximum length is optional and if you don't specify it 256 is used.
Values under 4 or over 32768 are adjusted to fit this range for security
issues.

  The OPTIONS parameter is 0 by default. Passing 1 the editor will return
the word located to the left of the cursor, if the cursor is located at
the first character after this word.


File: editor.inf,  Node: Writing macros that use text filters,  Prev: Editor specific commands,  Up: sLisp macros

10.6 Writing macros that use text filters
=========================================

  The sLisp language provides the commands needed to take a selected text,
pass it to an external program, and collect their output. You can finally
replace the original text by the new text. This kind of programs are
usually called filters. Some applications of this are complex recoding
using GNU recode, text formating, code indentation using GNU indent, `etc.'

  The following sections were contributed by Grzegorz Adam Hankiewicz and
explains how to use this feature.

* Menu:

* How to use Setedit for something it was not meant to::


File: editor.inf,  Node: How to use Setedit for something it was not meant to,  Prev: Writing macros that use text filters,  Up: Writing macros that use text filters

10.6.1 How to use Setedit for something it was not meant to
-----------------------------------------------------------

SET has always said that setedit is not a word processing program. He's
right, it's best at doing things like programming. But once you get used
to it the road to building another emacs is clear: you start wanting to
use it even to cook your breakfast. This document, however, centers on how
to control text format easily under setedit, which is not that ambitious :)

As you will notice, in some version SET added the "word wrap" option. IMHO
it should be removed, if you try to use it, it will behave quite
differently from what you expect (ie: if you are writting tabbed lines,
the editor will ignore them and puts your cursor right away in the first
column ignoring any possible autoindentation options and tab uses you
might have set for the document). Also, it's setedit's choice of
characters which will be used to split the line. Bleah... it really sucks.

But setedit is customizable. You can write macros in a lisp like language.
The language still doesn't allow you to control tightly things like text
formatting, but there's one cool option: you can pipe a block selection to
another external program and the editor will substitute it with the output
of this external program. Certainly not the most optimized way of doing
things, but flexible enough to write a custom extension which treats your
text.

And here we go... the purpose will be to create a macro, which feeds a
text block to an external program which we will write. Simple as that, all
the power you wanted at your finger tips.

* Menu:

* Step 1 - Building your macro::
* Step 2 - The filter program::
* Step 3 - Binding your script to a keystroke::
* Examples::


File: editor.inf,  Node: Step 1 - Building your macro,  Next: Step 2 - The filter program,  Prev: How to use Setedit for something it was not meant to,  Up: How to use Setedit for something it was not meant to

10.6.1.1 Step 1 - Building your macro
.....................................

Macros are written in sLisp, and stored somewhere in a `macros.slp' file.
This file can be a global read-only file or it can be located at
`~/.setedit/macros.slp'.  It's pure text, and somewhere (ie: at the end of
the file) you will insert the following chunk of code:

     ;*******************************************************************
     ;
     ; MACRO:   Block reformat
     ;
     ; DESCRIPTION: This script gets the current selection and feeds it to
     ; an external program. If no selection is present a message box will
     ; be printed.
     ;
     ;*******************************************************************/

     (defmacro 'Block reformat'
      (eval
       (setv "input" (GetSelection))
       (if (length input)
        ; Call the filter
        (eval
         (setv "output"
          (RunProgramRedir
           ; filter line here
           "~/project/email-fmt.py/email-fmt.py "
           input
          )
         )
         (SendCommands cmcCut)
         (InsertText output 1)
        )
        ; Ask the user to select something first
        (MessageBox "Please select a text first")
       )
      )
     )

Ok, don't worry about the syntax of the macro or how it's written, if you
are curious you can take a look at setedit's documentation to find out
what all that mess means. The important line is the one which follows the
comment `; filter line here'. That line is actually the path to the
external program we will be using, which can be stored anywhere on your
computer, it only needs to have execution permission. I am the only user
of my machine, so I don't need to put things under /local/bin to feel
comfortable :) Please change that to point at your filter script.


File: editor.inf,  Node: Step 2 - The filter program,  Next: Step 3 - Binding your script to a keystroke,  Prev: Step 1 - Building your macro,  Up: How to use Setedit for something it was not meant to

10.6.1.2 Step 2 - The filter program
....................................

The filter program has to be simple: receives text lines as input and
prints the result to stdout. You can say: `Hey! that calls some weird
Python script which I don't have... why don't I call GNU's fmt command
instead?'.  Good point. Do it. If you are meaning to write simple texts
that's ok. In fact, after the command you can specify parameters to fmt
like the width of the lines, and there you go, you have a text formatting
macro in Setedit. But if you are meaning to answer emails (ie: setedit is
your default editor and mail programs like mutt call it to write messages)
or do something more sophisticated, you better use something like this
(big chunk of code follows):

     #!/usr/bin/env python

     import sys, popen2, tempfile, os

     class LINE:
        pass

     indentation = " \t>:;#"

     def detect_indentation_characters(line):
        """Returns number of indentation chars minus trailing whitespace."""
        count = 0
        for f in line:
           if f in indentation: count = count + 1
           else: break

        return len(line[:count].rstrip()), count

     def initial_scan(line):
        """Add attributes to the lines."""
        l = LINE()
        l.line = line
        l.total_length = len(line)
        l.ident, l.soft_ident = detect_indentation_characters(line)
        l.length = l.total_length - l.soft_ident
        return l

     def same_indentation_lines(lines):
        """Returns number of lines with same indentation level."""
        f = 1
        while f < len(lines):
           if lines[f].ident != lines[0].ident:
              break
           else:
              f = f + 1

        return f

     def reformat_lines(lines, temp_filename):
        """Dumps lines in list to file, the reads fmt's output."""
        assert lines
        ident = lines[0].ident
        length = max (70 - ident, 20)

        # create temporary file with content to ident
        file = open(temp_filename, "wt")
        num = 0
        while num < len(lines):
           string = lines[num].line[ident:]
           stripped = string.lstrip()
           if stripped:   file.write(stripped)
           else:          file.write(string)
           num += 1
        file.close()

        # call external tool and read it's stdout
        stdout, stdin = popen2.popen2 (["fmt", "-w", "%d" % length,
           "-u", temp_filename])
        stdin.close()
        if ident:   padding = "%s " % lines[0].line[:ident]
        else:       padding = ""
        new_lines = stdout.readlines()
        stdout.close()
        os.unlink(temp_filename)

        # output lines, taking care of last line's trailing '\n'
        for f in range(len(new_lines)-1):
           sys.stdout.write("%s%s" % (padding, new_lines[f]))
        if lines[num-1].line.find("\n") >= 0:
           sys.stdout.write("%s%s" % (padding, new_lines[-1:][0]))
        else:
           sys.stdout.write("%s%s" % (padding, new_lines[-1:][0][:-1]))

     def main():
        lines = map(initial_scan, sys.stdin.readlines())
        temp_filename = tempfile.mktemp(".email-fmt.tmp")

        f = 0
        while f < len(lines):
           look = same_indentation_lines(lines[f:])
           reformat_lines(lines[f:f+look], temp_filename)
           f = f + look

     if __name__ == "__main__":
        main()
     # end of python code

Woah, that's more than the previous script. True, but this 86 line Python
script is a cool wrapper: fmt doesn't know exactly how you want to format
your text. If you are replying somebody's email, some text will have
quotes. Wouldn't it be nice if fmt could detect them? Yes, but it doesn't.
Remember that the unix style is doing one simple thing, but doing it
extremely well.

So we solve this with the Python script. It isn't really long (try
removing blank lines and comments), and it's pretty clear (to any
experienced functional programmer) what it does. It scans the sent block
of text for existant quote characters like those defined in the
indentation variable, which are used frequently by most email programs.
These lines will be kept together, and the script will call fmt with them,
but removing the quote characters and reducing the line width. To the
result, the script will add the apropiate quote indentation level.

This means that you can select say 20 lines of text which contain three
different quote indentation levels.  If these use the defined indentation
characters the script will split them, format them separately and join
them before returning them to setedit. The result is obvious: a cool
formatting feature which is cumbersome to build into setedit, and which
can be customized any way you want. You can write your script in Python,
ruby, perl, C, etc, etc... you put the limit, not the program.


File: editor.inf,  Node: Step 3 - Binding your script to a keystroke,  Next: Examples,  Prev: Step 2 - The filter program,  Up: How to use Setedit for something it was not meant to

10.6.1.3 Step 3 - Binding your script to a keystroke
....................................................

Nice, we have the macro, we have the script, but how do we run it? In a
horrible world you would have to reproduce these steps to format a text
block:

   * Select text block

   * Open macro menu

   * Select `Select...'

   * Choose the macro

If you did it once, you can repeat the macro with `Shift+F3', but this is
not nice, it prevents you from running other macros and you aren't saved
from the punishment of doing all that once each time you run setedit, and
since we want this for email replies, the editor will be run independently
for each answer. Ugh!

Luckily you can bind a macro to a key (*note Assigning a sLisp macro::).
The option is located under the menu option called Tool&Ops, submenu
Options, submenu Keyboard, submenu Key assignment. Once you reach that,
you can see all the key bindings for the editor. Notice that none seem to
use Alt for keystrokes, which is nice because you can assume they are free
for customizing. So you just have to type a nice combo. I use `Alt+F' for
"Formatting". Once you have the combo you assign the macro "Block
reformat" to it.

Say ok to all menus and try it yourself: write a few lines with only a
word in each of them. Select those lines and press `Alt+F'. If you did it
right you will see all those words formatted in a single paragraph. Now
try that with email indentation. Think of all the possibilities of using
this trick along with the "rectangle selection" feature of the editor.


File: editor.inf,  Node: Examples,  Prev: Step 3 - Binding your script to a keystroke,  Up: How to use Setedit for something it was not meant to

10.6.1.4 Examples
.................

I prepared some examples so you could see the good things of all this
work. All the examples are the result of selecting all lines and using the
macro. You can easily reproduce them yourself.

Written in setedit:

      So I am just     a lazy boy typing this
      which I know will be
         formatted correctly with that cool
          python script                     written by a
            guy with funny name.

After the `Alt+F' combo:

     So I am just a lazy boy typing this which I know will be formatted
     correctly with that cool python script written by a guy with
     funny name.

Written in setedit:

     On  9 Jan 01 at 14:25, Grzegorz Adam Hankiewicz wrote:
     > On Sun, 7 Jan 2001, Petr Vandrovec wrote:
     > > (2) you can specify only xres 'x' yres '-' bpp '@' fv, you cannot
     > >     specify for example horizontal/vertical sync polarity, sync-on-green
     > >     mode, or even shift picture left-right (modify
     > >     left/right/upper/lower/hslen/vslen fields of var_screeninfo)
     > >
     > > First problem is probably unresolvable without linking modedb to each
     > > fbdev separately, as if you removing __init, others will come to you
     > > with big staff.
     > >
     > > Second problem is probably only 'invent how to write it' problem... You
     > > can look at matroxfb picture size/refresh related parameters - all of
     > > them should be parsed by modedb for benefit of all drivers...
     >
     > Aha.. do you mean I have to add new options and switches to modedb, taking
     > out the parsing code from the matroxfb module? For example, adding new
     > modedb functions which have more parameters, to remain backwards
     > compatible with the existant code?

     In my opinion it should still take one char* and...

After the Alt+F combo:

     On 9 Jan 01 at 14:25, Grzegorz Adam Hankiewicz wrote:
     > On Sun, 7 Jan 2001, Petr Vandrovec wrote:
     > > (2) you can specify only xres 'x' yres '-' bpp '@' fv, you
     > > cannot specify for example horizontal/vertical sync polarity,
     > > sync-on-green mode, or even shift picture left-right (modify
     > > left/right/upper/lower/hslen/vslen fields of var_screeninfo)
     > >
     > > First problem is probably unresolvable without linking modedb
     > > to each fbdev separately, as if you removing __init, others will
     > > come to you with big staff.
     > >
     > > Second problem is probably only 'invent how to write it'
     > > problem... You can look at matroxfb picture size/refresh related
     > > parameters - all of them should be parsed by modedb for benefit
     > > of all drivers...
     >
     > Aha.. do you mean I have to add new options and switches to modedb,
     > taking out the parsing code from the matroxfb module? For example,
     > adding new modedb functions which have more parameters, to remain
     > backwards compatible with the existant code?

     In my opinion it should still take one char* and...


File: editor.inf,  Node: Calculator,  Next: How to contact me,  Prev: sLisp macros,  Up: Top

11 Calculator
*************

  The calculator inside the editor was originally made by Laszlo Molnar.
Laszlo is a friend of mine from Hungary and is the author of the great DJP
progam (a djgpp exe compressor and now UPX, the best EXE compressor in all
the categories). Currently the editor is compiled with a new calculator
with some advanced features. This new calculator have the same features
plus some interesting additions and was developed by Burton Radons.

  The sources of the calculator are in the `parser.c' file. They are free
and you can use it for any purpose. There are three sources.

  Here is the documentation of the calculator written by Laszlo:

  The purpose of this program is to provide a simple but powerful
'calculator' for programmers, to help with coding and debugging, where
GDB's expression evaluator is not enough.

  You may say "Hey, I can write a better one with `flex' and `bison'", and
you may be right. I can make a better one too. But it'll be 4-5 times
longer!  This calculator is only 10 kbytes of C code. What I think? It's
not that bad.

  The parser algorithm I use is called 'Operator Precedence Parsing' (I
translated this from Hungarian, so I may be wrong ;-). It works with
'operator precedence grammars' (a subset of LR(1) grammars), which means
that there can't be two non-terminating tokens next to each other on the
right side of your grammar rules. It's ideal for expression evaluation.

  With this parser you can use numbers, operators, parentheses and
functions like in C.

Here are the operators in decreasing precedence:

  1. `~' unary not `-' unary minus

  2. `**' power

  3. `*' multiplication `/' division `%' modulo

  4. `+' plus `-' binary minus

  5. `<<' shift left `>>' shift right

  6. `<' less than * `<=' less or equal than * `>' greater than * `>='
     greater or equal than *

  7. `==' equal to * `!=' different than *

  8. `&' bitwise and

  9. `^' bitwise xor

 10. `|' bitwise or

 11. `&&' logical and *

 12. `||' logical or *

 13. `?:' conditional *

  The operators marked with asterisk are available only in Burton's
version.

  The calculator includes the following functions: `sin, cos, tan, sinh,
cosh, tanh, asin, acos, atan, log, log10, exp, abs, sqrt, ceil' and
`floor'.  They work as you expect.  Additionally the calculator provides
some radix conversion routines: `bin, oct, dec' and `hex'.

  The calculator uses doubles, but you can use numbers in the usual integer
formats also: 0x... for base 16, 0b... for base 2 and 0... for base 8.
The result of the calculation is displayed as a double for base 10, and
converted to long long format for the other radixes.

  In addition the new calculator has the following features:

  You can define variables just by assigning a value to them. So if you
enter `x=5' you can use `x' in other calculation like this `x**2'. You can
also use the C/C++ assign plus operation. Post and pre increment and
decrement are also available.

  You can define functions like this `f(x)=x**2+2' so then entering `f(5)'
will give as result `27'.

  The C/C++ conditionals are available, so the following: `f(5)>=27 ? 6 :
2' will give `6' assuming you defined `f(x)' as in the above example.

  You can separate operations with commas as in C. The result of the last
operation is the result of the compound.


File: editor.inf,  Node: How to contact me,  Next: TAGS files,  Prev: Calculator,  Up: Top

12 How to contact me
********************

  If you have any suggestions or a bug report contact me at the address
shown in the author section. *Note About the Author::.

* Menu:

* Bugs::


File: editor.inf,  Node: Bugs,  Prev: How to contact me,  Up: How to contact me

12.1 Bugs
=========

  If you find a bug please contact me, the Undo thing is the most complex
one and I know that needs some work on it.

  When reporting a bug please don't tell me: Some times some strange thing
happens ... Try to find a pattern to the problem. What situation triggers
the problem? ... with which file(s)? Then send me the file and the
description.

  When sending me a file UUEncode it to avoid problems related with e-mail.


File: editor.inf,  Node: TAGS files,  Next: Debugging,  Prev: How to contact me,  Up: Top

13 TAGS files
*************

This chapter describes some details about `TAGS' files. They are
referreded as tags in the rest of the sections.

I wrote a small ilustrated tutorial showing how to quickly use this. The
tutorial is available in the editor home page:
http://setedit.sf.net/tags.html. It is also included in some of the
distributions of the editor.

I strongly recommend reading the documentation of the program to generate
the tag files.

* Menu:

* What are tags?::
* Which program is used to generate TAGS files?::
* How should I generate the tags?::
* Can these files be created and updated by the editor?::
* What is the easiest way to use tags?::
* What can I do with tags?::
* Technical details about tags::


File: editor.inf,  Node: What are tags?,  Next: Which program is used to generate TAGS files?,  Prev: TAGS files,  Up: TAGS files

13.1 What are tags?
===================

TAGS files are plain text files containing a list of symbols from your
source code. For each symbol the file indicates in which file it's located
and how to find the symbol inside the file. Modern programs also include
very important information like which type of symbol is defined and if
this symbol is part of a bigger construct like a class.

This information is very useful to do searches. The editor implements
facilities to jump to any defined symbol, browse classes and do word
completion using information from tag files.


File: editor.inf,  Node: Which program is used to generate TAGS files?,  Next: How should I generate the tags?,  Prev: What are tags?,  Up: TAGS files

13.2 Which program is used to generate TAGS files?
==================================================

A lot of programs generate tag files but the editor uses special features
only found in the `Exuberant Ctags' program. For this reason I recommend
using this program to generate the tag files. You can find this program at
Source Forge (http://ctags.sourceforge.net).


File: editor.inf,  Node: How should I generate the tags?,  Next: Can these files be created and updated by the editor?,  Prev: Which program is used to generate TAGS files?,  Up: TAGS files

13.3 How should I generate the tags?
====================================

It depends on your project and how you compile the project. It also
depends on how fast your system is. I currently use a tags file for the
editor and another for the Turbo Vision library. The best is to refresh the
tags file using the same makefile you use to compile your project. If your
system isn't very fast or your project is too big you could try using one
tags file for each directory in your project. The editor can be configured
to collect symbols from various tag files.

The command line options I recommend to use with `ctags' are:

   * -R recursive, to search in all subdirectories.

   * --fields=+i+l+m+z Inheritance information, language of source file
     that contains the tag, implementation information and type of tag.

Without the `+i' and `+z' option you won't be able to use the class
browser.


File: editor.inf,  Node: Can these files be created and updated by the editor?,  Next: What is the easiest way to use tags?,  Prev: How should I generate the tags?,  Up: TAGS files

13.4 Can these files be created and updated by the editor?
==========================================================

I recommend using makefiles to maintain tag files because you have all the
control over when and how they are updated. But if you are using a fast
machine and want to simplify the process you can let the editor create and
maintain a tags file for your project. You'll find options for it in the
Tool&Ops | Options | Tag files menu option. *Note Tag files options::.


File: editor.inf,  Node: What is the easiest way to use tags?,  Next: What can I do with tags?,  Prev: Can these files be created and updated by the editor?,  Up: TAGS files

13.5 What is the easiest way to use tags?
=========================================

Here is an explanation about how to quickly use tag files:

  1. Install `Exuberant Ctags' (http://ctags.sourceforge.net).

  2. Create a project (Project | Open). *Note Open (Project)::.

  3. Add all the files you want to include to the project. You can import
     the list of files from a text file. *Note Import project items::.

  4. Enable automatic tag generation using a central file (Tool&Ops |
     Options | Tag files | Options). *Note Tag files options::.

  5. Perform a search, the tags file will be generated during this process
     so be patient if your system is slow or your project is huge.


File: editor.inf,  Node: What can I do with tags?,  Next: Technical details about tags,  Prev: What is the easiest way to use tags?,  Up: TAGS files

13.6 What can I do with tags?
=============================

With the tag files you can:

  1. Jump to any defined symbol. *Note Jump to symbol::.

  2. Browse C++ class hierarchy. *Note Class browser::.

  3. Ask the editor to complete a partially typed symbol. *Note Word
     completion::.


File: editor.inf,  Node: Technical details about tags,  Prev: What can I do with tags?,  Up: TAGS files

13.7 Technical details about tags
=================================

The editor loads the tags to memory to allow fast searches. For this reason
you must be aware that they consume lots of memory. In some tests I did
using GNU/Linux I found the amount needed to load a tags file is close to
the size of the file on disk. For this reason I recommend to avoid
generating symbols for files you don't need.

The time to parse and load tag files can be annoying on slow systems. For
this reason the editor never loads the tag files until they are really
needed. That's why you'll notice a delay for the first search, because the
files are loaded at this time and not when the editor is started.

Tag files don't catch all definitions, they aren't perfect, so please read
the man pages. They also lack some important information, like what type a
variable (int, float, `etc.') is.


File: editor.inf,  Node: Debugging,  Next: Miscellaneous,  Prev: TAGS files,  Up: Top

14 Debugging
************

Important! 2004/08/17 version 0.5.4: Currently this chapter is incomplete
and the debugging features of the editor are considered unstable.

Only C and C++ programs can be debugged. If you use another language
supported by gdb and want to help supporting it please contact me.
Languages not supported by gdb needs more work to get supported, even if
the debugger used for them is similar to gdb.

* Menu:

* Supported platforms for debugging::
* Mechanism used to debug::
* Quick start to debugging::
* Supported debug targets::
* Available debug options::
* Debugging states::
* Running the program to debug::
* Stopping the program you are debugging::
* Examining data::
* Resuming the execution of the program::
* Finishing and restarting a debug session::
* Examining the calling stack::
* Cleaning the debug session::
* Selecting the thread to debug::
* Disassembler Window::
* Debugging already running processes::
* Debug Messages Window::
* Editing a debug expression::
* Debugging in the Linux console::


File: editor.inf,  Node: Supported platforms for debugging,  Next: Mechanism used to debug,  Prev: Debugging,  Up: Debugging

14.1 Supported platforms for debugging
======================================

Currently only Linux for IA32 (x86) CPUs is fully supported. Support for
other OSs where gdb (The GNU debuger) is available and that provides a
complete POSIX interface should be easy to obtain. If you want to help
adding support for your platform please contact the author.  *Note How to
contact me::.

Architectures other than IA32 are partially supported. If that's your case
you can help testing and providing information about it. The two most
important things you can help to fix are: the stack window and the syntax
highlight of the disassembler window. You just need to know a little bit
about the native assembler.

DOS and any other target where the fork/exec mechanism and pipes
communication isn't implemented aren't supported. To support them I need a
lot of help. In particular I need to make some code to handle the gdb/MI
protocol using libgdb.a. If you think you can help with it contact me.

The support for Linux is for X and for the real console. You can't debug
programs if you don't have access to the real console of the local machine.

Only programs that can be debugged by gdb can be debugged using the editor.


File: editor.inf,  Node: Mechanism used to debug,  Next: Quick start to debugging,  Prev: Supported platforms for debugging,  Up: Debugging

14.2 Mechanism used to debug
============================

The editor doesn't include a built-in debugger like RHIDE does. Instead you
have to install the GNU Debuger (gdb). Only versions of gdb that implements
the MI protocol are usable. The version 5 implements MI version 1 and the
version 6 implements MI version 2.

To debug the editor starts gdb and communicates with the debugger using a
POSIX mechanism called pipe. It means the editor can just send commands to
gdb like you could do manually. The consequence is that you all the power
of gdb, but also all the problems and bugs found in gdb. During the
development of the debug features I found more than two bugs in gdb each
week.

The editor uses a special mode of gdb called MI. MI stands for Machine
Interface. In this mode the gdb responses are specially designed to be
parsed by another program instead of read by a human bean. This makes the
communication much more robust but this mode is less tested than the usual
mode (CLI Command Line Interface).

The MI mode allows to send CLI commands to gdb. So you can send your own
commands to gdb. This should be used only if the editor doesn't provide any
way to achieve the same result. If you need to do it very often please
consider commenting it in the editor's mailing list. We could add the
proper user interface for what you need. *Note Debug Messages Window::.


File: editor.inf,  Node: Quick start to debugging,  Next: Supported debug targets,  Prev: Mechanism used to debug,  Up: Debugging

14.3 Quick start to debugging
=============================

The following is a very short explanation of how to start debugging your
program. It assumes you already know what's a debugger and you are
familiarized with the user interface. The user interface is quite similar
to the RHIDE's user interface and that's almost the same used by Borland
debuggers.

  1. Create a new project. All the debugging options will be stored in the
     project file. *Note Open (Project)::.

  2. Add your source files to the project. You can do it pressing the
     `Insert' key when the project window is selected or importing a list
     of files. *Note Import project items::.

  3. Compile your program with debug information. For `gcc' you should use
     the `-g' command line option and avoid using the `-s' option.  You'll
     get better integration if you compile your program using the internal
     features of the editor to run external programs. *Note Run program
     (which one)::.

  4. Select the `Debug|Step over' menu option. If you didn't set the debug
     options the editor will ask to do it. The most important option is the
     name of the program you want to debug.

  5. If the editor can't find the source file you'll be asked to indicate
     its location.

  6. If all goes as spected you'll see your source file and the first line
     of the main function highlighted. You are debugging your program. Now
     you'll want to consult the sections about breakpoints, stepping in
     your code and displaying data.


File: editor.inf,  Node: Supported debug targets,  Next: Available debug options,  Prev: Quick start to debugging,  Up: Debugging

14.4 Supported debug targets
============================

Currently you can especify the following targets:

   * Local executables. That's the most common case where you debug a
     program you compiled locally.

   * Remote debugging. In this case you debug a program that runs on
     another machine connected through a serial communication or network.

   * Already running processes. You can also debug a process that's
     currently running in your local machine.

Other gdb targets aren't supported.

In all the cases you should have a local copy of the program with debug
information. When you debug a remote program the remote copy doesn't have
to include debug information.

When you want to download the local copy of the binary to the target you
can select the remote option for embedded targets. This is useful for
embedded systems like AVR.


File: editor.inf,  Node: Available debug options,  Next: Debugging states,  Prev: Supported debug targets,  Up: Debugging

14.5 Available debug options
============================

You can configure the following debug options. Remmember that most of them
are stored in project files.

* Menu:

* Debug options::
* Path for sources::
* Messages displayed::
* Advanced debug options::


File: editor.inf,  Node: Debug options,  Next: Path for sources,  Prev: Available debug options,  Up: Available debug options

14.5.1 Debug options
--------------------

This dialog is obtained using the `Debug|Options|Program and mode...' menu
entry.

Here you setup the most relevant debug options. These options are stored in
project files. For this reason you should use a project if you want to
avoid setting these options again. The available options are:

   * Program to debug: Indicates the local copy of the program to debug.
     This copy must be compiled with debug information and the debug
     information must be preserved during the linking stage. Using the
     `Browse' button you can choose a file using a dialog to navigate your
     filesystem.

   * Mode: It selects the kind of target you will debug.  *Note Supported
     debug targets::.

   * Program arguments: The command line options for the program you want
     to debug. This option is used only for local targets.

   * Forced terminal: When the editor debugs your program the input and
     output of the program are redirected to a different terminal. This
     mechanism avoids interferences between the editor and the program you
     want to debug.  The terminal is selected or created automatically. If
     you need to force a particular terminal fill this option. Otherwise
     leave it blank.

   * Remote protocol type: This option is used for remote targets. Here you
     must specify one of the protocols supported by gdb. The most common
     protocol is `extended-remote'.

   * Remote location: Also used for remote debugging. Here you indicate the
     location of the remote machine or the serial device. For TCP/IP you
     must specify the host and the port number using `host:port'. For
     serial links you must specify the serial device. Consult gdb
     documentation for details.

Name of the command: cmeDebugOptions.


File: editor.inf,  Node: Path for sources,  Next: Messages displayed,  Prev: Debug options,  Up: Available debug options

14.5.2 Path for sources
-----------------------

This dialog is obtained using the `Debug|Options|Path for sources...' menu
entry.

The most common way to compile your program is by indicating the relative
path for the source file. When you debug your program you can do it from
any directory. For this reason gdb can have problems to find the source
files.  The editor will analyze your project and extract paths from it.
Additionally the editor will use the path for the executable as reference.
The resulting list is passed to gdb. But sometimes it isn't enough and you
must indicate the location for the files manually.

The easiest way to add a directory is using the `Browse' button. It will
bring a tree view of your filesystem. This dialog supports incremental
search.

When gdb reports a source file the editor uses this list to find the exact
location of the file. If the file couldn't be found the editor will ask you
to select the file using a dialog like the one used to open files. For this
reason you usually don't need to add the directories manually. The
exception is when you need to set a breakpoint and you get an error from
gdb indicating the file couldn't be found. In this case the best
recommendation is to add the file to the project, but you can add the
directory here.

Name of the command: cmeSourceList.


File: editor.inf,  Node: Messages displayed,  Next: Advanced debug options,  Prev: Path for sources,  Up: Available debug options

14.5.3 Messages displayed
-------------------------

This dialog is obtained using the `Debug|Options|Messages displayed...'
menu entry.

This dialog controls which messages will be displayed in the Debugger
Window.  *Note Debug Messages Window::. You can filter the following kind
of messages:

   * GDB console (CLI): Messages sent to the console. Usually they are
     human readable messages generated by gdb in response to console
     commands.

   * Target: The output of the target. This kind of messages are specified
     by gdb documentation but never generated. They are supposed to
     contain the tunneled output of your program.

   * Log: Messages sent to the gdb log. Usually they contain technical
     information about gdb details.

   * GDB/MI commands sent to gdb: Machine Interface commands sent by the
     editor to gdb.

   * GDB/MI responses from gdb: Machine Interface responses from gdb.

Usually you'll be interested only in the console and log messages. The
target messages aren't really implemented in gdb and the MI messages are
only useful to control if the editor is sending the proper information and
gdb replying to it.

Name of the command: cmeDbgOptsMsgs.


File: editor.inf,  Node: Advanced debug options,  Prev: Messages displayed,  Up: Available debug options

14.5.4 Advanced debug options
-----------------------------

This dialog is obtained using the `Debug|Options|Advanced...' menu entry.

The options contained in this dialog are used to fine tune the debug
session.  Some of these options are dangerous and can produce problems if
you don't set them properly.

   * GDB executable: The binary executed as debugger. Use the browse button
     to select it. If you leave it blank the editor will choose the first
     binary called gdb found in your path.

   * X terminal executable: The binary used to create a terminal for the
     program to debug when the editor is connected to an X server.

   * Main function: The name of the first function executed in your
     program.  For C and C++ programs that's usually `main'. Sometimes the
     name is different. One example is the Allegro library where `main' is
     replaced by `__mangled_main'.

   * GDB Time out [s]: The ammount of seconds to wait for a gdb response.
     After this time the editor will ask if you want to wait more time or
     assume the response will never arrive. You can't indicate less than
     two seconds.

   * Max. lines in Debug window: Maximum lines to hold in the Debugger
     Window. When this value is reached the older lines are discarded. You
     can't indicate less than 100 lines.

   * No gdb banner after connecting: Suppress the gdb banner printed in the
     Debugger Window when we start gdb. *Note Debug Messages Window::.

   * Enable MI v2 features: Enable a few features only available in gdb MI
     version 2. Currently the editor can't determine the exact version
     implemented in gdb so you must indicate it. Versions newer than 6.0
     seems to implement MI version 2. But cvs snapshots of gdb doesn't
     report a useful version.

   * No symbols bug workaround: Actually the editor implements a workaround
     for a bug in gdb when searching for file names in the table of debug
     symbols.  This workaround produces a slower start-up. This bug seems
     to affect versions from 5.3 to 6.2 (inclusive).

   * No source code in disasm. window: Disables the use of mixed source
     code and assembler in the disassembler window. This is faster.

All the above options are stored globally and affects all projects. The
only exception is the name of the main function which is stored in the
project file.

Name of the command: cmeDbgOptionsAdv.


File: editor.inf,  Node: Debugging states,  Next: Running the program to debug,  Prev: Available debug options,  Up: Debugging

14.6 Debugging states
=====================

Not all operations can be performed at any time. GDB must be running in
order to run the program and the program running in order to stop it. For
this reason the editor keeps track of gdb state. The current state is
displayed in the Debugger Window. *Note Debug Messages Window::.The
following states are defined:

   * Disconnected: gdb isn't running.

   * Connected: gdb is running but no target was selected.

   * Ready to Run: gdb is running and we selected a target.

   * Running: owr program is running. Note that currently gdb doesn't
     implement full asynchronous operation. It means that you can't send
     commands to gdb while the state is `running'. GDB won't be able to
     reply commands in this state.

   * Stopped: the program was stopped and can resume its execution.

Some menu options can be used to force a particular state. So you can
directly jump to `connected' or `ready to run' states from the
`disconnected' state. This is useful if you want to send commands to gdb
that only works in these states. *Note Debug Messages Window::.

When you specify an action that is invalid for the current state the editor
will try to reach the proper state. As an example, if you use the `Step
over' option when you are in `disconnected' state the editor will first
try to start gdb and go to `connected', then will try to specify the
target and go to `ready to run' and finally will emulate the step action
by using a temporal breakpoint on the main function.

The menu entry called `Debug|Debug session|Close' is used to go to the
`disconnected' state from any of the other states.

The menu entry called `Debug|Stop' is used to go to the `stopped' state
from the `running' state. And the `Debug|Kill' option is used to go to the
`ready to run' state from the `stopped' or `running' states.

* Menu:

* Going to the connected debug state::
* Going to the ready to run debug state::


File: editor.inf,  Node: Going to the connected debug state,  Next: Going to the ready to run debug state,  Prev: Debugging states,  Up: Debugging states

14.6.1 Going to the connected debug state
-----------------------------------------

This operation is obtained using the `Debug|Go to state|Connected' menu
entry.

With this function the editor will try to reach the `Connected' debugging
state. *Note Debugging states::.

It can be used when the debugger isn't running and you want to start it
without specifying the target to debug. In this way you can send commands
to gdb that are useful only before you specify the target.

Name of the command: cmeDbgGoConnected.


File: editor.inf,  Node: Going to the ready to run debug state,  Prev: Going to the connected debug state,  Up: Debugging states

14.6.2 Going to the ready to run debug state
--------------------------------------------

This operation is obtained using the `Debug|Go to state|Ready to run' menu
entry.

With this function the editor will try to reach the `Ready to run'
debugging state. *Note Debugging states::.

This operation will try to reach the `Connected' state first.  *Note Going
to the connected debug state::. If this is achieved then the editor will
indicate to gdb which target do you want to debug. For local debugging the
program won't be started so you can send to gdb commands that apply only
before starting the program to debug.

Name of the command: cmeDbgGoReadyToRun.


File: editor.inf,  Node: Running the program to debug,  Next: Stopping the program you are debugging,  Prev: Debugging states,  Up: Debugging

14.7 Running the program to debug
=================================

This operation is obtained using the `Debug|Run/Continue/Atach' menu entry.

You must first configure the name of the program you want to debug. If you
don't do it the editor will ask if you want to do it. *Note Debug
options::.

Once your program is running you can stop it using the `Debug|Stop'
option. But usually is better to use breakpoints and watchpoints instead.

While the program is running you can't consult the value of variables.
That's because gdb gets blocked until your program is stopped.  *Note
Debugging states::.

This command have other uses. If your program is already stopped it resumes
its execution. *Note Continue execution::. If you are debugging a program
that is already running this command will atach to the running process and
stop the execution.

Name of the command: cmeDbgRunContinue.
Assigned key: `Shift+F9'


File: editor.inf,  Node: Stopping the program you are debugging,  Next: Examining data,  Prev: Running the program to debug,  Up: Debugging

14.8 Stopping the program you are debugging
===========================================

Once your program is running you can stop it using the `Debug|Stop'
option. But usually is better to use breakpoints and watchpoints instead.

Using breakpoints you can stop the execution at a desired point of your
program. Using watchpoints you can stop the execution when some data value
changes or is accessed. Note that gdb watchpoints aren't fully reliable.

Name of the command: cmeDbgStop.

* Menu:

* Breakpoints::
* Advanced breakpoint options::
* Watchpoints::


File: editor.inf,  Node: Breakpoints,  Next: Advanced breakpoint options,  Prev: Stopping the program you are debugging,  Up: Stopping the program you are debugging

14.8.1 Breakpoints
------------------

Breakpoints are stop points in your program. The easiest way to create a
breakpoint is by using the `Debug|Breakpoint' menu option. This will
create a breakpoint at the current file and line. To remove it just use the
same menu option. Breakpoint lines are highlighted. The default color is
red.  *Note Customize Colors::.

Note that gdb accepts breakpoints even for source lines that didn't
generate code. In this case gdb will stop the execution when the nearest
source line is reached.

When you edit your program breakpoints are automatically moved. If you use
the editor options to call an external program in order to recompile your
program the editor will inform gdb the new place for the breakpoints.

To create more complex breakpoints you have to use the `Debug|Edit
breakpoints...' menu option. *Note Advanced breakpoint options::.

Name of the command: cmeBreakpoint.
Assigned key: `Ctrl+F8'


File: editor.inf,  Node: Advanced breakpoint options,  Next: Watchpoints,  Prev: Breakpoints,  Up: Stopping the program you are debugging

14.8.2 Advanced breakpoint options
----------------------------------

This dialog is obtained using the `Debug|Edit breakpoints...' menu entry.
Using this dialog you can:

   * Modify existing breakpoints. Modify button.

   * Add new breakpoints. New button.

   * Remove breakpoints. Delete button.

   * Enable or disable a breakpoint. Enable and Disable buttons. Note that
     currently this is not the same concept implemented in gdb. I.e. we
     remove the breakpoint from gdb but not from the editor list.

   * Jump to the source file where the breakpoint is located. Show button.

The list of breakpoints contains the following information:

   * E: an asterisk if enabled.

   * Where: breakpoint location.

   * Condition: the additional condition for conditional breakpoints.

   * Count: the number of times this breakpoint will be ignored when
     enabled.

   * Thre.: the thread affected by this breakpoint. All threads are
     affected by default.

When you add or modify a breakpoint a dialog offering the following options
is used:

   * Type: This is the kind of specification for the breakpoint location.
     GDB supports four ways to specify a breakpoint combining the source
     file name, the line, function and code address.

   * Condition: If this field contains a condition the breakpoint will stop
     the program execution when the location is reached and the condition
     is satisfied.

   * Count: When this value is specified the breakpoint will be ignored
     this ammount of times. Note that gdb keeps a counter that is reset
     every time you set the breakpoint. When the program is started the
     editor will force a refresh on this value. That isn't the normal gdb
     behavior. It means that a count of five will make the breakpoint to
     be ignored the first five times it was reached after starting your
     program.

   * Thread: You can specify a thread id here.

   * Enabled: Indicates if the breakpoint is enabled.

   * Hardware assisted: When you are debugging code that is located in a
     read only memory space you have to use hardware assisted breakpoints.
     Read the gdb documentation for more information.

When a breakpoint fails to apply the editor will disable it to avoid
farther gdb errors.

Name of the command: cmeDbgEditBreakPts.


File: editor.inf,  Node: Watchpoints,  Prev: Advanced breakpoint options,  Up: Stopping the program you are debugging

14.8.3 Watchpoints
------------------

This dialog is obtained using the `Debug|Edit watchpoints...' menu entry.

Unlike breakpoints the watchpoints are data related. Some people calls them
`data breakpoints'. Watchpoints can stop the execution when a data value
is:

   * Written

   * Read

   * Accessed (Written or Read)

Note that in order to get usable results this needs hardware assistance. It
means that not all platforms supports it. Additionally the number of
watchpoints is limited and gdb imposes more restrictions to what can be
used as a watchpoint. In some cases gdb tries to emulate it using software
and the result can be really bad. During development I found a case where
gdb did it and as a result it eated all the CPU time and was really hard
to stop.

Using this dialog you can:

   * Modify existing watchpoints. Modify button.

   * Add new watchpoints. New button.

   * Remove watchpoints. Delete button.

   * Enable or disable a watchpoint. Enable and Disable buttons.

The list of watchpoints contains the following information:

   * E: an asterisk if enabled.

   * R/W: type of watchpoint (Read, Write or Read+Write)

   * Expression: The expression to monitor.

When you add or modify a watchpoint a dialog offering the following options
is used:

   * Expression: the expression that will be monitored.

   * Type: the action that will stop the execution.

   * Enabled: indicates if the watchpoint is enabled.

Name of the command: cmeDbgEditWatchPts.


File: editor.inf,  Node: Examining data,  Next: Resuming the execution of the program,  Prev: Stopping the program you are debugging,  Up: Debugging

14.9 Examining data
===================

There are many tools to examine data values of the program you are
debugging.  You can:

   * Evaluate an expression to know the resulting value.  *Note Evaluate
     or Modify expression::.

   * Monitor a simple value as the program flows. *Note Watch an
     expression::.

   * Monitor an expression with scope. *Note Watch an expression with
     scope::.

   * Monitor a complex data structure. *Note Inspectors::.

   * Examine the memory space. *Note Data Window::.

   * Examine the stack. *Note Stack window::.

* Menu:

* Evaluate or Modify expression::
* Watch an expression::
* Watch an expression with scope::
* Inspectors::
* Data Window::
* Stack window::


File: editor.inf,  Node: Evaluate or Modify expression,  Next: Watch an expression,  Prev: Examining data,  Up: Examining data

14.9.1 Evaluate or Modify expression
------------------------------------

This dialog is obtained using the `Debug|Evaluate/Modify...' menu entry.

The first input line is used to enter the expression you want to evaluate.
The result is obtained using the `Evaluate' button. That's the default
button so you can just press `Enter'. The resulting value is displayed in
the `Result' input line.

To assign a different value to the expression you must use the `New value'
input line and press the `Change' button. Note that the value used in
`Expression' must be expressed in a way that can be used for an assignment
(`Expression' = `New Value').

The `Copy' button will copy the `Result' value to the editor's clipboard.
The `Paste' value will paste from the editor's clipboard to the
`Expression' input line.

Using the `Inspect' button you can create an Inspector Window based on the
`Expression'. *Note Inspectors::.

This dialog is modal and is used to evaluate a value just once. To see how
a value changes as yourt program flows use watches or inspectors.

Name of the command: cmeDbgEvalModify.
Assigned key: `Ctrl+F4'


File: editor.inf,  Node: Watch an expression,  Next: Watch an expression with scope,  Prev: Evaluate or Modify expression,  Up: Examining data

14.9.2 Watch an expression
--------------------------

This functionality is obtained using the `Debug|Watch an expression|Normal
watch' menu entry.

Using this option you can add an expression to the Watches Window. This
expression will be evaluated every time the program stops and the result
will be updated in the Watches Window.

Adding too much watches could slow down the debug process. Also note that
the expression will be evaluated in the current scope. If you need to
monitor an expression in a fixed scope use a watch with scope.  *Note
Watch an expression with scope::. For complex data structures you'll get
better results using Inspectors. *Note Inspectors::.

Name of the command: cmeDbgWatchExpNorm.
Assigned key: `Ctrl+F7'


File: editor.inf,  Node: Watch an expression with scope,  Next: Inspectors,  Prev: Watch an expression,  Up: Examining data

14.9.3 Watch an expression with scope
-------------------------------------

This functionality is obtained using the `Debug|Watch an expression|With
scope' menu entry.

Using this option you can add an expression to the Watches Window. This
expression will be evaluated every time the program stops and the result
will be updated in the Watches Window.

Adding too much watches could slow down the debug process. These watches
are implemented using a gdb mechanism that is faster when only a few
expressions changes in each execution.

Unlike normal watches the scope of the expression is fixed. It means you'll
be monitoring the same value all the time and not different variables. Also
note that when their scope is finished they are deleted from the list.

For complex data structures you'll get better results using Inspectors.
*Note Inspectors::.

Name of the command: cmeDbgWatchExpScp.


File: editor.inf,  Node: Inspectors,  Next: Data Window,  Prev: Watch an expression with scope,  Up: Examining data

14.9.4 Inspectors
-----------------

This functionality is obtained using the `Debug|Watch an expression|Using
the Inspector' menu entry.

Inspectors are used to monitor complex data structures as the program flows
or just navigate them to verify them. I.e. you can navigate a linked list
using an inspector.

Unlike watches each expression you evaluate have its own window. You can
have as many inspector windows as you like. The windows are resizable and
have scroll bars.

The representation of the data inside an inspector is a tree. You can
expand or collapse the branches using the `E' and `C' keys. On most systems
you can also use the `+' and `-' keys. If a line begins with a `+' it
means that you can expand the tree from this point. If it starts with a
`-' you can collapse it. After the name of the data member you'll find its
data type enclosed in brackets. At the end of the line the value of the
data member is displayed.

Some lines will look a like this: `varXX.public'. That's just the way gdb
indicates the accesibility of the members. The `varXX' part is the name of
the internal gdb value. You don't have to worry about this name.

When you select a line containing some data type that looks like a pointer
the `Inspect' option of the status bar will be enabled. Using it you'll
get a new inspector for the data pointed by the selected pointer. The
`Enter' key can be used for this.

When the line contains a data value that can be modified the `Modify'
option of the status bar will be enabled. The `Ctrl'+`M' key can be used
to modify the selected value.

You can also use the `Format' option (key `Ctrl'+`F') to change the format
used to represent the selected member.

Inspectors are evaluated in the scope they were created. When its scope is
finished they stop working. If you enter to the same scope, or another
where the expression is valid, you can use the `Recycle' option. The
keyboard shortcut for it is `Ctrl'+`R'.

Name of the command: cmeDbgInspector.
Assigned key: `Ctrl+F6'


File: editor.inf,  Node: Data Window,  Next: Stack window,  Prev: Inspectors,  Up: Examining data

14.9.5 Data Window
------------------

This functionality is obtained using the `Debug|Watch an expression|Data
window' menu entry.

The Data Window can be used to examine and/or modify the memory. Its
functionality can be compared with an hexadecimal editor. The number of
operations and options related to the Data Window are really big. For this
reason the Data Window have its own menu. When you select a Data Window the
menu will change to show the Data Window commands.

The original code for the Data Window was contributed by Molnar Laszlo. He
designed it for RHIDE, but RHIDE doesn't document all the available
functionality of the Data Window.

When you modify the memory in the Data Window the changes aren't reflected
to the real memory space. In order to reflect the changes you must use the
`Enter' key or the `Various|Update memory' menu option. Every time the
program stops the content of the Data Window is updated and the changes
highlighted. You can force the editor to recompute the original expression
used to get the memory address used in the Data Window in each update. To
achieve it use the `Mode|Toggle auto follow' menu option.

The following is a description of the special menu used for the Data
Window.  Only the commands related to the Data Window are explained.

Name of the command: cmeDbgDataWindow.

* Menu:

* File - Read block (DW)::
* File - Write block (DW)::
* Move - Up (DW)::
* Move - Down (DW)::
* Move - Right (DW)::
* Move - Left (DW)::
* Move - Page down (DW)::
* Move - Page up (DW)::
* Move - First column (DW)::
* Move - Last column (DW)::
* Move - First row (DW)::
* Move - Last row (DW)::
* Move - First addr increment (DW)::
* Move - First addr decrement (DW)::
* Address - Change base address (DW)::
* Address - Go to new address (DW)::
* Address - Follow pointer (DW)::
* Address - Follow pointer in new window (DW)::
* Address - Recompute address (DW)::
* Mode - Toggle auto follow (DW)::
* Mode - Change display mode (DW)::
* Mode - Toggle endian mode (DW)::
* Mode - Change radix (DW)::
* Block - Fill (DW)::
* Block - Clear (DW)::
* Block - Move (DW)::
* Various - Less bytes per line (DW)::
* Various - More bytes per line (DW)::
* Various - Update memory (DW)::
* Data Window Limitations and Details::


File: editor.inf,  Node: File - Read block (DW),  Next: File - Write block (DW),  Prev: Data Window,  Up: Data Window

14.9.5.1 File - Read block (DW)
...............................

Used to read data from a file and store it in the memory space of the
program you are debugging. You have to choose a file and then indicate the
destination address and the maximum ammounts of bytes to read from the
file.

Some general limits and functionality common to the Data Window operations
applies. *Note Data Window Limitations and Details::.

Name of the command: cmDWRead.
Assigned key: `Ctrl+R'


File: editor.inf,  Node: File - Write block (DW),  Next: Move - Up (DW),  Prev: File - Read block (DW),  Up: Data Window

14.9.5.2 File - Write block (DW)
................................

Used to write data from the memory space of the program you are debugging
to a file. You have to indicate the source address and the how much data to
write and then choose a file name.

Some general limits and functionality common to the Data Window operations
applies. *Note Data Window Limitations and Details::.

Name of the command: cmDWWrite.
Assigned key: `Ctrl+W'


File: editor.inf,  Node: Move - Up (DW),  Next: Move - Down (DW),  Prev: File - Write block (DW),  Up: Data Window

14.9.5.3 Move - Up (DW)
.......................

Moves the cursor position one row up. If the cursor is at the top row the
starting address will be decremented by the bytes contained in a row and
the whole block will be fetched.

Changes not tranferred to the target will be lost if a new block of data is
fetched.

Name of the command: cmDWUp.
Assigned key: `Cursor up'


File: editor.inf,  Node: Move - Down (DW),  Next: Move - Right (DW),  Prev: Move - Up (DW),  Up: Data Window

14.9.5.4 Move - Down (DW)
.........................

Moves the cursor position one row down. If the cursor is at the bottom row
the starting address will be incremented by the bytes contained in a row
and the whole block will be fetched.

Changes not tranferred to the target will be lost if a new block of data is
fetched.

Name of the command: cmDWDown.
Assigned key: `Cursor down'


File: editor.inf,  Node: Move - Right (DW),  Next: Move - Left (DW),  Prev: Move - Down (DW),  Up: Data Window

14.9.5.5 Move - Right (DW)
..........................

Moves the cursor to the right. If the cursor is in the rightmost column it
will remain there.

Name of the command: cmDWRight.
Assigned key: `->'


File: editor.inf,  Node: Move - Left (DW),  Next: Move - Page down (DW),  Prev: Move - Right (DW),  Up: Data Window

14.9.5.6 Move - Left (DW)
.........................

Moves the cursor to the left. If the cursor is in the leftmost column it
will remain there.

Name of the command: cmDWLeft.
Assigned key: `<-'


File: editor.inf,  Node: Move - Page down (DW),  Next: Move - Page up (DW),  Prev: Move - Left (DW),  Up: Data Window

14.9.5.7 Move - Page down (DW)
..............................

Increments the starting memory address by the number of bytes contained in
a row multiplied by the number of rows.

Changes not tranferred to the target will be lost.

Name of the command: cmDWPgDn.
Assigned key: `Page Down'


File: editor.inf,  Node: Move - Page up (DW),  Next: Move - First column (DW),  Prev: Move - Page down (DW),  Up: Data Window

14.9.5.8 Move - Page up (DW)
............................

Decrements the starting memory address by the number of bytes contained in
a row multiplied by the number of rows.

Changes not tranferred to the target will be lost.

Name of the command: cmDWPgUp.
Assigned key: `Page Up'


File: editor.inf,  Node: Move - First column (DW),  Next: Move - Last column (DW),  Prev: Move - Page up (DW),  Up: Data Window

14.9.5.9 Move - First column (DW)
.................................

Moves the cursor to the leftmost column.

Name of the command: cmDWFirstColumn.
Assigned key: `Home'


File: editor.inf,  Node: Move - Last column (DW),  Next: Move - First row (DW),  Prev: Move - First column (DW),  Up: Data Window

14.9.5.10 Move - Last column (DW)
.................................

Moves the cursor to the rightmost column.

Name of the command: cmDWLastColumn.
Assigned key: `End'


File: editor.inf,  Node: Move - First row (DW),  Next: Move - Last row (DW),  Prev: Move - Last column (DW),  Up: Data Window

14.9.5.11 Move - First row (DW)
...............................

Moves the cursor to the first row in the same column.

Name of the command: cmDWFirstRow.
Assigned key: `Ctrl+Home'


File: editor.inf,  Node: Move - Last row (DW),  Next: Move - First addr increment (DW),  Prev: Move - First row (DW),  Up: Data Window

14.9.5.12 Move - Last row (DW)
..............................

Moves the cursor to the last row in the same column.

Name of the command: cmDWLastRow.
Assigned key: `Ctrl+End'


File: editor.inf,  Node: Move - First addr increment (DW),  Next: Move - First addr decrement (DW),  Prev: Move - Last row (DW),  Up: Data Window

14.9.5.13 Move - First addr increment (DW)
..........................................

Increments the starting memory address by one.

Changes not tranferred to the target will be lost.

Name of the command: cmDWBaseIncrement.
Assigned key: `Ctrl+->'


File: editor.inf,  Node: Move - First addr decrement (DW),  Next: Address - Change base address (DW),  Prev: Move - First addr increment (DW),  Up: Data Window

14.9.5.14 Move - First addr decrement (DW)
..........................................

Decrements the starting memory address by one.

Changes not tranferred to the target will be lost.

Name of the command: cmDWBaseDecrement.
Assigned key: `Ctrl+<-'


File: editor.inf,  Node: Address - Change base address (DW),  Next: Address - Go to new address (DW),  Prev: Move - First addr decrement (DW),  Up: Data Window

14.9.5.15 Address - Change base address (DW)
............................................

When you open a new Data Window the addresses displayed are the same used
by the program you are debugging. If you need to convert them into
relative you can change the base address. When you specify a new base
address it is used as reference.

Name of the command: cmDWBaseAddress.
Assigned key: `Ctrl+B'


File: editor.inf,  Node: Address - Go to new address (DW),  Next: Address - Follow pointer (DW),  Prev: Address - Change base address (DW),  Up: Data Window

14.9.5.16 Address - Go to new address (DW)
..........................................

Used to change the expression used to determine the starting address of the
Data Window. The address corresponding to this expression is always
highlighted used a different color.

Name of the command: cmDWGotoAddress.
Assigned key: `Ctrl+G'


File: editor.inf,  Node: Address - Follow pointer (DW),  Next: Address - Follow pointer in new window (DW),  Prev: Address - Go to new address (DW),  Up: Data Window

14.9.5.17 Address - Follow pointer (DW)
.......................................

Interprets the memory at the cursor position as a pointer to another block
of memory. This pointer is used as the new expression for the Data Window.

Name of the command: cmDWFollowPointer.
Assigned key: `Ctrl+F'


File: editor.inf,  Node: Address - Follow pointer in new window (DW),  Next: Address - Recompute address (DW),  Prev: Address - Follow pointer (DW),  Up: Data Window

14.9.5.18 Address - Follow pointer in new window (DW)
.....................................................

Interprets the memory at the cursor position as a pointer to another block
of memory. This pointer is used as the expression for a new Data Window.
The extra asterisk is to cancel an `&' added by the editor.

Name of the command: cmDWFollowPtnNew.
Assigned key: `Ctrl+O'


File: editor.inf,  Node: Address - Recompute address (DW),  Next: Mode - Toggle auto follow (DW),  Prev: Address - Follow pointer in new window (DW),  Up: Data Window

14.9.5.19 Address - Recompute address (DW)
..........................................

Evaluates the original expression to determine the new starting address.
You can do it automatically every time the program stops using the auto
follow mode. *Note Mode - Toggle auto follow (DW)::.

Name of the command: cmDWRecompute.
Assigned key: `Ctrl+H'


File: editor.inf,  Node: Mode - Toggle auto follow (DW),  Next: Mode - Change display mode (DW),  Prev: Address - Recompute address (DW),  Up: Data Window

14.9.5.20 Mode - Toggle auto follow (DW)
........................................

Toggles the auto follow mode. When the auto follow mode is enabled the
expression supplied to determine the memory displayed by the Data Window is
automatically recomputed every time the program stops.

The auto follow mode is indicated with an `A' in the indicator widget
located at the bottom right of the Data Window.

Name of the command: cmDWTogAutoF.
Assigned key: `Ctrl+A'


File: editor.inf,  Node: Mode - Change display mode (DW),  Next: Mode - Toggle endian mode (DW),  Prev: Mode - Toggle auto follow (DW),  Up: Data Window

14.9.5.21 Mode - Change display mode (DW)
.........................................

Changes the display mode to the next in the list of available modes. The
available modes are:

   * Bytes: each cell represents one byte in memory. The right side of the
     window contains its ASCII representations. Note that ASCII
     representation is suppressed when you select decimal radix.

   * Word: each cell represents two bytes.

   * Double Word: each cell represents four bytes.

   * ASCII: Only the ASCII representation is displayed. In this mode you
     can simply type characters to change the memory.

Name of the command: cmDWDispMode.
Assigned key: `Ctrl+D'


File: editor.inf,  Node: Mode - Toggle endian mode (DW),  Next: Mode - Change radix (DW),  Prev: Mode - Change display mode (DW),  Up: Data Window

14.9.5.22 Mode - Toggle endian mode (DW)
........................................

Toggles the endian mode. When a new Data Window is created the data is
displayed using the endian type of the program you are debugging. You can
change the endian mode at any time.

Little endian mode is indicated in the indicator widget located at the
bottom right of the Data Window using an `e' and big endian using `E'.

Name of the command: cmDWTogEndian.
Assigned key: `Ctrl+E'


File: editor.inf,  Node: Mode - Change radix (DW),  Next: Block - Fill (DW),  Prev: Mode - Toggle endian mode (DW),  Up: Data Window

14.9.5.23 Mode - Change radix (DW)
..................................

Changes the radix of the represented numbers. The available radices are
hexadecimal and decimal.

Hexadecimal radix is indicated in the indicator widget located at the
bottom right of the Data Window using an `X' and decimal using `D'.

Name of the command: cmDWRadix.
Assigned key: `Ctrl+X'


File: editor.inf,  Node: Block - Fill (DW),  Next: Block - Clear (DW),  Prev: Mode - Change radix (DW),  Up: Data Window

14.9.5.24 Block - Fill (DW)
...........................

Fills a memory block with an indicated data value. You have to indicate the
destination address, how many bytes will be filled and the value used to
fill the block.

Some general limits and functionality common to the Data Window operations
applies. *Note Data Window Limitations and Details::.

Name of the command: cmDWFill.
Assigned key: `Ctrl+I'


File: editor.inf,  Node: Block - Clear (DW),  Next: Block - Move (DW),  Prev: Block - Fill (DW),  Up: Data Window

14.9.5.25 Block - Clear (DW)
............................

Fills a memory block with zeroes. You have to indicate the destination
address and how many bytes will be filled.

Some general limits and functionality common to the Data Window operations
applies. *Note Data Window Limitations and Details::.

Name of the command: cmDWClear.
Assigned key: `Ctrl+L'


File: editor.inf,  Node: Block - Move (DW),  Next: Various - Less bytes per line (DW),  Prev: Block - Clear (DW),  Up: Data Window

14.9.5.26 Block - Move (DW)
...........................

Copies a block of memory to another memory location. You have to indicate
the source address, the destination address and how many data will be
copied.

Some general limits and functionality common to the Data Window operations
applies. *Note Data Window Limitations and Details::.

Name of the command: cmDWMove.
Assigned key: `Ctrl+M'


File: editor.inf,  Node: Various - Less bytes per line (DW),  Next: Various - More bytes per line (DW),  Prev: Block - Move (DW),  Up: Data Window

14.9.5.27 Various - Less bytes per line (DW)
............................................

Decrements the ammount of data cells displayed in each row.

Changes not tranferred to the target will be lost.

Name of the command: cmDWLessLines.
Assigned key: `-'


File: editor.inf,  Node: Various - More bytes per line (DW),  Next: Various - Update memory (DW),  Prev: Various - Less bytes per line (DW),  Up: Data Window

14.9.5.28 Various - More bytes per line (DW)
............................................

Increments the ammount of data cells displayed in each row.

Changes not tranferred to the target will be lost.

Name of the command: cmDWMoreLines.
Assigned key: `+'


File: editor.inf,  Node: Various - Update memory (DW),  Next: Data Window Limitations and Details,  Prev: Various - More bytes per line (DW),  Up: Data Window

14.9.5.29 Various - Update memory (DW)
......................................

Transfers changes to the memory space of the program you are debugging.

Name of the command: cmDWUpdateMemory.
Assigned key: `Enter'


File: editor.inf,  Node: Data Window Limitations and Details,  Prev: Various - Update memory (DW),  Up: Data Window

14.9.5.30 Data Window Limitations and Details
.............................................

Most Data Window operations uses a common dialog that adapts its fields to
the operation you want to perform. For this reason the operations shares
the same functionality and limitations.

All the fields (New Value, From, To, Expression, Length and Value) accepts
any kind of expression supported by gdb. You can include arithmetic
operations, variables, `etc.'

The Length and Value fields are evaluated as an unsigned value. The other
values are evaluated as addresses. In the last case the editor tries to
determine if you typed an address (something starting with a digit), an
explicit reference (`&' C/C++ operator) or a CPU register (they start with
`$' in gdb). If the editor thinks you didn't specify an address the `&'
operator will be automatically added. If you have a local variable called
`var' and you specify it then the editor will use `&var'.

In most cases the transferring big memory blocks between the target program
and the editor is an slow process. For this reason the editor will show a
warning if the size of the block is bigger than 128 KB and will refuse to
operate with more than 1 MB. This is also a security meassurement. If you
think this is a wrong idea please tell me.


File: editor.inf,  Node: Stack window,  Prev: Data Window,  Up: Examining data

14.9.6 Stack window
-------------------

The stack window is a specialized version of the Data Window. It starts
using the `esp' register as starting address, one cell in each line, four
bytes cells and auto follow mode enabled. *Note Data Window::.

Currently this is implemented only for the IA32 architecture. If you know
the name of the stack pointer register for your architecture please
contact me so I can add support for it. Also note that this window uses
the `esp' register and not the stack frame register (`ebp'). I don't know
if users will be interested on having a similar window for the stack frame.

Name of the command: cmeDbgStackWindow.


File: editor.inf,  Node: Resuming the execution of the program,  Next: Finishing and restarting a debug session,  Prev: Examining data,  Up: Debugging

14.10 Resuming the execution of the program
===========================================

Once you stopped the execution of your program and you examined its data
you'll most probably want to resume its execution. This section describes
various operations to do it controlling how much code will be executed.

You can resume execution until a breakpoint, watchpoint or the end of
program is reached. *Note Continue execution::.

You can execute until the next line of code is reached. You can achieve it
using two different commands. The first won't stop inside a function called
during by the execution (*note Step over::) and the second will do it
(*note Trace into::).

You can also execute until a line of code is reached.  *Note Executing
until cursor position is reached::.

Another option is to run the code until the current function is finished.
*Note Executing until return::. It's also possible to return immediatly
without executing the rest of the function. *Note Returning immediatly::.

* Menu:

* Continue execution::
* Step over::
* Trace into::
* Executing until cursor position is reached::
* Executing until return::
* Returning immediatly::


File: editor.inf,  Node: Continue execution,  Next: Step over,  Prev: Resuming the execution of the program,  Up: Resuming the execution of the program

14.10.1 Continue execution
--------------------------

When the program is stopped the menu entry named
`Debug|Run/Continue/Atach' can be used to resume the execution.

If the program isn't started this command is used to start the execution
(Run) or atach to an already running process (Atach).

Name of the command: cmeDbgRunContinue.
Assigned key: `Shift+F9'


File: editor.inf,  Node: Step over,  Next: Trace into,  Prev: Continue execution,  Up: Resuming the execution of the program

14.10.2 Step over
-----------------

This functionality is obtained using the `Debug|Step over' menu entry.

This command resumes the execution of a stopped program until the next line
of code is reached. Function calls that appear within the line of code are
executed without stopping.

When applied to the Assembler Window it works at instruction level.

Name of the command: cmeDbgStepOver.
Assigned key: `F8'


File: editor.inf,  Node: Trace into,  Next: Executing until cursor position is reached,  Prev: Step over,  Up: Resuming the execution of the program

14.10.3 Trace into
------------------

This functionality is obtained using the `Debug|Trace into' menu entry.

Continue running your program until control reaches a different source
line, then stops it. If a function call is found this command will enter
the function unless it doesn't have debug information.

When applied to the Assembler Window it works at instruction level and no
debug information is needed to enter functio calls.

Name of the command: cmeDbgTraceInto.
Assigned key: `F7'


File: editor.inf,  Node: Executing until cursor position is reached,  Next: Executing until return,  Prev: Trace into,  Up: Resuming the execution of the program

14.10.4 Executing until cursor position is reached
--------------------------------------------------

This functionality is obtained using the `Debug|Go to cursor' menu entry.

Runs your program until control reaches the source line where the cursor is
located.

Name of the command: cmeDbgGoToCursor.
Assigned key: `F4'


File: editor.inf,  Node: Executing until return,  Next: Returning immediatly,  Prev: Executing until cursor position is reached,  Up: Resuming the execution of the program

14.10.5 Executing until return
------------------------------

This functionality is obtained using the `Debug|Until return' menu entry.

Resumes the execution until the current function is finished. This command
can't be used in the main function. If you want to return from the current
function without executing the remaining code use the `Return now' option.
*Note Returning immediatly::.

Name of the command: cmeDbgFinishFun.


File: editor.inf,  Node: Returning immediatly,  Prev: Executing until return,  Up: Resuming the execution of the program

14.10.6 Returning immediatly
----------------------------

This functionality is obtained using the `Debug|Return now' menu entry.

This command doesn't realy resume the execution. Instead it simulates a
function return and the control is passed to the calling function. If you
want to execute the rest of the code use the `Until return' option.  *Note
Executing until return::.

Name of the command: cmeDbgReturnNow.


File: editor.inf,  Node: Finishing and restarting a debug session,  Next: Examining the calling stack,  Prev: Resuming the execution of the program,  Up: Debugging

14.11 Finishing and restarting a debug session
==============================================

Sometimes you'll want to finish the process you are currently debugging
without farther execution or even finish the whole debug session. This
section describes the available options related to it.

If you want to finish the current process without wainting until it
finishes you can `kill' it. *Note Killing the program you are debugging::.
This operation is also called restart.

You can `kill' the process and finish the debug session. In this case the
debugger will also finish execution. *Note Closing the debug session::.

Finally you can `kill' the process, `kill' the debugger and instruct the
editor to forget about breakpoints, watchpoints, `etc.' That's a dangerous
operation used only when no other operation helps.  *Note Destroying the
debug session::.

* Menu:

* Killing the program you are debugging::
* Closing the debug session::
* Destroying the debug session::


File: editor.inf,  Node: Killing the program you are debugging,  Next: Closing the debug session,  Prev: Finishing and restarting a debug session,  Up: Finishing and restarting a debug session

14.11.1 Killing the program you are debugging
---------------------------------------------

This functionality is obtained using the `Debug|Restart (Kill)' menu entry.

This operation will finish the execution of the program you are debugging
and go to the `Ready to Run' state. *Note Debugging states::.

After it you can start executing your program from the beginning.

Name of the command: cmeDbgKill.


File: editor.inf,  Node: Closing the debug session,  Next: Destroying the debug session,  Prev: Killing the program you are debugging,  Up: Finishing and restarting a debug session

14.11.2 Closing the debug session
---------------------------------

This functionality is obtained using the `Debug|Debug session|Close' menu
entry.

This operation will finish the execution of the program you are debugging
and then will finish the debugger. After it the state will be
`Disconnected'.  *Note Debugging states::.

After it you can start a new debug session.

Name of the command: cmeDbgCloseSession.


File: editor.inf,  Node: Destroying the debug session,  Prev: Closing the debug session,  Up: Finishing and restarting a debug session

14.11.3 Destroying the debug session
------------------------------------

This functionality is obtained using the `Debug|Debug session|Destroy' menu
entry.

This operation isn't recommended for normal use. In addition to kill the
program you are debugging and finishing the debugger it also makes the
editor to forget about breakpoints, watchpoints and other settings related
to the debug session.

After it you can start a new debug session.

Name of the command: cmeDbgEndSession.


File: editor.inf,  Node: Examining the calling stack,  Next: Cleaning the debug session,  Prev: Finishing and restarting a debug session,  Up: Debugging

14.12 Examining the calling stack
=================================

This functionality is obtained using the `Debug|Calling stack' menu entry.

When your program stopped you may want to know which functions were called
in order to reach the current source line. Using this command the editor
will send the list of functions to the Message Window. *Note Message
Window::.

After sending the list of functions to the Message Window the editor will
jump to the first one. Using `Alt'+`F7' and `Alt'+`F8' you can navigate
this list.

In addition to the source file, function name, line of code and memory
address you'll also find the arguments of the function.

Name of the command: cmeDbgCallStack.
Assigned key: `Ctrl+F3'


File: editor.inf,  Node: Cleaning the debug session,  Next: Selecting the thread to debug,  Prev: Examining the calling stack,  Up: Debugging

14.13 Cleaning the debug session
================================

This dialog is obtained using the `Debug|Debug session|Clear debug
elements' menu entry.

Usually you'll want the editor to remmeber the breakpoints, watchpoints,
watches, `etc.' used in your last debug session. For this reason this data
is stored in the project file. But sometimes you could want to clean all
and do a fresh start. This command allows you to delete all of this or
just a portion. You erase items of the following types:

   * Breakpoints. *Note Advanced breakpoint options::.

   * Watchpoints. *Note Watchpoints::.

   * Watches. *Note Watch an expression::.

   * Inspectors. *Note Inspectors::.

   * Data windows. *Note Data Window::.

Name of the command: cmeDbgCleanElem.


File: editor.inf,  Node: Selecting the thread to debug,  Next: Disassembler Window,  Prev: Cleaning the debug session,  Up: Debugging

14.14 Selecting the thread to debug
===================================

This dialog is obtained using the `Debug|Select thread' menu entry.

GDB can debug multithread programs that uses POSIX threads. The starting
thread is the one you'll stop, step, trace, `etc.' If you want to select
another thread to debug you can use this option. Note that gdb uses its own
thread ids. The editor will offer a list of known threads and indicate
which one is the current thread. GDB doesn't have any MI command to know
which one is the current thread, for this reason the editor assumes that's
the last thread id informed during a stop.

Debugging multithread programs is complicated and I don't have good test
examples. If you need to enhance the current options and want to cooperate
with me please contact me.

Name of the command: cmeDbgThreadSel.


File: editor.inf,  Node: Disassembler Window,  Next: Debugging already running processes,  Prev: Selecting the thread to debug,  Up: Debugging

14.15 Disassembler Window
=========================

This functionality is obtained using the `Debug|Disassembler Window' menu
entry.

If you need to debug your program at the instruction level or debug some
code that lacks debug information that's the tool you need.

The Disassembler Window is divided in two sections. The left side contains
the assembler code and the right side the CPU registers. The code side
displays the assembler using a read-only edition window. If the code have
debug information you'll see the source code mixed as comments.

The `Step over', `Trace into' and `Go to cursor' operations works at
instruction level when applied to this window.

You can manually open this window. Additionlly the editor will open this
window every time the execution stops in a function without debug
information. When the editor can determine the function name and the source
file that contains it the whole function will be disassembled. If only the
function name can be determined the editor will disassemble from the
beginning of the function upto 500 bytes after the current location. If
nothing can be determined the editor will disassemble 500 bytes from the
current location.

Sometimes gdb informs bogus function locations. What's worst is that
disassembling from the informed place upto the current location can be too
slow and even make gdb to SIGSEGV. To avoid it the editor won't disassemble
from the beginning of the function if the distance is bigger than 20000
bytes.

When this window is opened the code section is selected. You can switch to
the registers section using the `Tab' key. Selecting a register and using
the `Enter' key you can modify its value.

If you get an error from gdb stating `bad register number' when you open
this window please try upgrading gdb. That's a bug in the MI code. I
submitted a patch to fix this problem to the proper list. It seems to
affect gdb 6.1 and 6.2.

Name of the command: cmeDbgDisAsmWin.


File: editor.inf,  Node: Debugging already running processes,  Next: Debug Messages Window,  Prev: Disassembler Window,  Up: Debugging

14.16 Debugging already running processes
=========================================

You can debug a process that's already running in memory. This is really
useful when your program exposes an uncommon bug that's hard to reproduce.

The steps to do it are almost the same used for regular programs. Only a
few details changes:

   * As the program is already running you have to stop it instead of run
     it.

   * When you finish debugging you could want to let it run without farther
     intrusion.

The first action is called `atach' and the second `detach'.

To start debugging an already running process you must select this option
in the `Debug Options' dialog. *Note Debug options::. Then you must know
the process id for the process you want to debug. This can be found using
the `ps' POSIX command.

To atach gdb to the running process you must use the
`Debug|Run/Continue/Atach' menu option. It will ask you the process id
(pid).

Once gdb is atached to the running process it is stopped and the state is
changed to `Stopped'. *Note Debugging states::.

When you no longer need to debug the process you can detach from it using
the `Debug|Debug session|Detach' menu option. The process will resume its
normal execution.

Name of the command: cmeDbgDetach.


File: editor.inf,  Node: Debug Messages Window,  Next: Editing a debug expression,  Prev: Debugging already running processes,  Up: Debugging

14.17 Debug Messages Window
===========================

This window is used to:

   * Show gdb messages. *Note Messages displayed::.

   * Show the current debugging state. *Note Debugging states::.

   * Show extra information about the current state. It includes errors
     from gdb or in the communication with gdb.

   * Send commands to gdb.

When you start a new debug session this window becomes visible. When the
session is closed the window is hided. When the window is hided you can
access it using the list of windows dialog. *Note List::.

The maximum ammount of messages displayed in this window is limited to
avoid wasting memory. You can configure this value using the advanced
options dialog. *Note Advanced debug options::.

To send commands to gdb use the `Insert' key.


File: editor.inf,  Node: Editing a debug expression,  Next: Debugging in the Linux console,  Prev: Debug Messages Window,  Up: Debugging

14.18 Editing a debug expression
================================

When a dialog asks for an expression to watch, modify, `etc.' you can
enter any expression that gdb can analize. This includes arithmetic
operations and function calls.


File: editor.inf,  Node: Debugging in the Linux console,  Prev: Editing a debug expression,  Up: Debugging

14.19 Debugging in the Linux console
====================================

When you debug in a Linux console the editor uses a separated virtual
terminal for the program you want to debug. The terminal is automatically
selected but you can specify it using the debug options dialog.  *Note
Debug options::.

One reason to specify a fixed terminal is when you have more than one video
card. In this case you can allocate some virtual terminals in the secondary
video board and use them to run the program to debug.

When using only one video card the debug window should be in some visible
part of the editor's desktop. This window indicates the current status and
hence you can know if your program is stopped or running. *Note Debug
Messages Window::.

Remmember that when the editor is running in a Linux console you must use
the `Ctrl' + `Alt' + `Fn' key combination to switch to another virtual
terminal.


File: editor.inf,  Node: Miscellaneous,  Next: Index,  Prev: Debugging,  Up: Top

15 Miscellaneous
****************

* Menu:

* Configuration files location::
* Clipboard::
* Time and date modifiers formats::
* Regular Expressions::
* Desktop Files::
* Text mode attributes::
* File Open::
* Message Window::
* Error messages from an external application::
* Mouse under Linux::
* Passing extra command line options::
* How to run setedit remotely without root installation (UNIX)::


File: editor.inf,  Node: Configuration files location,  Next: Clipboard,  Prev: Miscellaneous,  Up: Miscellaneous

15.1 Configuration files location
=================================

  The configuration files are read from various directories allowing to use
system wide defaults and also user defined settings. The mechanism used to
determine which file to load depends on the OS. For DOS and Windows the
editor doesn't know much about users and uses an approach that's different
to the one used for POSIX systems (Linux, FreeBSD, QNX, Solaris, `etc.').
The Cygwin version of the editor is considered as a POSIX version even when
that's a Windows binary.

* Menu:

* Configuration directories for DOS and Windows::
* Configuration directories for POSIX systems::


File: editor.inf,  Node: Configuration directories for DOS and Windows,  Next: Configuration directories for POSIX systems,  Prev: Configuration files location,  Up: Configuration files location

15.1.1 Configuration directories for DOS and Windows
----------------------------------------------------

  Here is the list of directories where the editor looks for a
configuration file. Note that Cygwin binaries are an exception and they
behave as binaries compiled for POSIX systems. *Note Configuration
directories for POSIX systems::.

  One concept used during the search is the `home directory'. It is
determined using the `HOME' environment variable. If this variable isn't
defined the editor tries with `HOMEDIR'. We represent it using `~'.

  To represent the content of an environment variable the examples use
`%VARIABLE%'. In the examples we will represent the configuration file
naming it `FILE'.

  1. `~/FILE'

  2. `%SET_FILES%/FILE'

  3. The directory where you started the editor.

  The `SET_FILES' environment variable should point to the directory where
system wide configuration files are stored. Note that if the `SET_FILES'
environment variable isn't defined the editor tries to figure out it using
the following sequence:

  1. The installation directory detected or specified at compilation time
     adding the `share/setedit' directory.

  2. The directory where the binary is located eliminating the `bin' part
     and adding `share/setedit' directory.


File: editor.inf,  Node: Configuration directories for POSIX systems,  Prev: Configuration directories for DOS and Windows,  Up: Configuration files location

15.1.2 Configuration directories for POSIX systems
--------------------------------------------------

  Here is the list of directories where the editor looks for a
configuration file. Note it includes Cygwin binaries.

  One concept used during the search is the `home directory'. It is
determined using the `HOME' environment variable. If this variable isn't
defined the editor tries with `HOMEDIR'. We represent it using `~'.

  To represent the content of an environment variable the examples use
`$VARIABLE'. In the examples we will represent the configuration file
naming it `FILE'. In POSIX systems a hidden file is created using a dot a
preffix.

  1. `~/.setedit/FILE' (Note: this directory is created if it doesn't
     exist).

  2. `~/.setedit/.FILE'

  3. `~/FILE'

  4. `~/.FILE'

  5. `$SET_FILES/FILE'

  The `SET_FILES' environment variable should point to the directory where
system wide configuration files are stored. Note that if the `SET_FILES'
environment variable isn't defined the editor tries to figure out it using
the following sequence:

  1. The installation directory detected or specified at compilation time
     adding the `share/setedit' directory.

  2. `/usr/share/setedit'

  3. `/usr/local/share/setedit'


File: editor.inf,  Node: Clipboard,  Next: Time and date modifiers formats,  Prev: Configuration files location,  Up: Miscellaneous

15.2 Clipboard
==============

The clipboard is just another editor window, which holds the text you used
the `Cut' and `Copy' commands on, and retrieve it with the `Paste' command.

Unlike the windows clipboard the one provided with the editor doesn't lose
the old contents when you copy to it. This approach has the important
advantage that you can copy text from various parts to the clipboard and
then paste all the text in one place with just one operation. To do it
select the clipboard window, select the text to paste and the editor
pastes the text selected in the clipboard window.

The disadvantage is that all the text copied to the clipboard remains there
and if you are running on a machine with low memory and handling huge files
you can fill all the memory quickly. To avoid this check the clipboard
size (with `Alt+0') and exit the program if it gets too big. That normally
isn't needed on machines with enough free disk space that can be used as
swap.


File: editor.inf,  Node: Time and date modifiers formats,  Next: Regular Expressions,  Prev: Clipboard,  Up: Miscellaneous

15.3 Time and date modifiers formats
====================================

This values are the same used by the `strftime' function of the standard
`libc'. The editor uses it in the printing module. *Note Print Setup::.

   * `%A'
     - Meaning: The full weekday name (`Friday')

   * `%a'
     - Meaning: The abbreviated weekday name (`Fri')

   * `%B'
     - Meaning: The full month name (`October')

   * `%b, %h'
     - Meaning: The abbreviated month name (`Oct')

   * `%C'
     - Meaning: Short for `%a %b %e %H:%M:%S %Y' (`Fri Oct  1 15:30:34
     1993')

   * `%c'
     - Meaning: Short for `%m/%d/%y %H:%M:%S' (`10/01/93 15:30:34')

   * `%e'
     - Meaning: The day of the month

   * `%D'
     - Meaning: Short for `%m/%d/%y' (`10/01/93')

   * `%d'
     - Meaning: The day of the month

   * `%H'
     - Meaning: The hour (0-24)

   * `%I'
     - Meaning: The hour (1-12)

   * `%j'
     - Meaning: The Julian day

   * `%k'
     - Meaning: The hour (0-24)

   * `%l'
     - Meaning: The hour (1-12)

   * `%M'
     - Meaning: The minutes

   * `%m'
     - Meaning: The month (1-12)

   * `%n'
     - Meaning: A newline (`n')

   * `%p'
     - Meaning: AM or PM (`PM')

   * `%R'
     - Meaning: Short for `%H:%M' (`15:30')

   * `%r'
     - Meaning: Short for `%I:%M:%S %p' (`03:30:35 PM')

   * `%S'
     - Meaning: The seconds

   * `%T, %X'
     - Meaning: Short for `%H:%M:%S' (`15:30:35')

   * `%t'
     - Meaning: A tab (`t')

   * `%U'
     - Meaning: The week of the year

   * `%W'
     - Meaning: The week of the year

   * `%w'
     - Meaning: The day of the week (0-6) (`5')

   * `%x'
     - Meaning: Short for `%m/%d/%y' (`10/01/93')

   * `%y'
     - Meaning: The year (00-99) of the century (`93')

   * `%Y'
     - Meaning: The year

   * `%Z'
     - Meaning: The timezone abbreviation (`EDT')

   * `%%'
     - Meaning: A percent symbol (`%')



File: editor.inf,  Node: Regular Expressions,  Next: Desktop Files,  Prev: Time and date modifiers formats,  Up: Miscellaneous

15.4 Regular Expressions
========================

The editor supports regular expressions in the search and replace commands,
here is a description of the syntax.

Regular expressions ("RE"s), as defined in POSIX 1003.2, come in two
forms: modern REs (roughly those of `egrep'; 1003.2 calls these _extended_
REs) and obsolete REs (roughly those of `ed'; 1003.2 _basic_ REs).
Obsolete REs mostly exist for backward compatibility in some old programs;
they will be discussed at the end.  1003.2 leaves some aspects of RE
syntax and semantics open; `(*)' marks decisions on these aspects that may
not be fully portable to other 1003.2 implementations.

A (modern) RE is one(*) or more non-empty(*) _branches_, separated by `|'.
It matches anything that matches one of the branches.

A branch is one(*) or more _pieces_, concatenated.  It will try to find a
match for the first, then for the second, etc.

A piece is an _atom_ possibly followed by a single(*) `*', `+', `?', or
_bound_.  An atom followed by `*' matches a sequence of 0 or more
occurences of the atom.  An atom followed by `+' matches a sequence of 1
or more occurences of the atom.  An atom followed by `?' matches a
sequence of 0 or 1 occurences of the atom.

A _bound_ is a `{' followed by an unsigned decimal integer, possibly
followed by `,' possibly followed by another unsigned decimal integer,
always followed by `}'.  The integers must lie between 0 and `RE_DUP_MAX'
(255(*)) inclusive, and if there are two of them, the first may not exceed
the second.  An atom followed by a bound containing one integer `i' and no
comma matches a sequence of exactly `i' occurences of the atom.  An atom
followed by a bound containing one integer `i' and a comma matches a
sequence of `i' or more occurences of the atom.  An atom followed by a
bound containing two integers `i' and `j' matches a sequence of `i'
through `j' (inclusive) occurences of the atom.

An atom is a regular expression enclosed in `()' (one occurence for the
regular expression), an empty set of `()' (matches the null string(*)), a
_bracket expression_ (see below), `.' (matching any single character), `^'
(matching the null string at the beginning of a line), `$' (matching the
null string at the end of a line), a `\\' followed by one of the
characters `^.[$()|*+?{\\' (matches that character taken as an ordinary
character), a `\\' followed by any other character(*) (matches that
character taken as an ordinary character, as if the `\\' had not been
present(*)), or a single character with no other significance (matching
that character).  A `{' followed by a character other than a digit is an
ordinary character, not the beginning of a bound(*).  It is illegal to end
an RE with `\\'.

A _bracket expression_ is a list of characters enclosed in `[]'.  It
normally matches any single character from the list (but see below).  If
the list begins with `^', it matches any single character (but see below)
_not_ from the rest of the list.  If two characters in the list are
separated by `-', this is shorthand for the full _range_ of characters
between those two (inclusive) in the used character set, e.g. `[0-9]'
matches any decimal digit in ASCII.  It is illegal(*) for two ranges to
share an endpoint, e.g. `a-c-e'.  Ranges are very character set-dependent,
and portable programs should avoid relying on them.

To include a literal `]' in the list, make it the first character
(following a possible `^').  To include a literal `-', make it the first
or last character, or the second endpoint of a range.  To use a literal
`-' as the first endpoint of a range, enclose it in `[.' and `.]' to make
it a collating element (see below).  With the exception of these and some
combinations using `[' (see next paragraphs), all other special
characters, including `\\', lose their special significance within a
bracket expression.

Within a bracket expression, a collating element (a character, a
multi-character sequence that collates as if it were a single character,
or a collating-sequence name for either) enclosed in `[.' and `.]'  stands
for the sequence of characters of that collating element.  The sequence is
a single element of the bracket expression's list.  A bracket expression
containing a multi-character collating element can thus match more than
one character, e.g. if the collating sequence includes a `ch' collating
element, then the RE `[[.ch.]]*c' matches the first five characters of
"chchcc".

Within a bracket expression, a collating element enclosed in `[=' and `=]'
is an equivalence class, standing for the sequences of characters of all
collating elements equivalent to that one, including itself.  (If there
are no other equivalent collating elements, the treatment is as if the
enclosing delimiters were `[.' and `.]'.)  For example, if o and \o'o^'
are the members of an equivalence class, then `[[=o=]]', `[[=\o'o^'=]]',
and `[o\o'o^']' are all synonymous.  An equivalence class may not be an
endpoint of a range.

Within a bracket expression, the name of a _character class_ enclosed in
`[:' and `:]' stands for the list of all characters belonging to that
class.  Standard character class names are:

     alnum	digit	punct
     alpha	graph	space
     blank	lower	upper
     cntrl	print	xdigit

These stand for the character classes defined by `isalnum', `isdigit',
`ispunct', `isalpha', `isgraph' , `isspace' (`blank' is the same as
`space'), `islower', `isupper', `iscntrl', `isprint', and `isxdigit',
respectively.  A locale may provide others.  A character class may not be
used as an endpoint of a range.

There are two special cases(*) of bracket expressions: the bracket
expressions `[[:<:]]' and `[[:>:]]' match the null string at the beginning
and end of a word respectively.  A word is defined as a sequence of word
characters which is neither preceded nor followed by word characters.  A
word character is an `alnum' character (as defined by the `isalnum'
library function) or an underscore.  This is an extension, compatible with
but not specified by POSIX 1003.2, and should be used with caution in
software intended to be portable to other systems.

In the event that an RE would match more than one substring of a given
string, the RE matches the one starting earliest in the string.  If the RE
could match more than one substring starting at that point, it matches the
longest.  Subexpressions also match the longest possible substrings,
subject to the constraint that the whole match be as long as possible,
with subexpressions starting earlier in the RE taking priority over ones
starting later.  Note that higher-level subexpressions thus take priority
over their lower-level component subexpressions.

Match lengths are measured in characters, not collating elements.  A null
string is considered longer than no match at all.  For example, `bb*'
matches the three middle characters of `abbbc',
`(wee|week)(knights|nights)' matches all ten characters of `weeknights',
when `(.*).*' is matched against `abc' the parenthesized subexpression
matches all three characters, and when `(a*)*' is matched against `bc'
both the whole RE and the parenthesized subexpression match the null
string.

If case-independent matching is specified, the effect is much as if all
case distinctions had vanished from the alphabet.  When a letter that
exists in multiple cases appears as an ordinary character outside a
bracket expression, it is effectively transformed into a bracket
expression containing both cases, e.g. `x' becomes `[xX]'.  When it
appears inside a bracket expression, all case counterparts of it are added
to the bracket expression, so that (e.g.) `[x]' becomes `[xX]' and `[^x]'
becomes `[^xX]'.

No particular limit is imposed on the length of REs(*).  Programs intended
to be portable should not employ REs longer than 256 bytes, as an
implementation can refuse to accept such REs and remain POSIX-compliant.

Obsolete (_basic_) regular expressions differ in several respects.  `|',
`+', and `?' are ordinary characters and there is no equivalent for their
functionality.  The delimiters for bounds are `\\{' and `\\}', with `{'
and `}' themselves being ordinary characters.  The parentheses for nested
subexpressions are `\(' and `\)', with `(' and `)' themselves being
ordinary characters.  `^' is an ordinary character except at the beginning
of the RE or(*) the beginning of a parenthesized subexpression, `$' is an
ordinary character except at the end of the RE or(*) the end of a
parenthesized subexpression, and `*' is an ordinary character if it
appears at the beginning of the RE or the beginning of a parenthesized
subexpression (after a possible leading `^').  Finally, there is one new
type of atom, a _back reference_: `\\' followed by a non-zero decimal
digit _d_ matches the same sequence of characters matched by the _d_th
parenthesized subexpression (numbering subexpressions by the positions of
their opening parentheses, left to right), so that (e.g.) `\\([bc]\\)\\1'
matches `bb' or `cc' but not `bc'.


File: editor.inf,  Node: Desktop Files,  Next: Text mode attributes,  Prev: Regular Expressions,  Up: Miscellaneous

15.5 Desktop Files
==================

Each time you run the editor it searches for a desktop file in the current
directory, if the editor can't find any desktop file it searches in the
directory indicated by the enviroment variable `SET_FILES'. If no desktop
files are found the editor uses internal default values. By creating a
desktop file in the `%SET_FILES%' directory you'll indicate default
values. To create a desktop file in this directory just run the editor in
the directory, customize it and leave the editor. This feature is very
useful to customize things like: Colors, Palette, Global editor options,
`etc.'

When you exit from the editor it saves all the settings, windows positions,
`etc.' to a desktop file stored in the current directory. Some people
don't like this and therefore a special mode in which the editor stores
just one desktop file in the `%SET_FILES%' directory and not in each
directory exists. This approach has the advantage of saving disk space,
but you won't have local settings. If you use this approarch and want to
keep a local configuration in a directory use a project. *Note Project::.
To store only one centralized desktop file: *Note Editor General::.

The desktop files have `.dst' as extension.


File: editor.inf,  Node: Text mode attributes,  Next: File Open,  Prev: Desktop Files,  Up: Miscellaneous

15.6 Text mode attributes
=========================

Text modes uses up to 16 colors for forground and 16 colors for background,
that's because the attributes of each character are stored in a 1 byte
allowing just 256 combinations. So four bits are dedicated to the
background color giving 16 combinations and the other four bits for the
foreground.

As we have only 16 colors there is a big chance that our preferred colors
aren't included. For this reason the VGA chip uses a palette of colors.
That means that these 16 colors aren't fixed and you can indicate what
colors to use. The values are just index values and you can assign to it
any color.

The VGA chip supports 18(6:6:6) bits per color giving 262,144
combinations. The colors are created using the RGB (Red Green and Blue)
method. That's simply because the CRT (Cathode Rays Tube) of the monitor
uses this method to create the colors. You have 6 bits per component
giving 64 different levels.

There is a little more of complexity added to the VGA card. The most
significant bit of the background is used to create blinking text. The
editor avoids this mode because it restricts the background combinations
to 8 and the editor doesn't need blinking text. The other funny thing of
the attribute is the most significant bit of the foreground color. It has
a special meaning but even when using it, it doesn't reduce the number of
combinations.  That means that this bit can select two things at the same
time. By now you'll be asking: What? This bit can be used to select a
second font, in this way you can have upto 512 different characters on the
screen. The editor can exploit it but you must understand that this bit is
used for the foreground color too. You can customize the palette to reduce
the number of foreground combinations to 8 and defining the 9th color with
the same value as the 0th color and so on. Then you can assign different
colors and different fonts to the things in the editor. You can for
example use a font for the menues and other for the text, or a font for
the code and other for the comments.  The editor goes even further
allowing different code page encodings for each font. I really never saw
it in any editor. You can use it for example to write your code using a
font with the ISO Latin 1 encoding (used by Linux and Windows in the USA
and part of Europe) and have your comments in russian (using cyrillic
characters).

To learn how to customize the palette: *Note Color Palette::.
To learn how to assign colors to the things used in the editor: *Note
Customize Colors::.
To learn how to select a font and an encoding: *Note Screen Options::.

File: editor.inf,  Node: File Open,  Next: Message Window,  Prev: Text mode attributes,  Up: Miscellaneous

15.7 File Open
==============

This dialog is used to select a file in various places. Even when it has
different names and purposes the dialog is always the same.

The dialog is similar to the one used by most of the T/GUI programs so I'll
focus on special details and particularities.

All the files and directories are shown together, the directories have a
slash at the end. The current directory and selected file information is
shown at the bottom of the dialog.

To select a different disk, at least in DOS, you can simply type the drive
letter followed by a colon in the text input area and press <Enter>. You
can specify a mask in the text area too. Even though under DOS a single
asterisk matches any filename, the *.* mask won't match with a filename
that lacks extension. You can use some asterisks and question marks in the
mask, they work like in most of the shells (DOS command.com included).
Additionally the mask can contain brackets, if your shell doesn't use it
and you never used it here is an example: `*.[ch]*' will match with
test.c, test.h, test.cc, test.cpp, `etc.' the brackets indicates the
possible characters that will match, in this case the first character
after the point should be c or h.
Pressing the down arrow while you are in the text input area you'll get a
list of the paths in which you selected files in the past. That's very
useful when you load files from two or more very different directories.

The `Home' changes the directory to the one from where you started the
editor, that's very useful when you navigate a lot and you want to quickly
return to the directory from where you started.

The `Options' button brings a dialog to configure the sorting options and
which files to exclude. These options are described in the following
subsections.

The editor remembers the last place where you selected a file the last time
you used it. This information is stored in the desktop file. This
information is unique for the following selections: open a file to edit,
save a file, open a help file, save a block of text, open/save a project,
open an MP3 file and save an MP3 file. In this way you can be opening
files from a directory and saving newly created files to another at the
same time without indicating the directory each time you open/save a file.

* Menu:

* Sorting of the files and directories in the dialog::
* Files and directories excluded in the dialog::


File: editor.inf,  Node: Sorting of the files and directories in the dialog,  Next: Files and directories excluded in the dialog,  Prev: File Open,  Up: File Open

15.7.1 Sorting of the files and directories in the dialog
---------------------------------------------------------

By default the sorting criteria is the following:

   * Names sorting is case insensitive.

   * Directories are listed after files.

   * The parent directory (`..') is the last entry.

   * Files starting with a dot are alphabetically listed.

But this can be customized with the `File open dialog' menu option or the
`Options' button of the dialog. It brings a dialog with the following
options:

   * Sort type: controls how the names are sorted.
        * Alphabetical: both, directories and file names, are mixed.

        * Directories first: the directories are listed first.

        * Files first: file names are listed first.


   * Case style: controls if the dialog differentiates between capital and
     lower case ones.
        * Capital letters goes first: the names are sorted according to the
          ASCII table

        * Case insensitive: the names are sorted lexicographically.


   * Parent directory: this option controls the location of the parent
     directory link (`..'). It doesn't affect the `Alphabetical' sorting.
        * First in the list: the parent is the first entry in the list.

        * At the end of the list: the parent is the last entry in the list.


   * Files starting with a dot: it controls how names starting with a dot
     are handled.
        * Normally sorted: they will be sorted alphabetically. As the
          `ASCII' code of a dot is less than the code of any letter they
          will be first in the list. That's quite annoying when you use
          UNIX style backups and they are also hidden files.

        * After the rest: they will be put at the end of the list.

The other options you'll find in this configuration dialog are described in
another subsection. *Note Files and directories excluded in the dialog::.

Something very important that you must know is how the <Shift> key is
interpreted.

When the sorting is `Alphabetical' and the list is case sensitive
(`Capital letters are first') the shift key affects the case of the typed
letters so you must be careful; check the state of <Caps Lock> now and
then as well.

When the sorting isn't `Alphabetical' the <Shift> has a special meaning.
If you press shift while typing the first letter of the name then the
search will be done in the list of directories instead of the list of file
names. Once you are in one of the lists the rest of the search is done in
this list. If the list is case sensitive it creates an interesting
conflict because you could need to press shift for some file name and then
the search will be done in the directories list. Don't forget this.


File: editor.inf,  Node: Files and directories excluded in the dialog,  Prev: Sorting of the files and directories in the dialog,  Up: File Open

15.7.2 Files and directories excluded in the dialog
---------------------------------------------------

By default all names found are listed but this can be customized with the
`File open dialog' menu option or the `Options' button of the dialog. The
related options are:

   * Exclude files: controls which names are excluded.
        * Ending with tilde: names ending with a tilde are excluded. They
          usually belong to UNIX-style backups. The editor generates these
          files when you configure it to generate UNIX style backups.

        * Ending with .bkp: names with the bkp extension are excluded. By
          default the editor generates backup files with this extension.

        * Starting with dot: names starting with a dot are excluded. In
          UNIX they are hidden files. The editor can be configured to
          create backup files as hidden files.

Personally I only exclude files with the bkp extension and sort files
starting with a dot so they appear at the end of the list.


File: editor.inf,  Node: Message Window,  Next: Error messages from an external application,  Prev: File Open,  Up: Miscellaneous

15.8 Message Window
===================

This window is used to show important information that you may want to have
at hand. Some examples are: the results of a printing operation, the errors
collected from an external program, the hits of the powered grep, the tip
of the day, the output of an external program, etc.

The message window doesn't have a number but can be accessed from the list
of windows (default `Alt+0') or from the `Windows | Message Window' menu
option.

If the messages are errors or hits from grep you can use `Alt+F7' and
`Alt+F8' to quickly jump to the next/previous line. You can also just
select any of the error/hits. The errors are parsed by the editor according
to the user selection. Many formats are supported by the editor and the
mechanism is configurable. See the next section for more information.

When the last or first error in the list is reached the editor indicates
it.  This behavior can be configured. *Note Editor General::.

You can also delete entries in the message window pressing <Delete>. To
add more flexibility the content of the message window can be stored in a
file or copied to the clipboard, to do this just use the menu.

For more information about the behavior of the message window when you run
external programs *Note Run program (which one)::.


File: editor.inf,  Node: Error messages from an external application,  Next: Mouse under Linux,  Prev: Message Window,  Up: Miscellaneous

15.9 Error messages from an external application
================================================

Originally the editor only supported the GNU style. After many users asked
for support of other error formats Grzegorz Adam Hankiewicz suggested
doing it in a configurable way. So starting with v0.4.41 the editor can be
configured to parse the errors from an external application.

The configuration is stored in a file called `errors.cle'. The syntax is
very similar to the one used in the `syntaxhl.shl' file. All definitions
start with a `Name' declaration that indicates the name of the parsing
options and ends with an `End' marker. *Note Configuration files
location::.

The `Pattern' entry tells the editor how to parse a line containing an
error from the external program. The pattern is actually a Perl regular
expression. I used it because they are much more easy to learn than POSIX
regular expressions and they are a lot more logical to me.

The `File', `Line', `Severity' and `Description' entries indicate - with
subexpressions - the file name, line number, degree of severity and
description of the error. Note that actually only the first two are used.
If you don't know what a subexpression is here is a hint: look at the
parentheses.

The `EnterDirPat' is another Perl regex to indicate how make informs about
a directory change. `EnterDirDir' is the related subexpression.  That's
needed for GNU make, I guess other make tools have a similar mechanism.
`LeaveDir' is the pattern generated by make to indicate a change to the
parent directory.


File: editor.inf,  Node: Mouse under Linux,  Next: Passing extra command line options,  Prev: Error messages from an external application,  Up: Miscellaneous

15.10 Mouse under Linux
=======================

When you are running in a console the mouse is captured by the editor and
you can't use it to copy/paste between consoles. If you want to do it you
must hold down the right <Alt> key and use the mouse as usually. Note this
can be altered if you changed the alt keys configuration.  *Note Alt key
configuration::. Additionally note that when you paste the keys are
interpreted as <Alt> plus the key you pressed so the carriage returns
aren't interpreted very well.

If you are using an X terminal the mouse isn't interactive because X
terminals only report when the button is pressed and released but not when
it's moved. You can do all the normal operations but you won't get the
usual feedback.


File: editor.inf,  Node: Passing extra command line options,  Next: How to run setedit remotely without root installation (UNIX),  Prev: Mouse under Linux,  Up: Miscellaneous

15.11 Passing extra command line options
========================================

You can pass extra command line options defining an environment variable.
It's called SET_CMDLINE. The editor will parse this variable and add it to
the options passed in the command line. These options will be interpreted
before the options passed in the command line.

Any space (including tabs) are interpreted as separators. If you need to
pass a file name containing spaces you must enclose the name with double
quotes.  If you need to pass a name containing a double quote you must
escape it using a back slash. Here are some examples:

   * ops 1
     - The editor interpretes: two options "ops" and "1"

   * "ops 1"
     - The editor interpretes: one option "ops 1"

   * ops"1
     - The editor interpretes: one option containing a double quote inside


This mechanism can be used to set default options and avoid typing them all
the time. Another use is when you need to pass options to the editor and
you are using Eterm; which can't pass command line options, so you must
use this mechanism.


File: editor.inf,  Node: How to run setedit remotely without root installation (UNIX),  Prev: Passing extra command line options,  Up: Miscellaneous

15.12 How to run setedit remotely without root installation (UNIX)
==================================================================

This text was contributed by Grzegorz Adam Hankiewicz:

I'm a lucky guy and I've been hired by eFaber (http://www.efaber.net) to
do some open source hacking. The first day I started I was given a
computer and received strong orders: `Install Suse Linux 8.1 and customize
your environment'. Obviously I chose to install setedit, and it worked
great. However, from time to time I have to go to another workstation or
login remotely. We export `/home' through NFS, so apparently we have the
same configuration everywhere. But setedit doesn't work that way.

First of all, setedit depends on the TVision library, and only my PC has
it installed. setedit also needs a global directory where shared files
reside, usually `/usr/share/setedit', or something else pointed by
`SET_FILES'.  One solution would be to install setedit everywhere, but
this is not scalable, and it's error prone. If I wanted to upgrade setedit
or TVision I would spend much time copying and installing on every
machine. Besides, even if my coworkers let me use root, or told me the
password, I would never be given access to the main server, and it's the
only one with email I/O. What's the solution?

The solution is to put the files needed by setedit on the exported
directory, in other words, `$HOME'. After you compile setedit, put the
binary in `~/bin'. Find where your TVision is (librhtv*) and copy the
library to `~/lib'. If you run `ldd' on `~/bin/setedit' you will see that
the librhtv dependency is resolved to your local file system. If you
logged now to another computer, the library wouldn't be found.

To avoid this, add something similar to this to your .bashrc:

        export PATH=$PATH:~/bin
        export LD_LIBRARY_PATH=~/lib

After you log in again, try to use ldd on the binary, and now you should
see the linker resolve it to your `~/lib' everywhere.  First step
complete.  The second step is to move the shared files.  I created the
directory in `~/bin/setedit_shared_files', and made `/usr/share/setedit'
on my local machine a symlink to it, so newer installs of setedit
overwrite the correct shared files.  Now make `SET_FILES' point to it:

        export SET_FILES=~/bin/setedit_shared_files

Nice. Now, if you run setedit it will be able to load, but you will still
find two annoying facts: setedit always looks for the `setedit.info' file
(which is usually found in `/usr/info/setedit.info.gz'), and the language
translations won't be found because GNU's gettext doesn't know anything
about our exportation trick.

To solve the info file warning, copy setedit.info.gz to
`~/bin/setedit_shared_files' and add that directory to the appropriate
environment variable:

        export INFOPATH=$INFOPATH:$SET_FILES

Finally, to correct the gettext problem, first make `SET_LOCELEDIR' point
to `SET_FILES':

        export SET_LOCALEDIR=$SET_FILES

And now, in the `SET_FILES' directory create the `xxxx/LC_MESSAGES/'
directory structure, where `xxxx' is a two letter code representing a
language.  I would then create
`~/bin/setedit_shared_files/es/LC_MESSAGES', and put inside the file
`setedit.mo' I found typing `locate setedit.mo' on my workstation.  After
copying the file there, GNU's gettext will find the translation file
always, from any directory, and you will be able to hack from every
computer as if you were at home.

Again, what you have to add to your `.bashrc' file is:

        export PATH=$PATH:~/bin
        export LD_LIBRARY_PATH=~/lib
        export SET_FILES=~/bin/setedit_shared_files
        export INFOPATH=$INFOPATH:$SET_FILES
        export SET_LOCALEDIR=$SET_FILES

Happy hacking!


File: editor.inf,  Node: Index,  Next: Index of key commands,  Prev: Miscellaneous,  Up: Top

16 Index
********

 [index ]
* Menu:

* About the Author:                      About the Author.         (line 6)
* Address - Change base address (DW):    Address - Change base address (DW).
                                                                   (line 6)
* Address - Follow pointer (DW):         Address - Follow pointer (DW).
                                                                   (line 6)
* Address - Follow pointer in new window (DW): Address - Follow pointer in new window (DW).
                                                                   (line 6)
* Address - Go to new address (DW):      Address - Go to new address (DW).
                                                                   (line 6)
* Address - Recompute address (DW):      Address - Recompute address (DW).
                                                                   (line 6)
* Advanced breakpoint options:           Advanced breakpoint options.
                                                                   (line 6)
* Advanced debug options:                Advanced debug options.   (line 6)
* Advice dialogs:                        Advice dialogs.           (line 6)
* AllowedInsideNames:                    AllowedInsideNames.       (line 6)
* Alt key configuration:                 Alt key configuration.    (line 6)
* and:                                   and.                      (line 6)
* Another InfView:                       Another InfView.          (line 6)
* Arbitrary indent:                      Arbitrary indent.         (line 6)
* Asking for user defined values:        Asking for user defined values.
                                                                   (line 6)
* AskString:                             AskString.                (line 6)
* Assigning a sequence of commands:      Assigning a sequence of commands.
                                                                   (line 6)
* Assigning a sLisp macro:               Assigning a sLisp macro.  (line 6)
* Assigning sLisp code:                  Assigning sLisp code.     (line 6)
* Autoindent:                            Autoindent.               (line 6)
* AutoIndent (action):                   AutoIndent (action).      (line 6)
* automatic word completion:             Word completion.          (line 6)
* Available commands and keys assignments: Available commands and keys assignments.
                                                                   (line 6)
* Available debug options:               Available debug options.  (line 6)
* Back to defaults:                      Back to defaults.         (line 6)
* Backspace behavior:                    Backspace unindents.      (line 6)
* Backspace unindents:                   Backspace unindents.      (line 6)
* backups, delete:                       Delete memorized backups. (line 6)
* backups, delete at exit:               Quit.                     (line 6)
* backups, enable/disable:               Editor General.           (line 6)
* backups, listing at the end:           Sorting of the files and directories in the dialog.
                                                                   (line 6)
* backups, memorize:                     Editor General.           (line 6)
* backups, not listing:                  Files and directories excluded in the dialog.
                                                                   (line 6)
* backups, selective:                    Do not create backups for.
                                                                   (line 6)
* backups, style:                        Editor General.           (line 6)
* BindKey:                               BindKey.                  (line 6)
* Block - Clear (DW):                    Block - Clear (DW).       (line 6)
* Block - Fill (DW):                     Block - Fill (DW).        (line 6)
* Block - Move (DW):                     Block - Move (DW).        (line 6)
* Block alternate:                       Block alternate.          (line 6)
* Block invert:                          Block invert.             (line 6)
* Block modes:                           Block modes.              (line 6)
* Block quoted printable decode:         Block quoted printable decode.
                                                                   (line 6)
* Block to lower:                        Block to lower.           (line 6)
* Block to upper:                        Block to upper.           (line 6)
* Blocks:                                Blocks.                   (line 6)
* Blocks - Rectangular:                  Rectangular Blocks.       (line 6)
* Blocks, transparent:                   Transparent Blocks.       (line 6)
* Breakpoints:                           Breakpoints.              (line 6)
* browsing classes:                      Class browser.            (line 6)
* Bugs:                                  Bugs.                     (line 6)
* Calculator:                            Calculator.               (line 6)
* Calculator (command/menu):             Calculator (command/menu).
                                                                   (line 6)
* Calendar options:                      Calendar options.         (line 6)
* Can these files be created and updated by the editor?: Can these files be created and updated by the editor?.
                                                                   (line 6)
* Can you explain more about the behavior of this mode?: Can you explain more about the behavior of this mode?.
                                                                   (line 6)
* CanStartAName:                         CanStartAName.            (line 6)
* Cascade:                               Cascade.                  (line 6)
* Case:                                  Case.                     (line 6)
* Case (Menu):                           Case (Menu).              (line 6)
* centering the screen while typing:     Scroll Lock centers.      (line 6)
* Character toggle:                      Character toggle.         (line 6)
* Check for modified files:              Check for modified files. (line 6)
* checking if file changed:              Check for modified files. (line 6)
* Choose (Macro):                        Choose (Macro).           (line 6)
* Class browser:                         Class browser.            (line 6)
* Cleaning the debug session:            Cleaning the debug session.
                                                                   (line 6)
* Clear:                                 Clear.                    (line 6)
* Clear (Rectangle):                     Clear (Rectangle).        (line 6)
* Clipboard:                             Clipboard.                (line 6)
* Close:                                 Close.                    (line 6)
* Close (Project):                       Close (Project).          (line 6)
* CloseComment1:                         CloseComment1.            (line 6)
* closed windows, number:                Editor General.           (line 6)
* CloseWindowNumber:                     CloseWindowNumber.        (line 6)
* Closing the debug session:             Closing the debug session.
                                                                   (line 6)
* Color Palette:                         Color Palette.            (line 6)
* Color Theme:                           Color Theme.              (line 6)
* Column cursor:                         Column cursor.            (line 6)
* Column Markers:                        Column Markers.           (line 6)
* columns, marking:                      Column Markers.           (line 6)
* Commands in menu items:                Commands in menu items.   (line 6)
* Comment indent:                        Comment indent.           (line 6)
* Comment unindent:                      Comment unindent.         (line 6)
* Comments in menu files:                Comments in menu files.   (line 6)
* Compact text:                          Compact text.             (line 6)
* ComplChoose:                           ComplChoose.              (line 6)
* completion, words:                     Word completion.          (line 6)
* cond:                                  cond.                     (line 6)
* Conditional menu entries:              Conditional menu entries. (line 6)
* Configuration directories for DOS and Windows: Configuration directories for DOS and Windows.
                                                                   (line 6)
* Configuration directories for POSIX systems: Configuration directories for POSIX systems.
                                                                   (line 6)
* Configuration files:                   Configuration files.      (line 6)
* Configuration files location:          Configuration files location.
                                                                   (line 6)
* configuration files, list:             Configuration files.      (line 6)
* configuration files, location:         Configuration files location.
                                                                   (line 6)
* Consult scan codes:                    Consult scan codes.       (line 6)
* Consulting scan codes:                 Consulting scan codes.    (line 6)
* Continue execution:                    Continue execution.       (line 6)
* Conventions:                           Conventions.              (line 6)
* Convert accents to tags:               Convert accents to tags.  (line 6)
* Convert tags to accents:               Convert tags to accents.  (line 6)
* Copy:                                  Copy.                     (line 6)
* Copy (Rectangle):                      Copy (Rectangle).         (line 6)
* Copy and Paste (Rectangle):            Copy and Paste (Rectangle).
                                                                   (line 6)
* Copy to clipboard (Rectangle):         Copy to clipboard (Rectangle).
                                                                   (line 6)
* Copy to file Clipboard:                Copy to file Clipboard.   (line 6)
* Copy to Windows Clipboard:             Copy to Windows Clipboard.
                                                                   (line 6)
* Copying:                               Copying.                  (line 6)
* cpmacros.pmc:                          Pseudo Macros.            (line 6)
* Cursor movement:                       Cursor movement.          (line 6)
* cursor through tabs:                   Do not move inside tabs.  (line 6)
* Customize Colors:                      Customize Colors.         (line 6)
* Cut:                                   Cut.                      (line 6)
* Cut (Rectangle):                       Cut (Rectangle).          (line 6)
* data breakpoints:                      Watchpoints.              (line 6)
* Data Window:                           Data Window.              (line 6)
* Data Window Limitations and Details:   Data Window Limitations and Details.
                                                                   (line 6)
* Debug Messages Window:                 Debug Messages Window.    (line 6)
* Debug options:                         Debug options.            (line 6)
* debug, already running:                Debugging already running processes.
                                                                   (line 6)
* debug, breakpoints:                    Breakpoints.              (line 6)
* debug, breakpoints advanced:           Advanced breakpoint options.
                                                                   (line 6)
* debug, call stack:                     Examining the calling stack.
                                                                   (line 6)
* debug, clean:                          Cleaning the debug session.
                                                                   (line 6)
* debug, close:                          Closing the debug session.
                                                                   (line 6)
* debug, console:                        Debugging in the Linux console.
                                                                   (line 6)
* debug, edit expression:                Editing a debug expression.
                                                                   (line 6)
* debug, evaluate expression:            Evaluate or Modify expression.
                                                                   (line 6)
* debug, examining data:                 Examining data.           (line 6)
* debug, forget:                         Cleaning the debug session.
                                                                   (line 6)
* debug, frames:                         Examining the calling stack.
                                                                   (line 6)
* debug, gdb messages:                   Debug Messages Window.    (line 6)
* debug, inspectors:                     Inspectors.               (line 6)
* debug, kill:                           Killing the program you are debugging.
                                                                   (line 6)
* debug, modify expression:              Evaluate or Modify expression.
                                                                   (line 6)
* debug, monitor expression:             Watch an expression.      (line 6)
* debug, pid:                            Debugging already running processes.
                                                                   (line 6)
* debug, run:                            Running the program to debug.
                                                                   (line 6)
* debug, state window:                   Debug Messages Window.    (line 6)
* debug, stop:                           Stopping the program you are debugging.
                                                                   (line 6)
* debug, structures:                     Inspectors.               (line 6)
* debug, watchpoints:                    Watchpoints.              (line 6)
* debugger, advanced options:            Advanced debug options.   (line 6)
* debugger, selecting it:                Advanced debug options.   (line 6)
* Debugging:                             Debugging.                (line 6)
* Debugging already running processes:   Debugging already running processes.
                                                                   (line 6)
* Debugging in the Linux console:        Debugging in the Linux console.
                                                                   (line 6)
* Debugging states:                      Debugging states.         (line 6)
* debugging, mechanism used:             Mechanism used to debug.  (line 6)
* debugging, messages from gdb:          Messages displayed.       (line 6)
* debugging, path for sources:           Path for sources.         (line 6)
* debugging, platforms supported:        Supported platforms for debugging.
                                                                   (line 6)
* debugging, quick start:                Quick start to debugging. (line 6)
* debugging, supported targets:          Supported debug targets.  (line 6)
* Default global edition:                Default global edition.   (line 6)
* defmacro:                              defmacro.                 (line 6)
* Delete (Rectangle):                    Delete (Rectangle).       (line 6)
* Delete memorized backups:              Delete memorized backups. (line 6)
* Desktop Files:                         Desktop Files.            (line 6)
* desktop files, do not create:          Editor General.           (line 6)
* desktop files, style:                  Editor General.           (line 6)
* Destroying the debug session:          Destroying the debug session.
                                                                   (line 6)
* Disassembler Window:                   Disassembler Window.      (line 6)
* Do not create backups for:             Do not create backups for.
                                                                   (line 6)
* Do not move inside tabs:               Do not move inside tabs.  (line 6)
* Do not move the cursor on Paste:       Do not move the cursor on Paste.
                                                                   (line 6)
* Do not wait to search the pair:        Do not wait to search the pair.
                                                                   (line 6)
* Do you have more examples?:            Do you have more examples?.
                                                                   (line 6)
* Documentation guide:                   Documentation guide.      (line 6)
* Edit:                                  Edit.                     (line 6)
* Edit breakpoints:                      Advanced breakpoint options.
                                                                   (line 6)
* Editing a debug expression:            Editing a debug expression.
                                                                   (line 6)
* Editing Modes:                         Editing Modes.            (line 6)
* Editor General:                        Editor General.           (line 6)
* Editor specific commands:              Editor specific commands. (line 6)
* EmacsModes:                            EmacsModes.               (line 6)
* Encodings:                             Encodings.                (line 6)
* End (Rectangle):                       End (Rectangle).          (line 6)
* Enter code to run:                     Enter code to run.        (line 6)
* EOLCInFirstCol:                        EOLCInFirstCol.           (line 6)
* EOLCInFirstCol1:                       EOLCInFirstCol1.          (line 6)
* EOLCInFirstCol2:                       EOLCInFirstCol2.          (line 6)
* EOLCInFirstUse1:                       EOLCInFirstUse1.          (line 6)
* EOLCInFirstUse2:                       EOLCInFirstUse2.          (line 6)
* EOLComment1:                           EOLComment1.              (line 6)
* Error messages from an external application: Error messages from an external application.
                                                                   (line 6)
* errors from external program:          Error messages from an external application.
                                                                   (line 6)
* Escape:                                Escape.                   (line 6)
* EscapeAnywhere:                        EscapeAnywhere.           (line 6)
* eval:                                  eval.                     (line 6)
* EvalString:                            EvalString.               (line 6)
* Evaluate or Modify expression:         Evaluate or Modify expression.
                                                                   (line 6)
* Examining data:                        Examining data.           (line 6)
* Examining the calling stack:           Examining the calling stack.
                                                                   (line 6)
* Examples:                              Examples.                 (line 6)
* Executing sLisp code from a pmacro:    Executing sLisp code from a pmacro.
                                                                   (line 6)
* Executing until cursor position is reached: Executing until cursor position is reached.
                                                                   (line 6)
* Executing until return:                Executing until return.   (line 6)
* Exit:                                  Exit.                     (line 6)
* exitloop:                              exitloop.                 (line 6)
* Expand all tabs:                       Expand all tabs.          (line 6)
* Export as HTML:                        Export as HTML.           (line 6)
* Export project:                        Export project.           (line 6)
* File:                                  File.                     (line 6)
* File - Read block (DW):                File - Read block (DW).   (line 6)
* File - Write block (DW):               File - Write block (DW).  (line 6)
* File Open:                             File Open.                (line 6)
* File open dialog:                      File open dialog.         (line 6)
* Files:                                 Files.                    (line 6)
* Files and directories excluded in the dialog: Files and directories excluded in the dialog.
                                                                   (line 6)
* Files to search (Syntax help):         Files to search (Syntax help).
                                                                   (line 6)
* files, search:                         Search files under cursor in.
                                                                   (line 6)
* Find:                                  Find.                     (line 6)
* FindAgain:                             FindAgain.                (line 6)
* FindString:                            FindString.               (line 6)
* Finishing and restarting a debug session: Finishing and restarting a debug session.
                                                                   (line 6)
* FirstWord (condition):                 FirstWord (condition).    (line 6)
* Fonts:                                 Fonts.                    (line 6)
* ForceUpdate:                           ForceUpdate.              (line 6)
* Format of short syntax highlighting definitions: Format of short syntax highlighting definitions.
                                                                   (line 6)
* FullNameMatch:                         FullNameMatch.            (line 6)
* functions, heuristic jump to:          Jump to function.         (line 6)
* functions, jump to:                    Jump to symbol.           (line 6)
* General customization:                 General customization.    (line 6)
* General sLisp commands:                General sLisp commands.   (line 6)
* Generate Code:                         Generate Code.            (line 6)
* GetCursorX:                            GetCursorX.               (line 6)
* GetCursorY:                            GetCursorY.               (line 6)
* GetCurWindowNumber:                    GetCurWindowNumber.       (line 6)
* getenv:                                getenv.                   (line 6)
* GetMaxProjectItem:                     GetMaxProjectItem.        (line 6)
* GetMaxWindowNumber:                    GetMaxWindowNumber.       (line 6)
* GetProjectItem:                        GetProjectItem.           (line 6)
* GetSelection:                          GetSelection.             (line 6)
* GetSyntaxAtCursor:                     GetSyntaxAtCursor.        (line 6)
* GetSyntaxLang:                         GetSyntaxLang.            (line 6)
* GetSystemInfo:                         GetSystemInfo.            (line 6)
* GetWindowCols:                         GetWindowCols.            (line 6)
* GetWindowRows:                         GetWindowRows.            (line 6)
* GetWrapCol:                            GetWrapCol.               (line 6)
* Go to line:                            Go to line.               (line 6)
* Going to the connected debug state:    Going to the connected debug state.
                                                                   (line 6)
* Going to the ready to run debug state: Going to the ready to run debug state.
                                                                   (line 6)
* Grep:                                  Grep.                     (line 6)
* gstr:                                  gstr.                     (line 6)
* Help:                                  Help.                     (line 6)
* HexMarker:                             HexMarker.                (line 6)
* Hide (Rectangle):                      Hide (Rectangle).         (line 6)
* How can I customize that?:             How can I customize that?.
                                                                   (line 6)
* How should I generate the tags?:       How should I generate the tags?.
                                                                   (line 6)
* How strings are parsed:                How strings are parsed.   (line 6)
* How to configure the keyboard:         How to configure the keyboard.
                                                                   (line 6)
* How to contact me:                     How to contact me.        (line 6)
* How to run setedit remotely without root installation (UNIX): How to run setedit remotely without root installation (UNIX).
                                                                   (line 6)
* How to use Setedit for something it was not meant to: How to use Setedit for something it was not meant to.
                                                                   (line 6)
* How to write a sLisp macro:            How to write a sLisp macro.
                                                                   (line 6)
* HTML Accents:                          HTML Accents.             (line 6)
* if:                                    if.                       (line 6)
* image, display:                        Search files under cursor in.
                                                                   (line 6)
* Import project items:                  Import project items.     (line 6)
* Indent amount:                         Use indent size.          (line 6)
* Indent one space:                      Indent one space.         (line 6)
* Indent one tab or gap:                 Indent one tab or gap.    (line 6)
* Indentation:                           Indentation.              (line 6)
* Index:                                 Index.                    (line 6)
* Index of key commands:                 Index of key commands.    (line 6)
* InfView:                               InfView.                  (line 6)
* Insert and Delete:                     Insert and Delete.        (line 6)
* Insert key name:                       Insert key name.          (line 6)
* Insert new line (do not move):         Insert new line (do not move).
                                                                   (line 6)
* InsertText:                            InsertText.               (line 6)
* Inspectors:                            Inspectors.               (line 6)
* Intelligent indent:                    Intelligent indent.       (line 6)
* intelligent indent configuration:      NLIndent.                 (line 6)
* Introduction:                          Introduction.             (line 6)
* Invisible status bar entries:          Invisible status bar entries.
                                                                   (line 6)
* Jump to function:                      Jump to function.         (line 6)
* Jump to last cursor position:          Jump to last cursor position.
                                                                   (line 6)
* Jump to last undo position:            Jump to last undo position.
                                                                   (line 6)
* Jump to prototype:                     Jump to prototype.        (line 6)
* Jump to symbol:                        Jump to symbol.           (line 6)
* Keep trailing whitespace:              Keep trailing whitespace. (line 6)
* Key assignment:                        Key assignment.           (line 6)
* Key names:                             Key names.                (line 6)
* Key pad behavior:                      Key pad behavior.         (line 6)
* KeyBindings:                           KeyBindings.              (line 6)
* Keyboard:                              Keyboard.                 (line 6)
* Keyboard configuration:                Keyboard configuration.   (line 6)
* keys, names:                           Insert key name.          (line 6)
* Keywords:                              Keywords.                 (line 6)
* Killing the program you are debugging: Killing the program you are debugging.
                                                                   (line 6)
* last cursor position:                  Jump to last cursor position.
                                                                   (line 6)
* last cursor position, alternative:     Jump to last undo position.
                                                                   (line 6)
* left:                                  left.                     (line 6)
* length:                                length.                   (line 6)
* List:                                  List.                     (line 6)
* List of tag files:                     List of tag files.        (line 6)
* loop:                                  loop.                     (line 6)
* Macro:                                 Macro.                    (line 6)
* macros from menu:                      sLisp macros.             (line 6)
* macros.slp:                            Assigning a sLisp macro.  (line 6)
* Match pair highlight:                  Match pair highlight.     (line 6)
* Match pair highlight all the time:     Match pair on the fly.    (line 6)
* Match pair on the fly:                 Match pair on the fly.    (line 6)
* Mechanism used to debug:               Mechanism used to debug.  (line 6)
* menues and macros:                     sLisp macros.             (line 6)
* Menues configuration:                  Menues configuration.     (line 6)
* MenuItem entries:                      MenuItem entries.         (line 6)
* MenuItemC entries:                     MenuItemC entries.        (line 6)
* MenuSeparator:                         MenuSeparator.            (line 6)
* message window:                        Message Window.           (line 6)
* Message Window:                        Message Window.           (line 6)
* message window, options:               Editor General.           (line 6)
* MessageBox:                            MessageBox.               (line 6)
* Messages displayed:                    Messages displayed.       (line 6)
* MIME quoted printable:                 Block quoted printable decode.
                                                                   (line 6)
* Miscellaneous:                         Miscellaneous.            (line 6)
* Miscellaneous keyboard commands:       Miscellaneous keyboard commands.
                                                                   (line 6)
* Mode - Change display mode (DW):       Mode - Change display mode (DW).
                                                                   (line 6)
* Mode - Change radix (DW):              Mode - Change radix (DW). (line 6)
* Mode - Toggle auto follow (DW):        Mode - Toggle auto follow (DW).
                                                                   (line 6)
* Mode - Toggle endian mode (DW):        Mode - Toggle endian mode (DW).
                                                                   (line 6)
* Mouse under Linux:                     Mouse under Linux.        (line 6)
* Move (Rectangle):                      Move (Rectangle).         (line 6)
* Move - Down (DW):                      Move - Down (DW).         (line 6)
* Move - First addr decrement (DW):      Move - First addr decrement (DW).
                                                                   (line 6)
* Move - First addr increment (DW):      Move - First addr increment (DW).
                                                                   (line 6)
* Move - First column (DW):              Move - First column (DW). (line 6)
* Move - First row (DW):                 Move - First row (DW).    (line 6)
* Move - Last column (DW):               Move - Last column (DW).  (line 6)
* Move - Last row (DW):                  Move - Last row (DW).     (line 6)
* Move - Left (DW):                      Move - Left (DW).         (line 6)
* Move - Page down (DW):                 Move - Page down (DW).    (line 6)
* Move - Page up (DW):                   Move - Page up (DW).      (line 6)
* Move - Right (DW):                     Move - Right (DW).        (line 6)
* Move - Up (DW):                        Move - Up (DW).           (line 6)
* MoveAfterPar (action):                 MoveAfterPar (action).    (line 6)
* Movement:                              Cursor movement.          (line 6)
* Name:                                  Name.                     (line 6)
* Name current function:                 Name current function.    (line 6)
* NameMatch:                             NameMatch.                (line 6)
* New:                                   New.                      (line 6)
* newer, files on disk:                  Check for modified files. (line 6)
* Next (Window):                         Next (Window).            (line 6)
* NLIndent:                              NLIndent.                 (line 6)
* No real tabs:                          Tab smart indents.        (line 6)
* NoCheckNumbers:                        NoCheckNumbers.           (line 6)
* NoLastChar (condition):                NoLastChar (condition).   (line 6)
* not:                                   not.                      (line 6)
* Open:                                  Open.                     (line 6)
* Open (Project):                        Open (Project).           (line 6)
* Open Read-only copy:                   Open Read-only copy.      (line 6)
* OpenComment1:                          OpenComment1.             (line 6)
* OpenFile:                              OpenFile.                 (line 6)
* Operator != (different):               Operator != (different).  (line 6)
* Operator & (bitwise and):              Operator & (bitwise and). (line 6)
* Operator + (plus):                     Operator + (plus).        (line 6)
* Operator ++ (increment):               Operator ++ (increment).  (line 6)
* Operator - (decrement):                Operator -- (decrement).  (line 6)
* Operator - (substraction):             Operator - (substraction).
                                                                   (line 6)
* Operator = (assign):                   Operator = (assign).      (line 6)
* Operator == (equal):                   Operator == (equal).      (line 6)
* Operator | (bitwise or):               Operator | (bitwise or).  (line 6)
* Operator ~ (negated):                  Operator ~ (negated).     (line 6)
* Optimal Fill:                          Optimal Fill.             (line 6)
* Options:                               Options.                  (line 6)
* Options (Syntax help):                 Options (Syntax help).    (line 6)
* or:                                    or.                       (line 6)
* Overwrite:                             Overwrite.                (line 6)
* ParBalanceNeg (condition):             ParBalanceNeg (condition).
                                                                   (line 6)
* ParBalancePos (condition):             ParBalancePos (condition).
                                                                   (line 6)
* parse, errors:                         Error messages from an external application.
                                                                   (line 6)
* PartialKeywords:                       PartialKeywords.          (line 6)
* Passing extra command line options:    Passing extra command line options.
                                                                   (line 6)
* Paste:                                 Paste.                    (line 6)
* Paste (Rectangle):                     Paste (Rectangle).        (line 6)
* Paste Emacs mode:                      Paste Emacs mode.         (line 6)
* Paste from clipboard (Rectangle):      Paste from clipboard (Rectangle).
                                                                   (line 6)
* Paste from file Clipboard:             Paste from file Clipboard.
                                                                   (line 6)
* Paste from Windows Clipboard:          Paste from Windows Clipboard.
                                                                   (line 6)
* Paste, do not move the cursor:         Do not move the cursor on Paste.
                                                                   (line 6)
* Path for sources:                      Path for sources.         (line 6)
* pdf, display:                          Search files under cursor in.
                                                                   (line 6)
* Persistent Blocks <1>:                 Persistent Blocks.        (line 6)
* Persistent Blocks:                     Block modes.              (line 6)
* Play (Macro):                          Play (Macro).             (line 6)
* Please enlighten me - what is that?:   Please enlighten me - what is that?.
                                                                   (line 6)
* PMacros:                               PMacros.                  (line 6)
* pmacros, executing sLisp:              Executing sLisp code from a pmacro.
                                                                   (line 6)
* pmacros, user interaction:             Asking for user defined values.
                                                                   (line 6)
* Pop cursor position:                   Pop cursor position.      (line 6)
* Preprocessor:                          Preprocessor.             (line 6)
* Previous (Window):                     Previous (Window).        (line 6)
* prex:                                  prex.                     (line 6)
* Print:                                 Print.                    (line 6)
* Print Setup:                           Print Setup.              (line 6)
* Profile Editor:                        Profile Editor.           (line 6)
* Project:                               Project.                  (line 6)
* project window, vertical:              Editor General.           (line 6)
* project, autosave:                     Editor General.           (line 6)
* Pseudo Macro (menu):                   Pseudo Macro (menu).      (line 6)
* Pseudo Macros:                         Pseudo Macros.            (line 6)
* Pull-down menues:                      Pull-down menues.         (line 6)
* Push cursor position:                  Push cursor position.     (line 6)
* Quick start to debugging:              Quick start to debugging. (line 6)
* Quit:                                  Quit.                     (line 6)
* quoted printable:                      Block quoted printable decode.
                                                                   (line 6)
* Real Tabs:                             Real Tabs.                (line 6)
* Real Tabs when indenting:              Optimal Fill.             (line 6)
* Record (Macro):                        Record (Macro).           (line 6)
* Rectangle:                             Rectangle.                (line 6)
* Rectangular Blocks:                    Rectangular Blocks.       (line 6)
* Redo:                                  Redo.                     (line 6)
* Redraw screen:                         Redraw screen.            (line 6)
* redrawing the screen:                  Redraw screen.            (line 6)
* Regenerate central file:               Regenerate central file.  (line 6)
* Regular Expressions:                   Regular Expressions.      (line 6)
* Regular Expressions Options:           Regular Expressions Options.
                                                                   (line 6)
* RelaxNumberCheck:                      RelaxNumberCheck.         (line 6)
* reloading newer files:                 Check for modified files. (line 6)
* Remap code page:                       Remap code page.          (line 6)
* repeat:                                repeat.                   (line 6)
* Repeat (Macro):                        Repeat (Macro).           (line 6)
* Replace:                               Replace.                  (line 6)
* ReplaceAgain:                          ReplaceAgain.             (line 6)
* ReplaceString:                         ReplaceString.            (line 6)
* Restoring the default keyboard assignments: Restoring the default keyboard assignments.
                                                                   (line 6)
* Resuming the execution of the program: Resuming the execution of the program.
                                                                   (line 6)
* Returning immediatly:                  Returning immediatly.     (line 6)
* right:                                 right.                    (line 6)
* Row cursor:                            Row cursor.               (line 6)
* Run program:                           Run program.              (line 6)
* Run program (which one):               Run program (which one).  (line 6)
* Run selected code:                     Run selected code.        (line 6)
* Running external programs (compilers/filters/others): Running external programs (compilers/filters/others).
                                                                   (line 6)
* Running programs with a macro:         Running programs with a macro.
                                                                   (line 6)
* Running the program to debug:          Running the program to debug.
                                                                   (line 6)
* RunProgram:                            RunProgram.               (line 6)
* RunProgramRedir:                       RunProgramRedir.          (line 6)
* Save:                                  Save.                     (line 6)
* Save (Project):                        Save (Project).           (line 6)
* Save all:                              Save all.                 (line 6)
* Save as:                               Save as.                  (line 6)
* Save as DOS or UNIX:                   Save as DOS or UNIX.      (line 6)
* Save as UNIX or DOS:                   Save as UNIX or DOS.      (line 6)
* Save desktop here:                     Save desktop here.        (line 6)
* Save with same time:                   Save with same time.      (line 6)
* Screen Options:                        Screen Options.           (line 6)
* screen saver:                          Screen Saver.             (line 6)
* Screen Saver:                          Screen Saver.             (line 6)
* screen, redraw:                        Redraw screen.            (line 6)
* Scroll Lock centers:                   Scroll Lock centers.      (line 6)
* SDG:                                   SDG.                      (line 6)
* SDG Options:                           SDG Options.              (line 6)
* Search:                                Search.                   (line 6)
* Search (Syntax help):                  Search (Syntax help).     (line 6)
* Search again:                          Search again.             (line 6)
* Search files under cursor in:          Search files under cursor in.
                                                                   (line 6)
* See Tabs:                              See Tabs.                 (line 6)
* Selecting the thread to debug:         Selecting the thread to debug.
                                                                   (line 6)
* Selecting with the mouse or Shift:     Selecting with the mouse or Shift.
                                                                   (line 6)
* SelectionExists:                       SelectionExists.          (line 6)
* SelectWindowNumber:                    SelectWindowNumber.       (line 6)
* SendCommands:                          SendCommands.             (line 6)
* Set Global:                            Set Global.               (line 6)
* Set Local:                             Set Local.                (line 6)
* SetCursorXY:                           SetCursorXY.              (line 6)
* Setup Alt keys:                        Setup Alt keys.           (line 6)
* setv:                                  setv.                     (line 6)
* Shell:                                 Shell.                    (line 6)
* ShellScript:                           ShellScript.              (line 6)
* ShortFileName:                         ShortFileName.            (line 6)
* ShortString:                           ShortString.              (line 6)
* Show clipboard:                        Show clipboard.           (line 6)
* ShowInMessageWindow:                   ShowInMessageWindow.      (line 6)
* ShowInStatusLine:                      ShowInStatusLine.         (line 6)
* Size/move:                             Size/move.                (line 6)
* slisp code to a key:                   Assigning sLisp code.     (line 6)
* sLisp macros:                          sLisp macros.             (line 6)
* Sorting of the files and directories in the dialog: Sorting of the files and directories in the dialog.
                                                                   (line 6)
* Spaces, purging at the end of line:    Keep trailing whitespace. (line 6)
* Spaces, removing trailing:             Keep trailing whitespace. (line 6)
* SpecialSymbol:                         SpecialSymbol.            (line 6)
* sstr:                                  sstr.                     (line 6)
* Stack window:                          Stack window.             (line 6)
* Start (Rectangle):                     Start (Rectangle).        (line 6)
* state, debug:                          Debugging states.         (line 6)
* Status bar ranges:                     Status bar ranges.        (line 6)
* Step 1 - Building your macro:          Step 1 - Building your macro.
                                                                   (line 6)
* Step 2 - The filter program:           Step 2 - The filter program.
                                                                   (line 6)
* Step 3 - Binding your script to a keystroke: Step 3 - Binding your script to a keystroke.
                                                                   (line 6)
* Step over:                             Step over.                (line 6)
* Stop (Macro):                          Stop (Macro).             (line 6)
* Stopping the program you are debugging: Stopping the program you are debugging.
                                                                   (line 6)
* strcasecmp:                            strcasecmp.               (line 6)
* strcmp:                                strcmp.                   (line 6)
* String1:                               String1.                  (line 6)
* strstr:                                strstr.                   (line 6)
* strxlt:                                strxlt.                   (line 6)
* SubMenu and EndSubMenu:                SubMenu and EndSubMenu.   (line 6)
* substr:                                substr.                   (line 6)
* Supported debug targets:               Supported debug targets.  (line 6)
* Supported platforms for debugging:     Supported platforms for debugging.
                                                                   (line 6)
* symbols, jump to:                      Jump to symbol.           (line 6)
* Symbols1:                              Symbols1.                 (line 6)
* Symbols2:                              Symbols2.                 (line 6)
* Syntax help:                           Syntax help.              (line 6)
* syntax highlight, default user words:  UserKeywords.             (line 6)
* syntax highlight, defining user words: User Words.               (line 6)
* syntax highlight, paste mode:          Paste Emacs mode.         (line 6)
* Syntax Highlighting:                   Syntax Highlighting.      (line 6)
* syntax highlighting extensions:        Syntax Highlighting.      (line 6)
* Syntax Highlighting File:              Syntax Highlighting File. (line 6)
* syntax highlighting, Emacs modes:      EmacsModes.               (line 6)
* syntax highlighting, extensions:       Files.                    (line 6)
* syntax highlighting, matching a name:  NameMatch.                (line 6)
* syntax highlighting, matching a path:  FullNameMatch.            (line 6)
* syntax highlighting, shell scripts:    ShellScript.              (line 6)
* Tab as spaces:                         Tab smart indents.        (line 6)
* Tab smart indents:                     Tab smart indents.        (line 6)
* TABs:                                  Real Tabs.                (line 6)
* TABs as spaces:                        Use indent size.          (line 6)
* TABs, highlight/see:                   See Tabs.                 (line 6)
* TABs, indenting with:                  Optimal Fill.             (line 6)
* TABs, skipping/through:                Do not move inside tabs.  (line 6)
* Tag files options:                     Tag files options.        (line 6)
* TAGS files:                            TAGS files.               (line 6)
* tags, easy way:                        What is the easiest way to use tags?.
                                                                   (line 6)
* tags, how to generate:                 How should I generate the tags?.
                                                                   (line 6)
* tags, how to maintain:                 Can these files be created and updated by the editor?.
                                                                   (line 6)
* tags, jump to tag:                     Jump to symbol.           (line 6)
* tags, list of files:                   List of tag files.        (line 6)
* tags, program to generate:             Which program is used to generate TAGS files?.
                                                                   (line 6)
* tags, what are?:                       What are tags?.           (line 6)
* tcedit.dst, do not create:             Editor General.           (line 6)
* tcedit.dst, style:                     Editor General.           (line 6)
* Technical details about tags:          Technical details about tags.
                                                                   (line 6)
* Text mode attributes:                  Text mode attributes.     (line 6)
* The special submenu used for the right click: The special submenu used for the right click.
                                                                   (line 6)
* Things to get help or find some definition: Things to get help or find some definition.
                                                                   (line 6)
* Tile:                                  Tile.                     (line 6)
* Time and date modifiers formats:       Time and date modifiers formats.
                                                                   (line 6)
* Tip of the day:                        Tip of the day.           (line 6)
* To lower (Rectangle):                  To lower (Rectangle).     (line 6)
* To upper (Rectangle):                  To upper (Rectangle).     (line 6)
* Tool&Ops:                              Tool&Ops.                 (line 6)
* tostr:                                 tostr.                    (line 6)
* Trace into:                            Trace into.               (line 6)
* Transparent Blocks:                    Transparent Blocks.       (line 6)
* Un/Indent block:                       Un/Indent block.          (line 6)
* Undo:                                  Undo.                     (line 6)
* Unindent (action):                     Unindent (action).        (line 6)
* Unindent one character:                Unindent one character.   (line 6)
* Unindent one tab or gap:               Unindent one tab or gap.  (line 6)
* Unindenting with backspace:            Backspace unindents.      (line 6)
* Use indent size:                       Use indent size.          (line 6)
* Use Real Tabs:                         Real Tabs.                (line 6)
* UseInternal:                           UseInternal.              (line 6)
* User Screen:                           User Screen.              (line 6)
* User Words:                            User Words.               (line 6)
* UserKeywords:                          UserKeywords.             (line 6)
* Using the mouse:                       Using the mouse.          (line 6)
* Using the Shift key:                   Using the Shift key.      (line 6)
* variables, jump to:                    Jump to symbol.           (line 6)
* Various - Less bytes per line (DW):    Various - Less bytes per line (DW).
                                                                   (line 6)
* Various - More bytes per line (DW):    Various - More bytes per line (DW).
                                                                   (line 6)
* Various - Update memory (DW):          Various - Update memory (DW).
                                                                   (line 6)
* VHDLNumbers:                           VHDLNumbers.              (line 6)
* VHDLStr1:                              VHDLStr1.                 (line 6)
* VHDLStr2:                              VHDLStr2.                 (line 6)
* Visible status bar entries:            Visible status bar entries.
                                                                   (line 6)
* Watch an expression:                   Watch an expression.      (line 6)
* Watch an expression with scope:        Watch an expression with scope.
                                                                   (line 6)
* watches:                               Watch an expression.      (line 6)
* watches w/scope:                       Watch an expression with scope.
                                                                   (line 6)
* Watchpoints:                           Watchpoints.              (line 6)
* What are tags?:                        What are tags?.           (line 6)
* What can be configured to change the look of the editor: What can be configured to change the look of the editor.
                                                                   (line 6)
* What can be configured to change the syntax highlighting: What can be configured to change the syntax highlighting.
                                                                   (line 6)
* What can be configured to make easier the operation: What can be configured to make easier the operation.
                                                                   (line 6)
* What can I do with tags?:              What can I do with tags?. (line 6)
* What is SETs Editor?:                  What is SETs Editor?.     (line 6)
* What is the easiest way to use tags?:  What is the easiest way to use tags?.
                                                                   (line 6)
* Which program is used to generate TAGS files?: Which program is used to generate TAGS files?.
                                                                   (line 6)
* WhichEditor:                           WhichEditor.              (line 6)
* Windows:                               Windows.                  (line 6)
* windows, message:                      Message Window.           (line 6)
* Word completion:                       Word completion.          (line 6)
* WordUnderCursor:                       WordUnderCursor.          (line 6)
* Wrap Words:                            Wrap Words.               (line 6)
* wrapping:                              Wrap Words.               (line 6)
* Writing macros that use text filters:  Writing macros that use text filters.
                                                                   (line 6)
* Zoom:                                  Zoom.                     (line 6)


File: editor.inf,  Node: Index of key commands,  Prev: Index,  Up: Top

17 Index of key commands
************************

 [index ]
* Menu:

* 0x0003 <9 x 16>:                       Screen Options.         (line  49)
* 0x0103 <9 x 14>:                       Screen Options.         (line  53)
* 0x0108 <9 x  8>:                       Screen Options.         (line  81)
* 0x0109 <9 x 14>:                       Screen Options.         (line 105)
* 0x010A <9 x 11>:                       Screen Options.         (line 109)
* 0x010B <9 x 10>:                       Screen Options.         (line 113)
* 0x010C <9 x  8>:                       Screen Options.         (line 117)
* 0x0203 <9 x 10>:                       Screen Options.         (line  65)
* 0x0303 <9 x 10>:                       Screen Options.         (line  69)
* 0x0403 <9 x  8>:                       Screen Options.         (line  73)
* 0x0503 <9 x  8>:                       Screen Options.         (line  77)
* 0x0703 <9 x 16>:                       Screen Options.         (line  57)
* 0x0803 <9 x 14>:                       Screen Options.         (line  61)
* 0x0903 <9 x 16>:                       Screen Options.         (line  89)
* 0x0A03 <9 x 14>:                       Screen Options.         (line  93)
* 0x0B03 <9 x 16>:                       Screen Options.         (line  97)
* 0x0C03 <9 x 14>:                       Screen Options.         (line 101)
* 0x0D03 <8 x 16>:                       Screen Options.         (line  85)
* 132 x 25 <9 x 14>:                     Screen Options.         (line 105)
* 132 x 43 <9 x 11>:                     Screen Options.         (line 109)
* 132 x 50 <9 x 10>:                     Screen Options.         (line 113)
* 132 x 60 <9 x  8>:                     Screen Options.         (line 117)
* 80 x 25 <9 x 16>:                      Screen Options.         (line  49)
* 80 x 28 <9 x 14>:                      Screen Options.         (line  53)
* 80 x 30 <9 x 16>:                      Screen Options.         (line  57)
* 80 x 34 <9 x 14>:                      Screen Options.         (line  61)
* 80 x 35 <9 x 10>:                      Screen Options.         (line  65)
* 80 x 40 <9 x 10>:                      Screen Options.         (line  69)
* 80 x 43 <9 x  8>:                      Screen Options.         (line  73)
* 80 x 50 <9 x  8>:                      Screen Options.         (line  77)
* 80 x 60 <9 x  8>:                      Screen Options.         (line  81)
* 82 x 25 <8 x 16>:                      Screen Options.         (line  85)
* 90 x 30 <9 x 16>:                      Screen Options.         (line  89)
* 90 x 34 <9 x 14>:                      Screen Options.         (line  93)
* 94 x 30 <9 x 16>:                      Screen Options.         (line  97)
* 94 x 34 <9 x 14>:                      Screen Options.         (line 101)
* Alternate case <none>:                 Blocks.                 (line 109)
* Autoindent mode on/off <^O>:           Miscellaneous keyboard commands.
                                                                 (line  10)
* Beginning of line <Home>:              Cursor movement.        (line  66)
* Bottom of file <^Q-C>:                 Cursor movement.        (line  91)
* Bottom of window <^Q-X>:               Cursor movement.        (line  81)
* Character left <Left arrow>:           Cursor movement.        (line  11)
* Character right <Right arrow>:         Cursor movement.        (line  16)
* cmcAltCase <From menu>:                Block alternate.        (line  12)
* cmcAltCase <none>:                     Blocks.                 (line 109)
* cmcArbitraryIndent <From menu>:        Arbitrary indent.       (line  11)
* cmcBackSpace <Backspace>:              Insert and Delete.      (line  16)
* cmcCharLeft <Left arrow>:              Cursor movement.        (line  11)
* cmcCharRight <Right arrow>:            Cursor movement.        (line  16)
* cmcChooseMacro <From menu>:            Choose (Macro).         (line  13)
* cmcChoosePMacrosList <From menu>:      Pseudo Macro (menu).    (line  16)
* cmcClear <^Del> <1>:                   Clear.                  (line  11)
* cmcClear <^Del>:                       Blocks.                 (line  69)
* cmcCommentIndent <From menu>:          Comment indent.         (line  16)
* cmcCommentUnIndent <From menu>:        Comment unindent.       (line  20)
* cmcCompactBuffer <From menu> <1>:      Compact text.           (line  13)
* cmcCompactBuffer <From menu>:          Miscellaneous keyboard commands.
                                                                 (line  74)
* cmcCopy <^Ins> <1>:                    Copy.                   (line  11)
* cmcCopy <^Ins>:                        Blocks.                 (line  64)
* cmcCopyBlock <^K-C>:                   Blocks.                 (line  54)
* cmcCopyClipFile <From menu>:           Copy to file Clipboard. (line  13)
* cmcCopyClipWin <From menu>:            Copy to Windows Clipboard.
                                                                 (line  16)
* cmcCut <^K-Y>:                         Blocks.                 (line  49)
* cmcCut <Shift+Del>:                    Cut.                    (line  12)
* cmcCutClipWin <From menu>:             Copy to Windows Clipboard.
                                                                 (line  18)
* cmcDelChar <Del>:                      Insert and Delete.      (line  11)
* cmcDelEnd <^Q-Y>:                      Insert and Delete.      (line  26)
* cmcDelLine <^Y>:                       Insert and Delete.      (line  21)
* cmcDelPrevWord <^Backspace>:           Insert and Delete.      (line  41)
* cmcDelStart <^Q-H>:                    Insert and Delete.      (line  31)
* cmcDelWord <^T>:                       Insert and Delete.      (line  36)
* cmcEndSelect <^K-K>:                   Blocks.                 (line  29)
* cmcExpandAllTabs <From menu> <1>:      Expand all tabs.        (line  13)
* cmcExpandAllTabs <From menu>:          Miscellaneous keyboard commands.
                                                                 (line  70)
* cmcExpandCode <^Space>:                Miscellaneous keyboard commands.
                                                                 (line  54)
* cmcFind <^Q-F>:                        Find.                   (line  61)
* cmcFirstLineInScreen <^Q-E>:           Cursor movement.        (line  76)
* cmcGenCodeForMacro <From menu>:        Generate Code.          (line  15)
* cmcGoBeginBlock <^Q-B>:                Blocks.                 (line  14)
* cmcGoEndBlock <^Q-K>:                  Blocks.                 (line  19)
* cmcGoEndOfWord <>:                     Cursor movement.        (line  31)
* cmcGotoEditorLine <^J> <1>:            Go to line.             (line  11)
* cmcGotoEditorLine <^J>:                Miscellaneous keyboard commands.
                                                                 (line  58)
* cmcGotoMarkn <^Q n*>:                  Miscellaneous keyboard commands.
                                                                 (line  14)
* cmcHideSelect <^K-H>:                  Blocks.                 (line  34)
* cmcIndentBlk <^K-Tab>:                 Indentation.            (line  27)
* cmcIndentBlk <From menu>:              Indent one tab or gap.  (line  11)
* cmcIndentBlkOne <^K-I>:                Indentation.            (line  17)
* cmcIndentBlkOne <From menu>:           Indent one space.       (line  10)
* cmcIndentMode <^O>:                    Miscellaneous keyboard commands.
                                                                 (line  10)
* cmcInsertKeyName <From menu>:          Insert key name.        (line  13)
* cmcInsertNewLine <Ctrl+N>:             Insert new line (do not move).
                                                                 (line  13)
* cmcInsMode <Ins>:                      Insert and Delete.      (line  56)
* cmcInvertCase <From menu>:             Block invert.           (line  10)
* cmcInvertCase <none>:                  Blocks.                 (line 104)
* cmcJumpLastCursorPos <Ctrl+Q-P>:       Jump to last cursor position.
                                                                 (line  12)
* cmcJumpToFunction <Alt+F2>:            Jump to function.       (line  71)
* cmcJumpToPrototype <From menu>:        Jump to prototype.      (line  14)
* cmcLastLineInScreen <^Q-X>:            Cursor movement.        (line  81)
* cmcLastPosCur <From menu>:             Jump to last undo position.
                                                                 (line  11)
* cmcLineDown <Down arrow>:              Cursor movement.        (line  41)
* cmcLineEnd <End>:                      Cursor movement.        (line  71)
* cmcLineStart <Home>:                   Cursor movement.        (line  66)
* cmcLineUp <Up arrow>:                  Cursor movement.        (line  36)
* cmcMarkLine <^K-L>:                    Blocks.                 (line  39)
* cmcMarkWord <^K-T>:                    Blocks.                 (line  44)
* cmcMoveBlock <^K+V>:                   Blocks.                 (line  59)
* cmcNewLine <Enter>:                    Insert and Delete.      (line  46)
* cmcPageDown <PgDn>:                    Cursor movement.        (line  61)
* cmcPageUp <PgUp>:                      Cursor movement.        (line  56)
* cmcPaste <Shift+Ins> <1>:              Paste.                  (line  12)
* cmcPaste <Shift+Ins>:                  Blocks.                 (line  74)
* cmcPasteClipFile <From menu>:          Paste from file Clipboard.
                                                                 (line  13)
* cmcPasteClipWin <From menu>:           Paste from Windows Clipboard.
                                                                 (line  13)
* cmcPasteEmacsMode <From menu>:         Paste Emacs mode.       (line  17)
* cmcPlayMacro <^F10> <1>:               Play (Macro).           (line  12)
* cmcPlayMacro <^F10>:                   Miscellaneous keyboard commands.
                                                                 (line  86)
* cmcPopCursorPos <From menu>:           Pop cursor position.    (line  13)
* cmcProfileEditor <From menu>:          Profile Editor.         (line  11)
* cmcPushCursorPos <From menu>:          Push cursor position.   (line  12)
* cmcPutMarkn <^K n*>:                   Miscellaneous keyboard commands.
                                                                 (line  18)
* cmcQuotedPrintDecode <From menu>:      Block quoted printable decode.
                                                                 (line  13)
* cmcReadBlock <^K-R>:                   Blocks.                 (line  79)
* cmcRecordMacro <Shift+F10> <1>:        Record (Macro).         (line  11)
* cmcRecordMacro <Shift+F10>:            Miscellaneous keyboard commands.
                                                                 (line  78)
* cmcRedo <From menu>:                   Redo.                   (line  10)
* cmcRepeatMacro <Shift+F3>:             Repeat (Macro).         (line  14)
* cmcReplace <^Q-A>:                     Replace.                (line  22)
* cmcReplaceSelect <Shift+^Ins>:         Blocks.                 (line  89)
* cmcRunEnter_sLisp <From menu>:         Enter code to run.      (line  11)
* cmcRunSel_sLisp <From menu>:           Run selected code.      (line  10)
* cmcSave <F2>:                          Save.                   (line  15)
* cmcSaveAll <From menu>:                Save all.               (line  10)
* cmcSaveAs <From menu>:                 Save as.                (line  17)
* cmcSaveAsConvertEOL <From menu>:       Save as UNIX or DOS.    (line  18)
* cmcSaveAsNoConvertEOL <From menu>:     Save as DOS or UNIX.    (line  14)
* cmcSaveSameTime <From menu>:           Save with same time.    (line  14)
* cmcScrollDown <^Z>:                    Cursor movement.        (line  51)
* cmcScrollUp <^W>:                      Cursor movement.        (line  46)
* cmcSearchAgain <^L>:                   Search again.           (line  11)
* cmcSearchClCor <Shift+^]>:             Miscellaneous keyboard commands.
                                                                 (line  42)
* cmcSearchClPar <Shift+^0>:             Miscellaneous keyboard commands.
                                                                 (line  34)
* cmcSearchComplement <^Q ESC>:          Miscellaneous keyboard commands.
                                                                 (line  46)
* cmcSearchEnd <^]>:                     Miscellaneous keyboard commands.
                                                                 (line  26)
* cmcSearchOpCor <Shift+^[>:             Miscellaneous keyboard commands.
                                                                 (line  38)
* cmcSearchOpPar <Shift+^9>:             Miscellaneous keyboard commands.
                                                                 (line  30)
* cmcSearchStart <^[>:                   Miscellaneous keyboard commands.
                                                                 (line  22)
* cmcSelLength <^Q-L>:                   Blocks.                 (line 114)
* cmcSelRectClear <^K-Shift+E> <1>:      Clear (Rectangle).      (line  13)
* cmcSelRectClear <^K-Shift+E>:          Rectangular Blocks.     (line  56)
* cmcSelRectCopy <^K-Shift+C> <1>:       Copy (Rectangle).       (line  15)
* cmcSelRectCopy <^K-Shift+C>:           Rectangular Blocks.     (line  40)
* cmcSelRectCopyClip <^K-Ctrl+Insert>:   Copy to clipboard (Rectangle).
                                                                 (line  13)
* cmcSelRectCopyPaste <^K-Shift+O> <1>:  Copy and Paste (Rectangle).
                                                                 (line  15)
* cmcSelRectCopyPaste <^K-Shift+O>:      Rectangular Blocks.     (line  52)
* cmcSelRectCut <^K-Shift+T>:            Cut (Rectangle).        (line  14)
* cmcSelRectCut <^K-ShiftT>:             Rectangular Blocks.     (line  32)
* cmcSelRectDel <^K-Shift+L> <1>:        Delete (Rectangle).     (line  13)
* cmcSelRectDel <^K-Shift+L>:            Rectangular Blocks.     (line  44)
* cmcSelRectEnd <^K-Shift+K> <1>:        End (Rectangle).        (line  13)
* cmcSelRectEnd <^K-Shift+K>:            Rectangular Blocks.     (line  24)
* cmcSelRectHide <^K-Shift+H> <1>:       Hide (Rectangle).       (line  13)
* cmcSelRectHide <^K-Shift+H>:           Rectangular Blocks.     (line  28)
* cmcSelRectMove <^K+Shift+V>:           Rectangular Blocks.     (line  36)
* cmcSelRectMove <^K-Shift+M>:           Move (Rectangle).       (line  13)
* cmcSelRectPaste <^K-Shift+P> <1>:      Paste (Rectangle).      (line  13)
* cmcSelRectPaste <^K-Shift+P>:          Rectangular Blocks.     (line  48)
* cmcSelRectPasteClip <^K-Shift+Insert>: Paste from clipboard (Rectangle).
                                                                 (line  15)
* cmcSelRectStart <^K-Shift+B> <1>:      Start (Rectangle).      (line  13)
* cmcSelRectStart <^K-Shift+B>:          Rectangular Blocks.     (line  20)
* cmcSelRectToLower <>:                  Rectangular Blocks.     (line  64)
* cmcSelRectToLower <From menu>:         To lower (Rectangle).   (line  16)
* cmcSelRectToUpper <>:                  Rectangular Blocks.     (line  60)
* cmcSelRectToUpper <From menu>:         To upper (Rectangle).   (line  16)
* cmcSetGlobalOptions <Alt+G> <1>:       Set Global.             (line  21)
* cmcSetGlobalOptions <Alt+G>:           Miscellaneous keyboard commands.
                                                                 (line  66)
* cmcSetLocalOptions <Alt+L> <1>:        Set Local.              (line  21)
* cmcSetLocalOptions <Alt+L>:            Miscellaneous keyboard commands.
                                                                 (line  62)
* cmcSmartIndent <^Tab>:                 Indentation.            (line  53)
* cmcSmartTab <Tab>:                     Insert and Delete.      (line  51)
* cmcSmartUnIndent <Shift+^Tab>:         Indentation.            (line  57)
* cmcStartSelect <^K-B>:                 Blocks.                 (line  24)
* cmcStopMacro <Alt+F10> <1>:            Stop (Macro).           (line  11)
* cmcStopMacro <Alt+F10>:                Miscellaneous keyboard commands.
                                                                 (line  82)
* cmcTextEnd <^Q-C>:                     Cursor movement.        (line  91)
* cmcTextStart <^Q-R>:                   Cursor movement.        (line  86)
* cmcToggleCharCase <From menu>:         Character toggle.       (line  11)
* cmcToLower <^K-O>:                     Blocks.                 (line  99)
* cmcToLower <From menu>:                Block to lower.         (line  10)
* cmcToUpper <^K-M>:                     Blocks.                 (line  94)
* cmcToUpper <From menu>:                Block to upper.         (line  10)
* cmcUndo <Alt+BackSpace>:               Undo.                   (line  12)
* cmcUndo <Alt+Backspace>:               Miscellaneous keyboard commands.
                                                                 (line  50)
* cmcUnIndentBlk <^K-Shift+Tab>:         Indentation.            (line  32)
* cmcUnIndentBlk <From menu>:            Unindent one tab or gap.
                                                                 (line  11)
* cmcUnIndentBlkOne <^K-U>:              Indentation.            (line  22)
* cmcUnIndentBlkOne <From menu>:         Unindent one character. (line  10)
* cmcWhichFunctionIs <>:                 Name current function.  (line  13)
* cmcWordLeft <^Left arrow>:             Cursor movement.        (line  21)
* cmcWordRight <^Right arrow>:           Cursor movement.        (line  26)
* cmcWriteBlock <^K-W>:                  Blocks.                 (line  84)
* cmDWBaseAddress <Ctrl+B>:              Address - Change base address (DW).
                                                                 (line  14)
* cmDWBaseDecrement <Ctrl+<->:           Move - First addr decrement (DW).
                                                                 (line  13)
* cmDWBaseIncrement <Ctrl+->>:           Move - First addr increment (DW).
                                                                 (line  13)
* cmDWClear <Ctrl+L>:                    Block - Clear (DW).     (line  15)
* cmDWDispMode <Ctrl+D>:                 Mode - Change display mode (DW).
                                                                 (line  23)
* cmDWDown <Cursor down>:                Move - Down (DW).       (line  16)
* cmDWFill <Ctrl+I>:                     Block - Fill (DW).      (line  16)
* cmDWFirstColumn <Home>:                Move - First column (DW).
                                                                 (line  11)
* cmDWFirstRow <Ctrl+Home>:              Move - First row (DW).  (line  11)
* cmDWFollowPointer <Ctrl+F>:            Address - Follow pointer (DW).
                                                                 (line  12)
* cmDWFollowPtnNew <Ctrl+O>:             Address - Follow pointer in new window (DW).
                                                                 (line  13)
* cmDWGotoAddress <Ctrl+G>:              Address - Go to new address (DW).
                                                                 (line  13)
* cmDWLastColumn <End>:                  Move - Last column (DW).
                                                                 (line  11)
* cmDWLastRow <Ctrl+End>:                Move - Last row (DW).   (line  11)
* cmDWLeft <<->:                         Move - Left (DW).       (line  12)
* cmDWLessLines <->:                     Various - Less bytes per line (DW).
                                                                 (line  13)
* cmDWMoreLines <+>:                     Various - More bytes per line (DW).
                                                                 (line  13)
* cmDWMove <Ctrl+M>:                     Block - Move (DW).      (line  16)
* cmDWPgDn <Page Down>:                  Move - Page down (DW).  (line  14)
* cmDWPgUp <Page Up>:                    Move - Page up (DW).    (line  14)
* cmDWRadix <Ctrl+X>:                    Mode - Change radix (DW).
                                                                 (line  15)
* cmDWRead <Ctrl+R>:                     File - Read block (DW). (line  17)
* cmDWRecompute <Ctrl+H>:                Address - Recompute address (DW).
                                                                 (line  13)
* cmDWRight <->>:                        Move - Right (DW).      (line  12)
* cmDWTogAutoF <Ctrl+A>:                 Mode - Toggle auto follow (DW).
                                                                 (line  16)
* cmDWTogEndian <Ctrl+E>:                Mode - Toggle endian mode (DW).
                                                                 (line  16)
* cmDWUp <Cursor up>:                    Move - Up (DW).         (line  16)
* cmDWUpdateMemory <Enter>:              Various - Update memory (DW).
                                                                 (line  11)
* cmDWWrite <Ctrl+W>:                    File - Write block (DW).
                                                                 (line  16)
* cmeAdviceDiagConf <From menu>:         Advice dialogs.         (line  16)
* cmeAnotherInfView <From menu>:         Another InfView.        (line  15)
* cmeBreakpoint <Ctrl+F8>:               Breakpoints.            (line  26)
* cmeCalculator <Alt+F4>:                Calculator (command/menu).
                                                                 (line  11)
* cmeCascade <From menu>:                Cascade.                (line  10)
* cmeClassBrowser <From menu>:           Class browser.          (line  42)
* cmeClose <Alt+F3>:                     Close.                  (line  12)
* cmeClosePrj <From menu>:               Close (Project).        (line  10)
* cmeColorTheme <From menu>:             Color Theme.            (line  13)
* cmeConfRunCommand <From menu>:         Run program (which one).
                                                                 (line 107)
* cmeDbgCallStack <Ctrl+F3>:             Examining the calling stack.
                                                                 (line  23)
* cmeDbgCleanElem <From menu>:           Cleaning the debug session.
                                                                 (line  27)
* cmeDbgCloseSession <From menu>:        Closing the debug session.
                                                                 (line  17)
* cmeDbgDataWindow <From menu>:          Data Window.            (line  32)
* cmeDbgDetach <From menu>:              Debugging already running processes.
                                                                 (line  38)
* cmeDbgDisAsmWin <From menu>:           Disassembler Window.    (line  46)
* cmeDbgEditBreakPts <From menu>:        Advanced breakpoint options.
                                                                 (line  67)
* cmeDbgEditWatchPts <From menu>:        Watchpoints.            (line  55)
* cmeDbgEndSession <From menu>:          Destroying the debug session.
                                                                 (line  18)
* cmeDbgEvalModify <Ctrl+F4>:            Evaluate or Modify expression.
                                                                 (line  31)
* cmeDbgFinishFun <From menu>:           Executing until return. (line  15)
* cmeDbgGoConnected <From menu>:         Going to the connected debug state.
                                                                 (line  18)
* cmeDbgGoReadyToRun <From menu>:        Going to the ready to run debug state.
                                                                 (line  20)
* cmeDbgGoToCursor <F4>:                 Executing until cursor position is reached.
                                                                 (line  14)
* cmeDbgInspector <Ctrl+F6>:             Inspectors.             (line  49)
* cmeDbgKill <From menu>:                Killing the program you are debugging.
                                                                 (line  15)
* cmeDbgOptionsAdv <From menu>:          Advanced debug options. (line  56)
* cmeDbgOptsMsgs <From menu>:            Messages displayed.     (line  36)
* cmeDbgReturnNow <From menu>:           Returning immediatly.   (line  15)
* cmeDbgRunContinue <Shift+F9> <1>:      Continue execution.     (line  15)
* cmeDbgRunContinue <Shift+F9>:          Running the program to debug.
                                                                 (line  27)
* cmeDbgStackWindow <From menu>:         Stack window.           (line  18)
* cmeDbgStepOver <F8>:                   Step over.              (line  17)
* cmeDbgStop <From menu>:                Stopping the program you are debugging.
                                                                 (line  15)
* cmeDbgThreadSel <From menu>:           Selecting the thread to debug.
                                                                 (line  22)
* cmeDbgTraceInto <F7>:                  Trace into.             (line  18)
* cmeDbgWatchExpNorm <Ctrl+F7>:          Watch an expression.    (line  22)
* cmeDbgWatchExpScp <From menu>:         Watch an expression with scope.
                                                                 (line  26)
* cmeDebugOptions <From menu>:           Debug options.          (line  44)
* cmeDeleteBkps <From menu>:             Delete memorized backups.
                                                                 (line  14)
* cmeDosShell <From menu>:               Shell.                  (line  12)
* cmeEdGralOptions <From menu>:          Editor General.         (line 153)
* cmeEditDeflOpts <From menu>:           Default global edition. (line  70)
* cmeEditKeyBind <From menu>:            Key assignment.         (line  15)
* cmeEditNoBkp <From menu>:              Do not create backups for.
                                                                 (line  27)
* cmeEditPalette <From menu>:            Color Palette.          (line  24)
* cmeEditUserWords <From menu>:          User Words.             (line  31)
* cmeEncodings <From menu>:              Encodings.              (line  66)
* cmeExportAsHTML <From menu>:           Export as HTML.         (line  33)
* cmeExportPrj <From menu>:              Export project.         (line  11)
* cmeFileOpenOptions <From menu>:        File open dialog.       (line  11)
* cmeFonts <From menu>:                  Fonts.                  (line  32)
* cmeGrepDialog <From menu>:             Grep.                   (line  64)
* cmeHolidaysConf <From menu>:           Calendar options.       (line  28)
* cmeHTMLAccents <From menu>:            Convert accents to tags.
                                                                 (line  13)
* cmeHTMLTag2Accent <From menu>:         Convert tags to accents.
                                                                 (line  12)
* cmeImportPrj <From menu>:              Import project items.   (line  17)
* cmeIncludeList <From menu>:            Search files under cursor in.
                                                                 (line  35)
* cmeInfView <F1>:                       InfView.                (line  11)
* cmeKbBackDefault <From menu>:          Back to defaults.       (line  12)
* cmeKeyPadBehavior <From menu>:         Key pad behavior.       (line  16)
* cmeListWin <Alt+0>:                    List.                   (line  34)
* cmeNew <From menu>:                    New.                    (line  16)
* cmeNext <F6>:                          Next (Window).          (line  17)
* cmeOpen <F3>:                          Open.                   (line  20)
* cmeOpenPrj <From menu>:                Open (Project).         (line  11)
* cmeOpenROCopy <From menu>:             Open Read-only copy.    (line  17)
* cmePrev <Shift+F6>:                    Previous (Window).      (line  17)
* cmePrintEditor <From menu>:            Print.                  (line  22)
* cmeQuit <Alt+X>:                       Exit.                   (line  13)
* cmeQuitDelete <Alt+Q>:                 Quit.                   (line  17)
* cmeReDraw <From menu>:                 Redraw screen.          (line  11)
* cmeRemapCodePage <From menu>:          Remap code page.        (line  26)
* cmeResize <^F5>:                       Size/move.              (line  20)
* cmeRunCommand <Ctrl+F9>:               Run program.            (line  12)
* cmeSaveDesktop <From menu>:            Save desktop here.      (line  12)
* cmeSavePrj <From menu>:                Save (Project).         (line  11)
* cmeScreenSaverOpts <From menu>:        Screen Saver.           (line  33)
* cmeSDG <F9>:                           SDG.                    (line  13)
* cmeSDGDialog <From menu>:              SDG Options.            (line  30)
* cmeSearchTag <Ctrl+F2>:                Jump to symbol.         (line  19)
* cmeSeeScanCodes <From menu>:           Consult scan codes.     (line  13)
* cmeSetColors <From menu>:              Customize Colors.       (line  33)
* cmeSetModiCkOps <From menu>:           Check for modified files.
                                                                 (line  66)
* cmeSetScreenOps <From menu>:           Screen Options.         (line 120)
* cmeSetUpAltKeys <From menu>:           Setup Alt keys.         (line  11)
* cmeSetUpPrinter <From menu>:           Print Setup.            (line  64)
* cmeShowClip <From menu>:               Show clipboard.         (line  10)
* cmeSourceList <From menu>:             Path for sources.       (line  32)
* cmeSyntaxHelp <^F1>:                   Search (Syntax help).   (line  12)
* cmeSyntaxHelpFiles <From menu>:        Files to search (Syntax help).
                                                                 (line  26)
* cmeSyntaxHelpOps <From menu>:          Options (Syntax help).  (line  35)
* cmeTagFiles <From menu>:               List of tag files.      (line  23)
* cmeTagsAutoRegen <From menu>:          Regenerate central file.
                                                                 (line  13)
* cmeTagsOps <From menu>:                Tag files options.      (line  31)
* cmeTile <From menu>:                   Tile.                   (line  10)
* cmeTipOfTheDay <From menu>:            Tip of the day.         (line  28)
* cmeUserScreen <Alt+F5>:                User Screen.            (line  11)
* cmeWordCompletion <Alt+Right>:         Word completion.        (line  22)
* cmeZoom <F5>:                          Zoom.                   (line  14)
* Compact the text using tabs <From menu>: Miscellaneous keyboard commands.
                                                                 (line  74)
* Convert all tabs to spaces <From menu>: Miscellaneous keyboard commands.
                                                                 (line  70)
* Convert to lowercase <>:               Rectangular Blocks.     (line  64)
* Convert to Lowercase <^K-O>:           Blocks.                 (line  99)
* Convert to uppercase <>:               Rectangular Blocks.     (line  60)
* Convert to Uppercase <^K-M>:           Blocks.                 (line  94)
* Copy and Paste in one operation <^K-Shift+O>: Rectangular Blocks.
                                                                 (line  52)
* Copy the selected block <^K-C>:        Blocks.                 (line  54)
* Copy to Clipboard <^Ins>:              Blocks.                 (line  64)
* Copy to special Clipboard <^K-Shift+C>: Rectangular Blocks.    (line  40)
* Delete block <^Del>:                   Blocks.                 (line  69)
* Delete block <^K-Shift+L>:             Rectangular Blocks.     (line  44)
* Delete block and copy it to an special Clipboard <^K-ShiftT>: Rectangular Blocks.
                                                                 (line  32)
* Delete block and copy it to the Clipboard <^K-Y>: Blocks.      (line  49)
* Delete character to left <Backspace>:  Insert and Delete.      (line  16)
* Delete line <^Y>:                      Insert and Delete.      (line  21)
* Delete the character under cursor <Del>: Insert and Delete.    (line  11)
* Delete to end of line <^Q-Y>:          Insert and Delete.      (line  26)
* Delete to start of line <^Q-H>:        Insert and Delete.      (line  31)
* Delete word at left <^Backspace>:      Insert and Delete.      (line  41)
* Delete word at right <^T>:             Insert and Delete.      (line  36)
* End of line <End>:                     Cursor movement.        (line  71)
* End of the word <>:                    Cursor movement.        (line  31)
* Find place marker <^Q n*>:             Miscellaneous keyboard commands.
                                                                 (line  14)
* Goto Line <^J>:                        Miscellaneous keyboard commands.
                                                                 (line  58)
* Hide/Show block <^K-H>:                Blocks.                 (line  34)
* Hide/Show block <^K-Shift+H>:          Rectangular Blocks.     (line  28)
* Indent block <^K-Tab>:                 Indentation.            (line  27)
* Indent block one position adding a space <^K-I>: Indentation.  (line  17)
* Insert line <Enter>:                   Insert and Delete.      (line  46)
* Insert mode on/off <Ins>:              Insert and Delete.      (line  56)
* Invert case <none>:                    Blocks.                 (line 104)
* Line down <Down arrow>:                Cursor movement.        (line  41)
* Line up <Up arrow>:                    Cursor movement.        (line  36)
* Mark line <^K-L>:                      Blocks.                 (line  39)
* Mark word <^K-T>:                      Blocks.                 (line  44)
* Move block <^K+Shift+V>:               Rectangular Blocks.     (line  36)
* Move block <^K+V>:                     Blocks.                 (line  59)
* Move to beginning of block <^Q-B>:     Blocks.                 (line  14)
* Move to end of block <^Q-K>:           Blocks.                 (line  19)
* Page down <PgDn>:                      Cursor movement.        (line  61)
* Page up <PgUp>:                        Cursor movement.        (line  56)
* Paste from Clipboard <Shift+Ins>:      Blocks.                 (line  74)
* Paste from special Clipboard <^K-Shift+P>: Rectangular Blocks. (line  48)
* Play a macro <^F10>:                   Miscellaneous keyboard commands.
                                                                 (line  86)
* PMacro's Trigger <^Space>:             Miscellaneous keyboard commands.
                                                                 (line  54)
* Read block from disk <^K-R>:           Blocks.                 (line  79)
* Replace the block by the Clipboard block <Shift+^Ins>: Blocks. (line  89)
* Replace the content using spaces <^K-Shift+E>: Rectangular Blocks.
                                                                 (line  56)
* Report the length of the block <^Q-L>: Blocks.                 (line 114)
* Scroll the screen one line down <^Z>:  Cursor movement.        (line  51)
* Scroll the screen one line up <^W>:    Cursor movement.        (line  46)
* Search for ( from where the cursor is <Shift+^9>: Miscellaneous keyboard commands.
                                                                 (line  30)
* Search for ) from where the cursor is <Shift+^0>: Miscellaneous keyboard commands.
                                                                 (line  34)
* Search for [ from where the cursor is <Shift+^[>: Miscellaneous keyboard commands.
                                                                 (line  38)
* Search for ] from where the cursor is <Shift+^]>: Miscellaneous keyboard commands.
                                                                 (line  42)
* Search for close curly bracket from where the cursor is <^]>: Miscellaneous keyboard commands.
                                                                 (line  26)
* Search for open curly bracket from where the cursor is <^[>: Miscellaneous keyboard commands.
                                                                 (line  22)
* Search for the complementary pair <^Q ESC>: Miscellaneous keyboard commands.
                                                                 (line  46)
* Set beginning of block <^K-B>:         Blocks.                 (line  24)
* Set beginning of block <^K-Shift+B>:   Rectangular Blocks.     (line  20)
* Set end of block <^K-K>:               Blocks.                 (line  29)
* Set end of block <^K-Shift+K>:         Rectangular Blocks.     (line  24)
* Set marker <^K n*>:                    Miscellaneous keyboard commands.
                                                                 (line  18)
* Set the default options (Not in RHIDE) <Alt+G>: Miscellaneous keyboard commands.
                                                                 (line  66)
* Set the options for the current window (Not in RHIDE) <Alt+L>: Miscellaneous keyboard commands.
                                                                 (line  62)
* Smart Indent block <^Tab>:             Indentation.            (line  53)
* Smart tab <Tab>:                       Insert and Delete.      (line  51)
* Smart Unindent block <Shift+^Tab>:     Indentation.            (line  57)
* Start recording a macro <Shift+F10>:   Miscellaneous keyboard commands.
                                                                 (line  78)
* Stop recording a macro <Alt+F10>:      Miscellaneous keyboard commands.
                                                                 (line  82)
* Top of file <^Q-R>:                    Cursor movement.        (line  86)
* Top of window <^Q-E>:                  Cursor movement.        (line  76)
* Undo <Alt+Backspace>:                  Miscellaneous keyboard commands.
                                                                 (line  50)
* Unindent block <^K-Shift+Tab>:         Indentation.            (line  32)
* Unindent block one character - not an x position <^K-U>: Indentation.
                                                                 (line  22)
* Word left <^Left arrow>:               Cursor movement.        (line  21)
* Word right <^Right arrow>:             Cursor movement.        (line  26)
* Write block to disk <^K-W>:            Blocks.                 (line  84)



Tag Table:
Node: Top427
Node: Introduction1310
Node: Copying3222
Node: What is SETs Editor?4177
Node: About the Author5081
Node: Documentation guide6359
Node: What can be configured to make easier the operation7191
Node: What can be configured to change the look of the editor9200
Node: What can be configured to change the syntax highlighting10780
Node: Things to get help or find some definition11737
Node: Running external programs (compilers/filters/others)13363
Node: Configuration files14755
Node: Available commands and keys assignments16457
Node: Conventions17248
Node: Cursor movement18466
Node: Insert and Delete20278
Node: Blocks21780
Node: Block modes24230
Node: Selecting with the mouse or Shift25334
Node: Using the mouse25730
Node: Using the Shift key26136
Node: Indentation26511
Node: Rectangular Blocks28896
Node: Miscellaneous keyboard commands30606
Node: Keyboard configuration32574
Node: How to configure the keyboard33436
Node: Assigning a sequence of commands35262
Node: Assigning a sLisp macro36054
Node: Assigning sLisp code36514
Node: Alt key configuration36936
Node: Restoring the default keyboard assignments37793
Node: Consulting scan codes38237
Node: Pull-down menues38637
Node: File39255
Node: Open39679
Node: New40325
Node: Open Read-only copy40815
Node: Save41311
Node: Save as41720
Node: Save as UNIX or DOS42207
Node: Save as DOS or UNIX42811
Node: Save with same time43270
Node: Save all43834
Node: Print44034
Node: Print Setup44807
Node: Shell47139
Node: Quit47434
Node: Exit47915
Node: Edit48231
Node: Undo48777
Node: Redo49013
Node: Cut49191
Node: Copy49429
Node: Paste49640
Node: Show clipboard49912
Node: Clear50132
Node: Set Local50358
Node: Set Global50960
Node: Expand all tabs51763
Node: Compact text52101
Node: Copy to Windows Clipboard52490
Node: Paste from Windows Clipboard53118
Node: Copy to file Clipboard53637
Node: Paste from file Clipboard54141
Node: Push cursor position54633
Node: Pop cursor position55068
Node: Case (Menu)55493
Node: Block to upper55877
Node: Block to lower56116
Node: Character toggle56360
Node: Block invert56653
Node: Block alternate56920
Node: Insert new line (do not move)57264
Node: Search57666
Node: Find58245
Node: Regular Expressions Options60634
Node: Replace62020
Node: Search again62698
Node: Name current function62932
Node: Jump to function63344
Node: Jump to prototype65188
Node: Jump to symbol65707
Node: Go to line66378
Node: Class browser66629
Node: Word completion68416
Node: Jump to last cursor position69338
Node: Jump to last undo position69731
Node: Macro70087
Node: Record (Macro)70444
Node: Stop (Macro)70715
Node: Play (Macro)70939
Node: Choose (Macro)71210
Node: Repeat (Macro)71533
Node: Generate Code71946
Node: Run selected code72369
Node: Enter code to run72616
Node: Pseudo Macro (menu)72912
Node: Rectangle73477
Node: Start (Rectangle)74126
Node: End (Rectangle)74468
Node: Hide (Rectangle)74815
Node: Copy (Rectangle)75140
Node: Copy to clipboard (Rectangle)75614
Node: Paste (Rectangle)76016
Node: Paste from clipboard (Rectangle)76416
Node: Cut (Rectangle)76919
Node: Delete (Rectangle)77314
Node: Move (Rectangle)77638
Node: Copy and Paste (Rectangle)77995
Node: Clear (Rectangle)78528
Node: To upper (Rectangle)78879
Node: To lower (Rectangle)79472
Node: Windows80039
Node: Size/move80356
Node: Zoom81113
Node: Tile81490
Node: Cascade81694
Node: Next (Window)81901
Node: Previous (Window)82452
Node: Close83023
Node: List83282
Node: User Screen84529
Node: Tool&Ops84756
Node: Options85252
Node: Customize Colors86211
Node: Color Palette87648
Node: Color Theme88585
Node: Editor General88948
Node: Check for modified files96175
Node: Screen Saver99096
Node: SDG Options100676
Node: Run program (which one)101631
Node: Keyboard107724
Node: Key assignment108075
Node: Setup Alt keys108501
Node: Key pad behavior108828
Node: Back to defaults109400
Node: Consult scan codes109766
Node: Screen Options110189
Node: Encodings113609
Node: Fonts116865
Node: User Words118087
Node: Default global edition119489
Node: File open dialog123331
Node: Do not create backups for123642
Node: Search files under cursor in124842
Node: List of tag files126394
Node: Tag files options127301
Node: Regenerate central file128656
Node: Calendar options129133
Node: Advice dialogs130336
Node: Calculator (command/menu)130858
Node: SDG131136
Node: Run program131429
Node: Grep131702
Node: HTML Accents134118
Node: Convert accents to tags134468
Node: Convert tags to accents134935
Node: Export as HTML135321
Node: Insert key name136491
Node: Remap code page136940
Node: Profile Editor137988
Node: Redraw screen138306
Node: Paste Emacs mode138621
Node: Block quoted printable decode139252
Node: Un/Indent block139731
Node: Indent one space140138
Node: Unindent one character140422
Node: Indent one tab or gap140732
Node: Unindent one tab or gap141069
Node: Comment indent141418
Node: Comment unindent142014
Node: Arbitrary indent142728
Node: Delete memorized backups143066
Node: Project143567
Node: Open (Project)145295
Node: Close (Project)145550
Node: Save (Project)145759
Node: Save desktop here146049
Node: Export project146456
Node: Import project items146748
Node: Help147366
Node: InfView147534
Node: Another InfView147752
Node: Tip of the day148364
Node: Syntax help149525
Node: Options (Syntax help)150157
Node: Files to search (Syntax help)151326
Node: Search (Syntax help)152585
Node: Menues configuration152944
Node: SubMenu and EndSubMenu154216
Node: Key names155235
Node: MenuItem entries157653
Node: Commands in menu items158404
Node: MenuItemC entries159064
Node: MenuSeparator159702
Node: The special submenu used for the right click159974
Node: Status bar ranges160452
Node: Visible status bar entries161105
Node: Invisible status bar entries161533
Node: Conditional menu entries161954
Node: Comments in menu files165736
Node: Editing Modes166079
Node: Overwrite166845
Node: Autoindent167133
Node: Real Tabs167517
Node: Persistent Blocks169612
Node: Intelligent indent169907
Node: Can you explain more about the behavior of this mode?171907
Node: Do you have more examples?175033
Node: Column cursor176964
Node: Row cursor177477
Node: Match pair highlight177797
Node: Match pair on the fly178822
Node: Do not wait to search the pair179555
Node: Transparent Blocks180050
Node: Optimal Fill180442
Node: Wrap Words180917
Node: Do not move the cursor on Paste181546
Node: Scroll Lock centers181941
Node: See Tabs182443
Node: Do not move inside tabs182958
Node: Tab smart indents183877
Node: Use indent size184966
Node: Keep trailing whitespace185563
Node: Backspace unindents186096
Node: Column Markers186775
Node: Syntax Highlighting187375
Node: Syntax Highlighting File190128
Node: AllowedInsideNames192735
Node: CanStartAName193159
Node: Case193549
Node: CloseComment1193980
Node: EmacsModes194383
Node: EOLCInFirstCol194921
Node: EOLCInFirstCol1195200
Node: EOLCInFirstCol2195464
Node: EOLCInFirstUse1195729
Node: EOLCInFirstUse2196065
Node: EOLComment1196399
Node: Escape196828
Node: EscapeAnywhere197056
Node: Files197317
Node: FullNameMatch197951
Node: HexMarker198359
Node: Keywords198721
Node: Name198982
Node: NameMatch199219
Node: NLIndent199604
Node: AutoIndent (action)200501
Node: FirstWord (condition)200946
Node: MoveAfterPar (action)201563
Node: NoLastChar (condition)201950
Node: ParBalanceNeg (condition)202303
Node: ParBalancePos (condition)202620
Node: Unindent (action)202933
Node: NoCheckNumbers203257
Node: OpenComment1203469
Node: Format of short syntax highlighting definitions204000
Node: PartialKeywords204842
Node: PMacros205313
Node: Preprocessor205742
Node: RelaxNumberCheck205946
Node: ShellScript206336
Node: ShortString206915
Node: SpecialSymbol207213
Node: String1207756
Node: Symbols1208158
Node: Symbols2208402
Node: UseInternal208652
Node: UserKeywords209129
Node: VHDLNumbers209461
Node: VHDLStr1209856
Node: VHDLStr2210184
Node: Pseudo Macros210492
Node: Please enlighten me - what is that?210845
Node: How can I customize that?212127
Node: General customization212416
Node: Asking for user defined values215938
Node: Executing sLisp code from a pmacro217454
Node: sLisp macros218443
Node: How to write a sLisp macro219882
Node: How strings are parsed220799
Node: Running programs with a macro221818
Node: General sLisp commands222549
Node: and223372
Node: Operator = (assign)223833
Node: Operator & (bitwise and)224092
Node: cond224541
Node: Operator -- (decrement)224940
Node: Operator != (different)225473
Node: Operator == (equal)225901
Node: eval226327
Node: exitloop226732
Node: gstr226908
Node: if227179
Node: Operator ++ (increment)227726
Node: left228244
Node: length228496
Node: loop228730
Node: Operator ~ (negated)229071
Node: not229374
Node: or229624
Node: Operator | (bitwise or)229982
Node: Operator + (plus)230387
Node: prex230911
Node: repeat231914
Node: right232273
Node: setv232509
Node: ShortFileName233254
Node: sstr233631
Node: strcasecmp233944
Node: strcmp234197
Node: strstr234517
Node: strxlt234965
Node: substr235310
Node: Operator - (substraction)235756
Node: tostr236074
Node: Editor specific commands236287
Node: AskString237249
Node: BindKey237584
Node: CloseWindowNumber239249
Node: ComplChoose239555
Node: defmacro240534
Node: EvalString240838
Node: FindAgain241064
Node: FindString241500
Node: ForceUpdate245125
Node: GetCursorX245502
Node: GetCursorY245747
Node: GetCurWindowNumber245999
Node: GetMaxWindowNumber246274
Node: GetMaxProjectItem246594
Node: GetProjectItem246976
Node: GetSystemInfo247427
Node: getenv248525
Node: GetSelection248872
Node: GetSyntaxAtCursor249157
Node: GetSyntaxLang251434
Node: GetWrapCol251752
Node: GetWindowCols252134
Node: GetWindowRows252530
Node: InsertText252926
Node: KeyBindings253421
Node: MessageBox254045
Node: OpenFile254838
Node: ReplaceAgain255295
Node: ReplaceString255767
Node: RunProgram257297
Node: RunProgramRedir258757
Node: SelectionExists259499
Node: SelectWindowNumber259763
Node: SendCommands260521
Node: SetCursorXY260901
Node: ShowInMessageWindow261413
Node: ShowInStatusLine261924
Node: WhichEditor262348
Node: WordUnderCursor263203
Node: Writing macros that use text filters263939
Node: How to use Setedit for something it was not meant to264683
Node: Step 1 - Building your macro266614
Node: Step 2 - The filter program268627
Node: Step 3 - Binding your script to a keystroke273672
Node: Examples275411
Node: Calculator278583
Node: How to contact me282012
Node: Bugs282296
Node: TAGS files282825
Node: What are tags?283645
Node: Which program is used to generate TAGS files?284351
Node: How should I generate the tags?284876
Node: Can these files be created and updated by the editor?285967
Node: What is the easiest way to use tags?286637
Node: What can I do with tags?287512
Node: Technical details about tags287958
Node: Debugging288941
Node: Supported platforms for debugging290071
Node: Mechanism used to debug291415
Node: Quick start to debugging292940
Node: Supported debug targets294609
Node: Available debug options295602
Node: Debug options295990
Node: Path for sources297924
Node: Messages displayed299382
Node: Advanced debug options300712
Node: Debugging states303232
Node: Going to the connected debug state305312
Node: Going to the ready to run debug state305989
Node: Running the program to debug306783
Node: Stopping the program you are debugging307844
Node: Breakpoints308548
Node: Advanced breakpoint options309660
Node: Watchpoints312117
Node: Examining data313727
Node: Evaluate or Modify expression314593
Node: Watch an expression315849
Node: Watch an expression with scope316737
Node: Inspectors317759
Node: Data Window319891
Node: File - Read block (DW)322255
Node: File - Write block (DW)322849
Node: Move - Up (DW)323412
Node: Move - Down (DW)323902
Node: Move - Right (DW)324399
Node: Move - Left (DW)324715
Node: Move - Page down (DW)325031
Node: Move - Page up (DW)325441
Node: Move - First column (DW)325853
Node: Move - Last column (DW)326155
Node: Move - First row (DW)326458
Node: Move - Last row (DW)326769
Node: Move - First addr increment (DW)327084
Node: Move - First addr decrement (DW)327485
Node: Address - Change base address (DW)327900
Node: Address - Go to new address (DW)328461
Node: Address - Follow pointer (DW)328951
Node: Address - Follow pointer in new window (DW)329416
Node: Address - Recompute address (DW)329966
Node: Mode - Toggle auto follow (DW)330482
Node: Mode - Change display mode (DW)331104
Node: Mode - Toggle endian mode (DW)331928
Node: Mode - Change radix (DW)332546
Node: Block - Fill (DW)333046
Node: Block - Clear (DW)333578
Node: Block - Move (DW)334055
Node: Various - Less bytes per line (DW)334584
Node: Various - More bytes per line (DW)334993
Node: Various - Update memory (DW)335413
Node: Data Window Limitations and Details335789
Node: Stack window337204
Node: Resuming the execution of the program337943
Node: Continue execution339259
Node: Step over339777
Node: Trace into340319
Node: Executing until cursor position is reached340968
Node: Executing until return341456
Node: Returning immediatly342064
Node: Finishing and restarting a debug session342607
Node: Killing the program you are debugging343752
Node: Closing the debug session344356
Node: Destroying the debug session344958
Node: Examining the calling stack345582
Node: Cleaning the debug session346460
Node: Selecting the thread to debug347369
Node: Disassembler Window348348
Node: Debugging already running processes350456
Node: Debug Messages Window351865
Node: Editing a debug expression352801
Node: Debugging in the Linux console353178
Node: Miscellaneous354198
Node: Configuration files location354684
Node: Configuration directories for DOS and Windows355452
Node: Configuration directories for POSIX systems356938
Node: Clipboard358345
Node: Time and date modifiers formats359450
Node: Regular Expressions361454
Node: Desktop Files370597
Node: Text mode attributes371961
Node: File Open374711
Node: Sorting of the files and directories in the dialog377234
Node: Files and directories excluded in the dialog380119
Node: Message Window381285
Node: Error messages from an external application382727
Node: Mouse under Linux384430
Node: Passing extra command line options385337
Node: How to run setedit remotely without root installation (UNIX)386604
Node: Index390498
Node: Index of key commands446262

End Tag Table
